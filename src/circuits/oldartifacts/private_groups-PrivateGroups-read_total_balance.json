{
  "noir_version": "0.35.0+df29d315d6b71131ffe0180c97130395edb2e4ba-aarch64",
  "hash": 0,
  "abi": {
    "error_types": {
      "16137133351287663689": {
        "error_kind": "fmtstring",
        "item_types": [],
        "length": 17
      }
    },
    "parameters": [
      {
        "name": "inputs",
        "type": {
          "fields": [
            {
              "name": "call_context",
              "type": {
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::function_selector::FunctionSelector"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::call_context::CallContext"
              }
            },
            {
              "name": "historical_header",
              "type": {
                "fields": [
                  {
                    "name": "last_archive",
                    "type": {
                      "fields": [
                        {
                          "name": "root",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "next_available_leaf_index",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                    }
                  },
                  {
                    "name": "content_commitment",
                    "type": {
                      "fields": [
                        {
                          "name": "num_txs",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "txs_effects_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "in_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "out_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::content_commitment::ContentCommitment"
                    }
                  },
                  {
                    "name": "state",
                    "type": {
                      "fields": [
                        {
                          "name": "l1_to_l2_message_tree",
                          "type": {
                            "fields": [
                              {
                                "name": "root",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "next_available_leaf_index",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                          }
                        },
                        {
                          "name": "partial",
                          "type": {
                            "fields": [
                              {
                                "name": "note_hash_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "nullifier_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "public_data_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::partial_state_reference::PartialStateReference"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::state_reference::StateReference"
                    }
                  },
                  {
                    "name": "global_variables",
                    "type": {
                      "fields": [
                        {
                          "name": "chain_id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "version",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "block_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "slot_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "timestamp",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        },
                        {
                          "name": "coinbase",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::eth_address::EthAddress"
                          }
                        },
                        {
                          "name": "fee_recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "gas_fees",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::global_variables::GlobalVariables"
                    }
                  },
                  {
                    "name": "total_fees",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::header::Header"
              }
            },
            {
              "name": "tx_context",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "version",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "gas_settings",
                    "type": {
                      "fields": [
                        {
                          "name": "gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "teardown_gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "max_fees_per_gas",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        },
                        {
                          "name": "inclusion_fee",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::gas_settings::GasSettings"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::transaction::tx_context::TxContext"
              }
            },
            {
              "name": "start_side_effect_counter",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
        },
        "visibility": "private"
      },
      {
        "name": "creditor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      },
      {
        "name": "debtor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "fields": [
          {
            "name": "call_context",
            "type": {
              "fields": [
                {
                  "name": "msg_sender",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "storage_contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "function_selector",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::function_selector::FunctionSelector"
                  }
                },
                {
                  "name": "is_delegate_call",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "is_static_call",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::call_context::CallContext"
            }
          },
          {
            "name": "args_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "returns_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "min_revertible_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "is_fee_payer",
            "type": {
              "kind": "boolean"
            }
          },
          {
            "name": "max_block_number",
            "type": {
              "fields": [
                {
                  "name": "_opt",
                  "type": {
                    "fields": [
                      {
                        "name": "_is_some",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "_value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::option::Option"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::max_block_number::MaxBlockNumber"
            }
          },
          {
            "name": "note_hash_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "nullifier_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "key_validation_requests_and_generators",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "request",
                    "type": {
                      "fields": [
                        {
                          "name": "pk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        },
                        {
                          "name": "sk_app",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                    }
                  },
                  {
                    "name": "sk_app_generator",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
              }
            }
          },
          {
            "name": "note_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::note_hash::NoteHash"
              }
            }
          },
          {
            "name": "nullifiers",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::nullifier::Nullifier"
              }
            }
          },
          {
            "name": "private_call_requests",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "returns_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "start_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::private_call_request::PrivateCallRequest"
              }
            }
          },
          {
            "name": "public_call_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::public_call_request::PublicCallRequest"
              }
            }
          },
          {
            "name": "public_teardown_call_request",
            "type": {
              "fields": [
                {
                  "name": "contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "args_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::public_call_request::PublicCallRequest"
            }
          },
          {
            "name": "l2_to_l1_msgs",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
              }
            }
          },
          {
            "name": "start_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "end_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "note_encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "note_hash_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::NoteLogHash"
              }
            }
          },
          {
            "name": "encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::EncryptedLogHash"
              }
            }
          },
          {
            "name": "unencrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::LogHash"
              }
            }
          },
          {
            "name": "historical_header",
            "type": {
              "fields": [
                {
                  "name": "last_archive",
                  "type": {
                    "fields": [
                      {
                        "name": "root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "next_available_leaf_index",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                  }
                },
                {
                  "name": "content_commitment",
                  "type": {
                    "fields": [
                      {
                        "name": "num_txs",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "txs_effects_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "in_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "out_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::content_commitment::ContentCommitment"
                  }
                },
                {
                  "name": "state",
                  "type": {
                    "fields": [
                      {
                        "name": "l1_to_l2_message_tree",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "partial",
                        "type": {
                          "fields": [
                            {
                              "name": "note_hash_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "nullifier_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "public_data_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::partial_state_reference::PartialStateReference"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::state_reference::StateReference"
                  }
                },
                {
                  "name": "global_variables",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "block_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "slot_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "timestamp",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 64
                        }
                      },
                      {
                        "name": "coinbase",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "fee_recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "gas_fees",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::global_variables::GlobalVariables"
                  }
                },
                {
                  "name": "total_fees",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::header::Header"
            }
          },
          {
            "name": "tx_context",
            "type": {
              "fields": [
                {
                  "name": "chain_id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "version",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "gas_settings",
                  "type": {
                    "fields": [
                      {
                        "name": "gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "teardown_gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "max_fees_per_gas",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      },
                      {
                        "name": "inclusion_fee",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::gas_settings::GasSettings"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::transaction::tx_context::TxContext"
            }
          }
        ],
        "kind": "struct",
        "path": "protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
      },
      "visibility": "databus"
    }
  },
  "bytecode": "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",
  "debug_symbols": "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9+Vc7w774nvnrhf25VzvjvtyrnfHfTnXu+O+0NmXYV/O9e64L+d6d9yXc7077su53h335VzvDvvyfXfPm/TlXO+O+3Kud8d9Ode7477Q2ZdhX8717rgv53p33JdzvTvuy7neHfflXO8O++J817/X9eVc7477cq53x30517vjvtDZl2FfzvXuuC/nenfcl3O9O+7Lud4d9+Vc7w774nsfxBf25Qvtif18wpjvHQiXnqnvNenKM6Vvc6a+140rz9T3SvBjZ/r82ut7bbfyTH2v1laeqe/118Iz9b1j29Iz/UL3BBfPy+6+90t7cW++0L3B5b2hszcPe3PuXfC4N+feBY9743ufMdy296h0F7KXg3+y973D14y97721Juydb5c1Y+97B6wZe9+bWs3Y+97vacaeQrP3vb/pjL3vnUVn7ENnre/dfKbsA2ctpOR7a5w5/cBpe6UfOG6v9APn7ZV+4MC90g+cuFf6gSP3Sj9w5l7pBw7dK/3Yqet7g445/dip63u7izn92Knre/OIOf3Yqet7K4Y5/dip63tjgzn92Knre5uAOf3Yqet76P6cfuzU9T3Cfk4/dur6Hgg/px87dX2PV5/Tj526voeVz+nHTl3fo7/n9GOnru9B2nP6sVPX91jqOf3Yqet7yPOcfuzU9T0yeU4/dur6HkA8px87dX2P853Tj526vofjzunHTl3fo2bn9GOnru/BrXP6sVPX9xjUOf3Yqet7qOicfuzU9T2ic04/dur6Hng5px87dX2Pj5zTj526vocxzunHTl3fow3n9GOnru9BgXP6sVPX99i9Of3Yqet7iN2cfuzU9T1Abk4/dur6HvU2px87dX0PZZvTj526vsenzenHTl3fg87m9GOnru8BY3P6sVPX95iuOf3Yqet72NWcfuzUjTyQ6ko/dupGHkl1pR87dSMPpbrSj526kcdSXenHTt3Ig6mu9GOnbuTRVFf6oVMXYs+mgtizqSD2bCqIPZsKUujUhdizqSD2bCqIPZsKYs+mgtizqSD2bCqIPZsKYs+mgtizqSD2bCoYz6bqmfNbWUeo9/TfyqqsrMnKWFbWRWXjmT/zMpCVZVkZyspIViZTSZapJMtUkmUqyTKVoEwlKFMJylSCMpWgTCUoUwnKVIIylaBMJShTCclUQjKVkEwlJFMJyVRCMpWQTCUkUwnJVEIylRSZSopM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",
  "file_map": {
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
    },
    "24": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "25": {
      "path": "std/field/bn254.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "26": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"
    },
    "29": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"
    },
    "34": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "35": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"
    },
    "58": {
      "path": "std/option.nr",
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "59": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "65": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "68": {
      "path": "std/uint128.nr",
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"
    },
    "70": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/NewAddressNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: u32 = 3;\n// CARD_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: u32 = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\n#[derive(Deserialize)]\nstruct NewAddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let header = NoteHeader::empty();\n        NewAddressNote { address, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//serialize is a macro now?\n// impl Serialize<3> for NewAddressNote {\n//     fn serialize(self) -> [Field; 3] {\n//         [self.address.to_field(), self.shared_secret, self.npk_m_hash.to_field()]\n//     }\n// }\n\n"
    },
    "71": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/StringNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n//going to make the max length 10 characters just to keep it simple\n//pretty sure the only thing that this changes is the amount of compute needed\nglobal STRING_NOTE_LENGTH: Field = 3;\nglobal STRING_NOTE_BYTES_LENGTH: Field = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n"
    },
    "80": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PrivateGroups {\n\n    use dep::aztec::{prelude::{Map, AztecAddress, PrivateImmutable, PrivateSet}};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use value_note::{balance_utils, utils::{increment, decrement}, value_note::ValueNote};\n    use std::hash::pedersen_hash;\n    use aztec::context::inputs::private_context_inputs::PrivateContextInputs;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    //Storage for the contract, we have an admin that creates the group, they add members to the group, and they can add notes to the group\n    //The reason there is a credit and a debt is for note tracking.\n\n    #[storage]\n   struct Storage<Context> {\n        admin: PrivateImmutable<NewAddressNote, Context>,\n        group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        group_balances_credit: Map<Field, PrivateSet<ValueNote,Context>, Context>,\n        group_balances_debt: Map<Field, PrivateSet<ValueNote, Context>, Context>,\n   }\n\n    //The Constructor\n    // - Admin creates the group\n    // - Admin adds members to the group\n    // - Each group member is added to a private set of members so that they can see all of the members\n    // - This is very expensive, highlights some of the inefficiencies of the current system\n    // - Since the 0.57 update, this cannot compile, it uses too much memory. I have to get rid of the group member logic which doesnt allow for access gating\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 3]) {\n        //setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let mut admin_address_note = NewAddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n        // this is for adding members to the private set, so they can see the other members, going to be expensive\n        for i in 0..3 {\n            let member = group_members[i as u32];\n            if (member != ZERO_ADDRESS) {\n                let member_keys = get_public_keys(member);\n                for i in 0..3 {\n                    let member_add = group_members[i as u32];\n                    let mut memberNote = NewAddressNote::new(member_add, member_keys.npk_m.hash());\n                    storage.group_members.at(member).insert(&mut memberNote).emit(\n                        encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, member_keys.ivpk_m, member)\n                    );\n                }\n            }\n        }\n    }\n\n    //need to constrain this so that only group members can read this \n    #[private]\n    fn get_admin() -> pub AztecAddress {\n        let admin_note = storage.admin.get_note();\n        admin_note.address\n    }\n\n    //For each group member, we have a private set of members so that they can see all of the members\n    #[private]\n    fn get_group_members(member: AztecAddress) -> [AztecAddress; 3] {\n        let mut options = NoteGetterOptions::new();\n        let member_note = storage.group_members.at(member).get_notes(options);\n        let mut member_array : [AztecAddress; 3] = [ZERO_ADDRESS; 3];\n        //if you call this and u are not part of the group, it will return the zero address\n        for i in 0..3 {\n            let note = member_note.get_unchecked(i);\n            let address: AztecAddress = note.address;\n            member_array[i] = address;\n        }\n        member_array\n    }\n\n    //Setting the balance for the creditor and debtor\n    #[private]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        //TODO:: add assertions here to make sure that the creditor and debtor are part of the group\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, amount, debtor, creditor);\n    }\n\n    //can have a timestamp here for when the payment is made. \n    #[private]\n    fn make_payment(debtor: AztecAddress, creditor: AztecAddress, amount: Field) {\n        //do not do any assertions for now\n        //reason it does a increment with a negative amount is because decrement would not work.\n        //it always failed an assertion. \n        let new_amount = amount * -1;\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, new_amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, new_amount, debtor, creditor);\n    }\n\n    #[private]\n    fn setup_group_payments(creditor: AztecAddress, debtors: [AztecAddress; 2], amount: Field) {\n        //can be called by anyone\n\n        //increase the credit for the creditor with each member\n        let shared_amount : u32 = amount as u32 / (debtors.len() + 1);\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n            let loc_credit = storage.group_balances_credit.at(key);\n            increment(loc_credit, shared_amount.to_field(), creditor, debtor);\n        }\n        //increase the debt for each member with the creditor\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n            let loc_debt = storage.group_balances_debt.at(key);\n            increment(loc_debt, shared_amount.to_field(), debtor, creditor);\n        }\n    }\n\n    #[private]\n    fn read_balance_credit(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //for this function i need to also get the notes that the debtor has sent if they have sent any\n        //if they have sent new notes, i need to nullify the old ones that i have sent to the debtor\n        //make a new one with the new outstanding balance\n        //tricky part is listening for new notes that the debtor has sent, updating the balance\n\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                let note = balance_notes_credit.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_balance_debt(debtor: AztecAddress, creditor: AztecAddress) -> u64 {\n        let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_total_balance(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //going to have to hand type this, could not call the other private functions\n\n        //keys to check in storage\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n\n        //options for the notes \n        let options_1 = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options_1);\n\n        let options_2 = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options_2);\n\n        //sum the notes\n        let mut total_balance_credit = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                // let note = balance_notes_credit.get_unchecked(i);\n                let note = balance_notes_credit.get(i);\n                total_balance_credit += note.value;\n            }\n        }\n\n        //sum the notes\n        let mut total_balance_debt = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get(i);\n                total_balance_debt += note.value;\n            }\n        }\n\n        //convert the note to integer\n\n        let total_debt = U128::from_integer(total_balance_debt);\n        let total_credit = U128::from_integer(total_balance_credit);\n        let tot_debt: i64 = total_debt.to_integer();\n        let tot_credit: i64 = total_credit.to_integer();\n        let total_balance = tot_credit - tot_debt;\n        total_balance as u64\n        // let total_balance = total_credit - total_debt;\n        // total_balance\n    }\n\n    // #[private]\n    // fn read_total_balance_2(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n\n    //     let total_balance_credit = read_balance_credit(&mut context, creditor, debtor);\n    //     let total_balance_debt = read_balance_debt(&mut context, debtor, creditor);\n    //     let total_balance = total_balance_credit - total_balance_debt;\n\n    //     total_balance    \n    // }\n\n    unconstrained pub(crate) fn admin() -> pub AztecAddress {\n        let admin_note: NewAddressNote = storage.admin.view_note();\n        admin_note.address\n    }\n}\n\n//TODO:: add the token transfer, have tests for that too. \n//add block time to storage for notes being paid\n"
    },
    "82": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/address-note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "88": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "89": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "91": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"
    },
    "94": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "103": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "105": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "110": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"
    },
    "112": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext}};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"
    },
    "125": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "126": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "128": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "129": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"
    },
    "130": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "131": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "135": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"
    },
    "139": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"
    },
    "143": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr",
      "source": "// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"
    },
    "147": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"
    },
    "165": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"
    },
    "166": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "169": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "171": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"
    },
    "179": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "186": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "232": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"
    },
    "310": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "311": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "317": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    public_keys::PublicKeys, contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys : PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11]\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize(\n                [\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15]\n            ]\n            )\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"
    },
    "318": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n    partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n    salted_initialization_hash::SaltedInitializationHash\n},\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(contract_class_id, salted_initialization_hash);\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "320": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "321": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "325": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "327": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(_vk: VerificationKey<N>) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "328": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "358": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/utils.nr",
      "source": "use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(\n        encode_and_encrypt_note(\n            balance.context,\n            outgoing_viewer_ovpk_m,\n            recipient_keys.ivpk_m,\n            recipient\n        )\n    );\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n"
    },
    "359": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "decompose_hint",
    "get_notes_internal",
    "get_collapse_hints",
    "pack_returns_oracle_wrapper",
    "directive_invert",
    "directive_integer_quotient"
  ]
}