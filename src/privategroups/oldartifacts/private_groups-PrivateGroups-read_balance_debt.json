{
  "noir_version": "0.35.0+df29d315d6b71131ffe0180c97130395edb2e4ba-aarch64",
  "hash": 0,
  "abi": {
    "error_types": {
      "16137133351287663689": {
        "error_kind": "fmtstring",
        "item_types": [],
        "length": 17
      }
    },
    "parameters": [
      {
        "name": "inputs",
        "type": {
          "fields": [
            {
              "name": "call_context",
              "type": {
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::function_selector::FunctionSelector"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::call_context::CallContext"
              }
            },
            {
              "name": "historical_header",
              "type": {
                "fields": [
                  {
                    "name": "last_archive",
                    "type": {
                      "fields": [
                        {
                          "name": "root",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "next_available_leaf_index",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                    }
                  },
                  {
                    "name": "content_commitment",
                    "type": {
                      "fields": [
                        {
                          "name": "num_txs",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "txs_effects_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "in_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "out_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::content_commitment::ContentCommitment"
                    }
                  },
                  {
                    "name": "state",
                    "type": {
                      "fields": [
                        {
                          "name": "l1_to_l2_message_tree",
                          "type": {
                            "fields": [
                              {
                                "name": "root",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "next_available_leaf_index",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                          }
                        },
                        {
                          "name": "partial",
                          "type": {
                            "fields": [
                              {
                                "name": "note_hash_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "nullifier_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "public_data_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::partial_state_reference::PartialStateReference"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::state_reference::StateReference"
                    }
                  },
                  {
                    "name": "global_variables",
                    "type": {
                      "fields": [
                        {
                          "name": "chain_id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "version",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "block_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "slot_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "timestamp",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        },
                        {
                          "name": "coinbase",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::eth_address::EthAddress"
                          }
                        },
                        {
                          "name": "fee_recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "gas_fees",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::global_variables::GlobalVariables"
                    }
                  },
                  {
                    "name": "total_fees",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::header::Header"
              }
            },
            {
              "name": "tx_context",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "version",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "gas_settings",
                    "type": {
                      "fields": [
                        {
                          "name": "gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "teardown_gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "max_fees_per_gas",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        },
                        {
                          "name": "inclusion_fee",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::gas_settings::GasSettings"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::transaction::tx_context::TxContext"
              }
            },
            {
              "name": "start_side_effect_counter",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
        },
        "visibility": "private"
      },
      {
        "name": "debtor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      },
      {
        "name": "creditor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "fields": [
          {
            "name": "call_context",
            "type": {
              "fields": [
                {
                  "name": "msg_sender",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "storage_contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "function_selector",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::function_selector::FunctionSelector"
                  }
                },
                {
                  "name": "is_delegate_call",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "is_static_call",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::call_context::CallContext"
            }
          },
          {
            "name": "args_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "returns_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "min_revertible_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "is_fee_payer",
            "type": {
              "kind": "boolean"
            }
          },
          {
            "name": "max_block_number",
            "type": {
              "fields": [
                {
                  "name": "_opt",
                  "type": {
                    "fields": [
                      {
                        "name": "_is_some",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "_value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::option::Option"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::max_block_number::MaxBlockNumber"
            }
          },
          {
            "name": "note_hash_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "nullifier_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "key_validation_requests_and_generators",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "request",
                    "type": {
                      "fields": [
                        {
                          "name": "pk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        },
                        {
                          "name": "sk_app",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                    }
                  },
                  {
                    "name": "sk_app_generator",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
              }
            }
          },
          {
            "name": "note_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::note_hash::NoteHash"
              }
            }
          },
          {
            "name": "nullifiers",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::nullifier::Nullifier"
              }
            }
          },
          {
            "name": "private_call_requests",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "returns_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "start_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::private_call_request::PrivateCallRequest"
              }
            }
          },
          {
            "name": "public_call_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::public_call_request::PublicCallRequest"
              }
            }
          },
          {
            "name": "public_teardown_call_request",
            "type": {
              "fields": [
                {
                  "name": "contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "args_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::public_call_request::PublicCallRequest"
            }
          },
          {
            "name": "l2_to_l1_msgs",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
              }
            }
          },
          {
            "name": "start_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "end_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "note_encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "note_hash_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::NoteLogHash"
              }
            }
          },
          {
            "name": "encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::EncryptedLogHash"
              }
            }
          },
          {
            "name": "unencrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::LogHash"
              }
            }
          },
          {
            "name": "historical_header",
            "type": {
              "fields": [
                {
                  "name": "last_archive",
                  "type": {
                    "fields": [
                      {
                        "name": "root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "next_available_leaf_index",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                  }
                },
                {
                  "name": "content_commitment",
                  "type": {
                    "fields": [
                      {
                        "name": "num_txs",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "txs_effects_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "in_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "out_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::content_commitment::ContentCommitment"
                  }
                },
                {
                  "name": "state",
                  "type": {
                    "fields": [
                      {
                        "name": "l1_to_l2_message_tree",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "partial",
                        "type": {
                          "fields": [
                            {
                              "name": "note_hash_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "nullifier_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "public_data_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::partial_state_reference::PartialStateReference"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::state_reference::StateReference"
                  }
                },
                {
                  "name": "global_variables",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "block_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "slot_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "timestamp",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 64
                        }
                      },
                      {
                        "name": "coinbase",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "fee_recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "gas_fees",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::global_variables::GlobalVariables"
                  }
                },
                {
                  "name": "total_fees",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::header::Header"
            }
          },
          {
            "name": "tx_context",
            "type": {
              "fields": [
                {
                  "name": "chain_id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "version",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "gas_settings",
                  "type": {
                    "fields": [
                      {
                        "name": "gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "teardown_gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "max_fees_per_gas",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      },
                      {
                        "name": "inclusion_fee",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::gas_settings::GasSettings"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::transaction::tx_context::TxContext"
            }
          }
        ],
        "kind": "struct",
        "path": "protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
      },
      "visibility": "databus"
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
    },
    "24": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "25": {
      "path": "std/field/bn254.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "26": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"
    },
    "29": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"
    },
    "34": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "35": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"
    },
    "58": {
      "path": "std/option.nr",
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "59": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "65": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "68": {
      "path": "std/uint128.nr",
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"
    },
    "70": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/NewAddressNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: u32 = 3;\n// CARD_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: u32 = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\n#[derive(Deserialize)]\nstruct NewAddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let header = NoteHeader::empty();\n        NewAddressNote { address, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//serialize is a macro now?\n// impl Serialize<3> for NewAddressNote {\n//     fn serialize(self) -> [Field; 3] {\n//         [self.address.to_field(), self.shared_secret, self.npk_m_hash.to_field()]\n//     }\n// }\n\n"
    },
    "71": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/StringNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n//going to make the max length 10 characters just to keep it simple\n//pretty sure the only thing that this changes is the amount of compute needed\nglobal STRING_NOTE_LENGTH: Field = 3;\nglobal STRING_NOTE_BYTES_LENGTH: Field = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n"
    },
    "80": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PrivateGroups {\n\n    use dep::aztec::{prelude::{Map, AztecAddress, PrivateImmutable, PrivateSet}};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use value_note::{balance_utils, utils::{increment, decrement}, value_note::ValueNote};\n    use std::hash::pedersen_hash;\n    use aztec::context::inputs::private_context_inputs::PrivateContextInputs;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    //Storage for the contract, we have an admin that creates the group, they add members to the group, and they can add notes to the group\n    //The reason there is a credit and a debt is for note tracking.\n\n    #[storage]\n   struct Storage<Context> {\n        admin: PrivateImmutable<NewAddressNote, Context>,\n        group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        group_balances_credit: Map<Field, PrivateSet<ValueNote,Context>, Context>,\n        group_balances_debt: Map<Field, PrivateSet<ValueNote, Context>, Context>,\n   }\n\n    //The Constructor\n    // - Admin creates the group\n    // - Admin adds members to the group\n    // - Each group member is added to a private set of members so that they can see all of the members\n    // - This is very expensive, highlights some of the inefficiencies of the current system\n    // - Since the 0.57 update, this cannot compile, it uses too much memory. I have to get rid of the group member logic which doesnt allow for access gating\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 3]) {\n        //setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let mut admin_address_note = NewAddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n        // this is for adding members to the private set, so they can see the other members, going to be expensive\n        for i in 0..3 {\n            let member = group_members[i as u32];\n            if (member != ZERO_ADDRESS) {\n                let member_keys = get_public_keys(member);\n                for i in 0..3 {\n                    let member_add = group_members[i as u32];\n                    let mut memberNote = NewAddressNote::new(member_add, member_keys.npk_m.hash());\n                    storage.group_members.at(member).insert(&mut memberNote).emit(\n                        encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, member_keys.ivpk_m, member)\n                    );\n                }\n            }\n        }\n    }\n\n    //need to constrain this so that only group members can read this \n    #[private]\n    fn get_admin() -> pub AztecAddress {\n        let admin_note = storage.admin.get_note();\n        admin_note.address\n    }\n\n    //For each group member, we have a private set of members so that they can see all of the members\n    #[private]\n    fn get_group_members(member: AztecAddress) -> [AztecAddress; 3] {\n        let mut options = NoteGetterOptions::new();\n        let member_note = storage.group_members.at(member).get_notes(options);\n        let mut member_array : [AztecAddress; 3] = [ZERO_ADDRESS; 3];\n        //if you call this and u are not part of the group, it will return the zero address\n        for i in 0..3 {\n            let note = member_note.get_unchecked(i);\n            let address: AztecAddress = note.address;\n            member_array[i] = address;\n        }\n        member_array\n    }\n\n    //Setting the balance for the creditor and debtor\n    #[private]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        //TODO:: add assertions here to make sure that the creditor and debtor are part of the group\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, amount, debtor, creditor);\n    }\n\n    //can have a timestamp here for when the payment is made. \n    #[private]\n    fn make_payment(debtor: AztecAddress, creditor: AztecAddress, amount: Field) {\n        //do not do any assertions for now\n        //reason it does a increment with a negative amount is because decrement would not work.\n        //it always failed an assertion. \n        let new_amount = amount * -1;\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, new_amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, new_amount, debtor, creditor);\n    }\n\n    #[private]\n    fn setup_group_payments(creditor: AztecAddress, debtors: [AztecAddress; 2], amount: Field) {\n        //can be called by anyone\n\n        //increase the credit for the creditor with each member\n        let shared_amount : u32 = amount as u32 / (debtors.len() + 1);\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n            let loc_credit = storage.group_balances_credit.at(key);\n            increment(loc_credit, shared_amount.to_field(), creditor, debtor);\n        }\n        //increase the debt for each member with the creditor\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n            let loc_debt = storage.group_balances_debt.at(key);\n            increment(loc_debt, shared_amount.to_field(), debtor, creditor);\n        }\n    }\n\n    #[private]\n    fn read_balance_credit(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //for this function i need to also get the notes that the debtor has sent if they have sent any\n        //if they have sent new notes, i need to nullify the old ones that i have sent to the debtor\n        //make a new one with the new outstanding balance\n        //tricky part is listening for new notes that the debtor has sent, updating the balance\n\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                let note = balance_notes_credit.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_balance_debt(debtor: AztecAddress, creditor: AztecAddress) -> u64 {\n        let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_total_balance(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //going to have to hand type this, could not call the other private functions\n\n        //keys to check in storage\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n\n        //options for the notes \n        let options_1 = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options_1);\n\n        let options_2 = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options_2);\n\n        //sum the notes\n        let mut total_balance_credit = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                // let note = balance_notes_credit.get_unchecked(i);\n                let note = balance_notes_credit.get(i);\n                total_balance_credit += note.value;\n            }\n        }\n\n        //sum the notes\n        let mut total_balance_debt = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get(i);\n                total_balance_debt += note.value;\n            }\n        }\n\n        //convert the note to integer\n\n        let total_debt = U128::from_integer(total_balance_debt);\n        let total_credit = U128::from_integer(total_balance_credit);\n        let tot_debt: i64 = total_debt.to_integer();\n        let tot_credit: i64 = total_credit.to_integer();\n        let total_balance = tot_credit - tot_debt;\n        total_balance as u64\n        // let total_balance = total_credit - total_debt;\n        // total_balance\n    }\n\n    // #[private]\n    // fn read_total_balance_2(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n\n    //     let total_balance_credit = read_balance_credit(&mut context, creditor, debtor);\n    //     let total_balance_debt = read_balance_debt(&mut context, debtor, creditor);\n    //     let total_balance = total_balance_credit - total_balance_debt;\n\n    //     total_balance    \n    // }\n\n    unconstrained pub(crate) fn admin() -> pub AztecAddress {\n        let admin_note: NewAddressNote = storage.admin.view_note();\n        admin_note.address\n    }\n}\n\n//TODO:: add the token transfer, have tests for that too. \n//add block time to storage for notes being paid\n"
    },
    "82": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/address-note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "88": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "89": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "91": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"
    },
    "94": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "103": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "105": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "110": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"
    },
    "112": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext}};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"
    },
    "125": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "126": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "128": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "129": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"
    },
    "130": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "131": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "135": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"
    },
    "139": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"
    },
    "143": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr",
      "source": "// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"
    },
    "147": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"
    },
    "165": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"
    },
    "166": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "169": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "171": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"
    },
    "179": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "186": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "232": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"
    },
    "310": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "311": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "317": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    public_keys::PublicKeys, contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys : PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11]\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize(\n                [\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15]\n            ]\n            )\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"
    },
    "318": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n    partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n    salted_initialization_hash::SaltedInitializationHash\n},\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(contract_class_id, salted_initialization_hash);\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "320": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "321": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "325": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "327": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(_vk: VerificationKey<N>) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "328": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "358": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/utils.nr",
      "source": "use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(\n        encode_and_encrypt_note(\n            balance.context,\n            outgoing_viewer_ovpk_m,\n            recipient_keys.ivpk_m,\n            recipient\n        )\n    );\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n"
    },
    "359": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "decompose_hint",
    "get_notes_internal",
    "get_collapse_hints",
    "pack_returns_oracle_wrapper",
    "directive_invert",
    "directive_integer_quotient"
  ]
}