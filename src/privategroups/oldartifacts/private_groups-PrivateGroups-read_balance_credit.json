{
  "noir_version": "0.35.0+df29d315d6b71131ffe0180c97130395edb2e4ba-aarch64",
  "hash": 0,
  "abi": {
    "error_types": {
      "16137133351287663689": {
        "error_kind": "fmtstring",
        "item_types": [],
        "length": 17
      }
    },
    "parameters": [
      {
        "name": "inputs",
        "type": {
          "fields": [
            {
              "name": "call_context",
              "type": {
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::function_selector::FunctionSelector"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::call_context::CallContext"
              }
            },
            {
              "name": "historical_header",
              "type": {
                "fields": [
                  {
                    "name": "last_archive",
                    "type": {
                      "fields": [
                        {
                          "name": "root",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "next_available_leaf_index",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                    }
                  },
                  {
                    "name": "content_commitment",
                    "type": {
                      "fields": [
                        {
                          "name": "num_txs",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "txs_effects_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "in_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "out_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::content_commitment::ContentCommitment"
                    }
                  },
                  {
                    "name": "state",
                    "type": {
                      "fields": [
                        {
                          "name": "l1_to_l2_message_tree",
                          "type": {
                            "fields": [
                              {
                                "name": "root",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "next_available_leaf_index",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                          }
                        },
                        {
                          "name": "partial",
                          "type": {
                            "fields": [
                              {
                                "name": "note_hash_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "nullifier_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "public_data_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::partial_state_reference::PartialStateReference"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::state_reference::StateReference"
                    }
                  },
                  {
                    "name": "global_variables",
                    "type": {
                      "fields": [
                        {
                          "name": "chain_id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "version",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "block_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "slot_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "timestamp",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        },
                        {
                          "name": "coinbase",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::eth_address::EthAddress"
                          }
                        },
                        {
                          "name": "fee_recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "gas_fees",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::global_variables::GlobalVariables"
                    }
                  },
                  {
                    "name": "total_fees",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::header::Header"
              }
            },
            {
              "name": "tx_context",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "version",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "gas_settings",
                    "type": {
                      "fields": [
                        {
                          "name": "gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "teardown_gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "max_fees_per_gas",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        },
                        {
                          "name": "inclusion_fee",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::gas_settings::GasSettings"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::transaction::tx_context::TxContext"
              }
            },
            {
              "name": "start_side_effect_counter",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
        },
        "visibility": "private"
      },
      {
        "name": "creditor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      },
      {
        "name": "debtor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "fields": [
          {
            "name": "call_context",
            "type": {
              "fields": [
                {
                  "name": "msg_sender",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "storage_contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "function_selector",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::function_selector::FunctionSelector"
                  }
                },
                {
                  "name": "is_delegate_call",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "is_static_call",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::call_context::CallContext"
            }
          },
          {
            "name": "args_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "returns_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "min_revertible_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "is_fee_payer",
            "type": {
              "kind": "boolean"
            }
          },
          {
            "name": "max_block_number",
            "type": {
              "fields": [
                {
                  "name": "_opt",
                  "type": {
                    "fields": [
                      {
                        "name": "_is_some",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "_value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::option::Option"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::max_block_number::MaxBlockNumber"
            }
          },
          {
            "name": "note_hash_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "nullifier_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "key_validation_requests_and_generators",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "request",
                    "type": {
                      "fields": [
                        {
                          "name": "pk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        },
                        {
                          "name": "sk_app",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                    }
                  },
                  {
                    "name": "sk_app_generator",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
              }
            }
          },
          {
            "name": "note_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::note_hash::NoteHash"
              }
            }
          },
          {
            "name": "nullifiers",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::nullifier::Nullifier"
              }
            }
          },
          {
            "name": "private_call_requests",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "returns_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "start_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::private_call_request::PrivateCallRequest"
              }
            }
          },
          {
            "name": "public_call_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::public_call_request::PublicCallRequest"
              }
            }
          },
          {
            "name": "public_teardown_call_request",
            "type": {
              "fields": [
                {
                  "name": "contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "args_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::public_call_request::PublicCallRequest"
            }
          },
          {
            "name": "l2_to_l1_msgs",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
              }
            }
          },
          {
            "name": "start_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "end_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "note_encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "note_hash_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::NoteLogHash"
              }
            }
          },
          {
            "name": "encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::EncryptedLogHash"
              }
            }
          },
          {
            "name": "unencrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::LogHash"
              }
            }
          },
          {
            "name": "historical_header",
            "type": {
              "fields": [
                {
                  "name": "last_archive",
                  "type": {
                    "fields": [
                      {
                        "name": "root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "next_available_leaf_index",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                  }
                },
                {
                  "name": "content_commitment",
                  "type": {
                    "fields": [
                      {
                        "name": "num_txs",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "txs_effects_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "in_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "out_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::content_commitment::ContentCommitment"
                  }
                },
                {
                  "name": "state",
                  "type": {
                    "fields": [
                      {
                        "name": "l1_to_l2_message_tree",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "partial",
                        "type": {
                          "fields": [
                            {
                              "name": "note_hash_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "nullifier_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "public_data_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::partial_state_reference::PartialStateReference"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::state_reference::StateReference"
                  }
                },
                {
                  "name": "global_variables",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "block_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "slot_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "timestamp",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 64
                        }
                      },
                      {
                        "name": "coinbase",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "fee_recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "gas_fees",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::global_variables::GlobalVariables"
                  }
                },
                {
                  "name": "total_fees",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::header::Header"
            }
          },
          {
            "name": "tx_context",
            "type": {
              "fields": [
                {
                  "name": "chain_id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "version",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "gas_settings",
                  "type": {
                    "fields": [
                      {
                        "name": "gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "teardown_gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "max_fees_per_gas",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      },
                      {
                        "name": "inclusion_fee",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::gas_settings::GasSettings"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::transaction::tx_context::TxContext"
            }
          }
        ],
        "kind": "struct",
        "path": "protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
      },
      "visibility": "databus"
    }
  },
  "bytecode": "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",
  "debug_symbols": "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WVwgl27fWDe4dPvGusGl2zfWDS7U1v5QLtOsY5xCfOJC7aev48KdBH8hlzfyvbty6faEpsGlX7/7mksWF8ilX7/7mku/fvc1l3797msu8ruYi/wu5MLdjeFCLvK7mIv8LuYiv4u5ZHGBXOR3MRf5XcxFfhdzkd/FXOR3IRfujigXcpHfxVzkdzEX+V3MJYsL5CK/i7nI72Iu8ruYi/wu5iK/C7lwdyW6kIv8LuYiv4u5yO9iLllcIBf5XcxFfhdzkd/FXOR3MRf5XciFuzPYhVzkdzEX+V3MRX4Xc8niArnI72Iu8ruYi/wu5iK/i7nI70Iu3N35LuQiv4u5yO9iLvK7mEsWF8hFfhdzkd/FXOR3MRf5XcxFfhdxGbl7FV7IRX4Xc5HfxVzkdzGXLC6Qi/wu5iK/i7mogzbqoD1y9yu8kAu33w1pzvesoeTXFxs7g7tT4K4z5fake86U22XuOVNu37jnTLPSjH+TZjxyd6a7mM0bOcLd2byRK9ydzRs5w93ZvNG3oXuzIe/olpbmC2N+KLK3iz/Vc/dSs9RzdzGz1HP3D7PUZ9fquXtmWeq522BZ6rk7W1nquZtVWeq5+zgZ6sk7KFnqXdda7u5CpnrXtZa7S4+p3nWt5e54Y6p3XWu5u8eY6l3XWu5OLKZ617WWu6uJqd51reXuEGKqd11rubttmOpd11ruzhWmete1lrsLhKneda3l7qhgqndda7m7E5jqXdda7qR/U73rWsudmm+qd11ruRPoTfWuay13mrup3nWt5U5GN9W7rrXcKeOmete1ljux21TvutZyp1+b6l3XWu4kaVO961rLncpsqndda7kTjk31rmstd1qwqd51reVO3jXVu6613Cm2pnrXtZY7EdZU77rWcqermupd11rupFJTvetay536aap3XWu5EzRN9a5rLXcapaneda3lTnY01buutdwpiaZ6z7W2cicOmuo919rKnd5nqvdca+vgudZW7rw6U73nWlu5s99M9Z5rbeXOUbPUc2ejmepd11ruDDNTvetay501Zqp3XWu587pM9a5rLXfmlaneda11nRtVXedGVde5UdV1blR1nRtVXedGVde5UdV1blR1nRtVXedGVde5UdV1blR1nRtVXedGVde5UdV1blR1nRtVXedGVde5UdV1blR1nRtVXedGVde5UdV1blR1nRtVXedGVde5UdV1blTlzo26rKNW5U6kuo4Ld9bVhVy67SBrcOm2g6zBpdsOsgaXTF1NSyyz+FLj64s/4n6+Lv54o+6p9JIHkO06VW6Ht+tUue3gt6ZaH6b6813gc6rc39PsOlXuL3X2nCp5wloLS/loZTKmOuS5/VcY6l1Hm2BhqkvJu4tIBV2bYkzzBON4ZxinL4bc30NxMExpXrQptfrMkPvbMB8Mub+T88Ewi+FmhtxW10dN4fbQPtYhtzn3wZDb9ftgyP044YIheTqli5pCnpHpYx3qOWU7Qz2nbGeYxXAzQz2nbK8pek7Zvg71nLKdoZ5TtjPUc8pmhuTJvhwM73+TSm14YJi/GL7Rc8ptNjPDH2PfGX5O9Y0eJ6ypvpHrt6aa32eqMcV5qjf9r28CYcrj18VxCO1+G4gV3l/K8nLQ7d85Wde3ukhp08NNJsNfUSjLr2jMjxd//ork/e37dEt1mWAJz/dpef/tDKm9//feDBzavPunMNx3M34zMKbSZuQxjaH+dP0nmzd6W313Nt2+sd7Sw7a+/+ivN0q5074v5NLtG+sGl27fWDe4dPvGusEld8tlmnWMU3h6k587r/1CLtQe+UIub+R7d+XS7QlNg0u/fvcVl8aduH8hl3797msu/frd11z69buvuWRxgVzkdzEX+V3MRX4Xc5HfxVzkdyEX7q4XF3KR38Vc5HcxF/ldzCWLC+Qiv4u5yO9iLvK7mIv8LuYivwu5cHeeuZCL/C7mIr+LucjvYi5ZXCAX+V3MRX4Xc5HfxVzkdzEX+V3Ihbv704Vc5HcxF/ldzEV+F3PJ4gK5yO9iLvK7mIv8LuYiv4u5yO9CLtwd2C7kIr+LucjvYi7yu5hLFhfIRX4Xc5HfxVzkdzEX+V3MRX4Xcum3o6DBRX4Xc5HfxVzkdzGXLC6Qi/wu5iK/i7nI72Iu8ruYi/wu5MLdX/FCLvK7mIv8LuaiDtqog3bj7ld4IRduvxvSnO9ZQ8mvL7Z2BreD3XOm3J50z5lyu8w9Z8rtG3ecKXcHu0vTjBt3Z7qL2byRI9ydzRu5wt3ZZLH5LZs3+jZ0dzbcXR3S0nxhzA9F9nbxp3ruXmqWeu4uZpZ67v5hhnryzl2Weu6eWZZ67jZYlnruzlaW+uxaPXcfJ0u961rL3bvIVO+61nL3/7HUc3fpMdW7rrXcHW9M9a5rLXf3GFO961rL3YnFVO+61nJ3NTHVe661E3eHEFO951o7cXfbMNV7rrXT4LnWTtz9JUz1nmvtxN2rwVTvudZO3H0PLPXc3QlM9a5rLXfSv6neda3lTs031buutdwJ9KZ617WWO83dVO+61nIno5vqXdda7pRxU73rWsud2G2qd11rudOvTfWuay13krSp3nWt5U5lNtW7rrXcCcemete1ljst2FTvutZyJ++a6l3XWu4UW1O961rLnQhrqndda7nTVU31rmstd1Kpqd51reVO/TTVu6613AmapnrXtZY7jdJU77rWcic7mupd11rulERTvetay504aKp3XWu50/tM9a5rLXcSnqneda3lTpUz1buutdwJbaZ617WWOxvNVO+61nJnmJnqXdda7qwxU73rWsud12Wqd11ruTOvTPWua63r3KjJdW7U5Do3anKdGzW5zo2aXOdGTa5zoybXuVGT69yoyXVu1OQ6N2pynRs1uc6NmlznRk2uc6Mm17lRk+vcqMl1btTkOjdqcp0bNbnOjZpc50ZNrnOjJs+5UXHwnBt1U++41t7UO661N/WOa+1NPXWtvaqj1o1Ltx1kDS7ddpA1uHTbQdbg0m0HWYNLtx1kX3MhzxQrscziS42vLw7jAjHUDxa/lF7yALJdp8rt8HadKrcd/NZU68NUf74LfE419zNV7i91dp0q9zdALSzlo5XJmOqQ5/ZfYah3HW2ChakuJe8uIhV0bYoxzROM451hnL4Ycn8PxcEwpXnRptTqM0Pub8N8MOT+Ts4FQ/LkPR8Mua2ui5pCnkLoYx1ym3MfDLMYbmbI/Tjhg6GeU7bXFD2nbF+Hek7ZzlDPKZsZkqeW+mCo55TNNYU8wdXHOtRzynaGWQw3M9RzynaGek6xGd7/JpXa8MAwfzF8o+eUUBeGP8a+M/yc6hs9TlhTfSPXb0yVPOb4W1ONKc5Tvel/fRP4CFv9uvjjL3r320Cs8P5SlpeDbv/Oybq+1UVKmx5uMhn+ikJZfkVjfrz481ck72/fp1uqywRLeLpPkydK+2BI7f2/92bg0ObdP4Xhvpvxm4ExlTYjj2kM9afr/+UHmyw2v2XT7RvrLT1s6/uP/nqjlDvt+0Iu3b6xbnDp9o11g0u3b6y/5sKdqn4ol2nWMU7h6U1+7rz2C7lQe+QLubyR792VSxYXyKVfv/uaS79+9zWXfv3uay79+t3XXPr1uy+5cHc2uJCL/C7mIr+LucjvYi5ZXCAX+V3MRX4Xc5HfxVzkdzEX+V3Ihbu7yIVc5HcxF/ldzEV+F3PJ4gK5yO9iLvK7mIv8LuYiv4u5yO9CLtwdfi7kIr+LucjvYi7yu5hLFhfIRX4Xc5HfxVzkdzEX+V3MRX4XcuHusnUhF/ldzEV+F3OR38VcsrhALvK7mIv8LuYiv4u5yO9iLvK7iEvg7nR3IRf5XcxFfhdzkd/FXLK4QC7yu5iL/C7mIr+LucjvYi7yu5ALd0fBC7nI72Iu8ruYi/wu5pLFBXKR38Vc5HcxF/ldzEV+F3NRB23UQTtw9yu8kAu33w1pzvesoeTXFxs7g7tT4K4z5fake840dzNTbt+450zfyAnunGYcuDvTXczmjRzh7mzeyBXuzYa7Q9zFbN7o29Dd2XB3dUhL84UxPxTZ28Wf6rl7qVnqs2v13P3DLPXcnbss9dw9syz13G2wLPXcna0M9eTNqiz13H2cLPWuay137yJTvetay93/x1TvutZy99Ix1buutdx9aSz13N1jTPWuay13JxZTvetay93VxFTvutZydwgx1buutdzdNkz1rmstd+cKU73rWsvdBcJU77rWcndUMNW7rrXc3QlM9a5rLXfSv6neda3lTs031buutdwJ9KZ617WWO83dVO+61nIno5vqXdda7pRxU73rWsud2G2qd11rudOvTfWuay13krSp3nWt5U5lNtW7rrXcCcemete1ljst2FTvutZyJ++a6l3XWu4UW1O961rLnQhrqndda7nTVU31nmtt5E4qNdV7rrWRO/XTVO+51sbBc62N3DmXpnrPtTZyZ0aa6j3X2sidv2ip505JNNW7rrXciYOmete1lju9z1TvutZyJ+GZ6l3XWu5UOVO961rLndBmqndda7mz0Uz1rmstd4aZqd51reXOGjPVu6613HldpnrXtZY788pU77rWus6Niq5zo6Lr3KjoOjcqus6Niq5zo6Lr3KjoOjcqus6Niq5zo6Lr3KjoOjcqus6Niq5zo6Lr3KjoOjcqus6Niq5zo6Lr3KjoOjcqus6Niq5zo6Lr3KjoOjcqus6Niq5zo6Lr3KjoOjcqcudGXdZRK3InUl3IpdsOsgaXbjvIGlyyuEAu3XaQNbhw+7ASyyy+1Pj64jAuEEP9YPFr6eU2bbtOldvh7TpVbjv4ranWh6n+fBf4MVXyHLRdp8r9pc6uU+X+BqiFpXy0MhlTHfLc/isM9a6jTbAw1aXk3UWkgq5Ntz9nzhO8lazl6jh9MeT+HoqDYUrzok2p1WeGWQw3M+T+Ts4HQ25H6oMht9X1UVO4PbSPdchtzl0wJE9k9MGQ+3HCB0M9p2yuKeQZmT7WYRbDzQz1nLKdoZ5TtjPUc8r2mqLnlO3rUM8pmxmSp9n6YKjnlO0M9ZxiM7z/TSq14YFh/mL4Rs8poS4Mf4x9Z/g51dzPVN/I9VtTfSNzHlOcp3rT//omEKY8fl0ch9Dut4FY4f2lLC8H3f6dk3V9q4uUNj3cZDL8FYWy/IrG/Hjx569I3t++T7dUlwmW8HyflvffzpDa+3/vzcChzbt/CsN9N+M3A2MqbUYe0xjqT9d/sEncqdkXs+n2jfWWHrb1/UfXLy7dvrFucOn2jXWDSxYXyKXbN9YNLtTW/lAu06xjnEJ84kLtpy/kQu2RL+TyRr53Ty7c6fUXcunX777m0q/ffc2lX7/7mksWF8ilX7/7mov8LuYiv4u5yO9iLvK7kAt3B4kLucjvYi7yu5iL/C7mksUFcpHfxVzkdzEX+V3MRX4Xc5HfhVy4u7hcyEV+F3OR38Vc5HcxlywukIv8LuYiv4u5yO9iLvK7mIv8LuTC3UnpQi7yu5iL/C7mIr+LuWRxgVzkdzEX+V3MRX4Xc5HfxVzkdyEX7m5mF3KR38Vc5HcxF/ldzCWLC+Qiv4u5yO9iLvK7mIv8LuYivwu59NtR0OAiv4u5yO9iLvK7mEsWF8hFfhdzkd/FXOR3MRf5XcxFfhdy4e6CeCEX+V3MRX4Xc5HfxVyyuEAu6qCNOmgn7n6FF3Lh9rshzfmeNZT8+mJrZ3A72D1nyu1Jd5wpd9e9XWfK7Rv3nOkbOcG904y5O9NdzCaLzW/ZvJEr3J3NGznD3dm80behu7Ph7uqQluYLY34osreLP9Vz91Iz1JN3MbPUc/cPs9Rzd+6y1HP3zLLUZ9fquTtbWeq5m1VZ6rn7OFnqXdda7t5FhvrM3V3IVO+51mbuLj2mes+1Ng+ea23m7ktjqvdcazN3jxdTvedam7n7pVjqubuamOpd11ruDiGmete1lrvbhqneda3l7lxhqndda7m7QJjqXdda7o4KpnrXtZa7O4Gp3nWt5U76N9W7rrXcqfmmete1ljuB3lTvutZyp7mb6l3XWu5kdFO961rLnTJuqndda7kTu031rmstd/q1qd51reVOkjbVu6613KnMpnrXtZY74dhU77rWcqcFm+pd11ru5F1Tvetay51ia6p3XWu5E2FN9a5rLXe6qqneda3lTio11buutdypn6Z617WWO0HTVO+61nKnUZrqXdda7mRHU73rWsudkmiqd11ruRMHTfWuay13ep+p3nWt5U7CM9W7rrXcqXKmete1ljuhzVTvutZyZ6OZ6l3XWu4MM1O961rLnTVmqndda7nzukz1rmstd+aVqd51rXWdG5Vd50Zl17lR2XVuVHadG5Vd50Zl17lR2XVuVHadG5Vd50Zl17lR2XVuVHGdG1Vc50YV17lRxXVuVBk819riOjequM6NKq5zo4rr3KjiOjequM6NKq5zo4rr3KjiOjequM6NKq5zowp3btRlHbUKdyLVhVy67SBrcOm2g+xrLtz5XBdy6baDrMGF24eVWGbxpcbXF4dxgRjqB4tfSi95ANmuU839TJXbDn5rqvVhqj/fBT6nyv09za5T5f5SZ9epcn8D1MJSPlqZjKkOeW7/FYZ619EmWJjqUvLuIlJB16YY0zzBON4ZxumLIff3UBwMU5oXbUqtPjEkT5vzwZD7OzkfDLkdqQ+G3FbXRU0hTyH0sQ65zbkPhtyu3wdD7scJHwz1nLK9pug5ZfM6JE/q9MFQzynbGeo5ZTtDPadsrinkCa4+1qGeU7Yz1HPKdoZ6TtnOUM8pNsP736RSGx4Y5i+Gb/ScEurC8MfYd4Y/pkoeRrzrVN/I9VtTfSNzHlOcp3rT//omEKY8fl0ch9Dut4FY4f2lLC8H3f6dk3V9q4uUNj3cZDL8FYWy/IrG/Hjx569I3t++T7dUlwmW8HSfJk+U9sGQ2vt/783Aoc27fwrDfTfjNwNjKm1GHtMY6k/Xf7J5o7fVd2fT7RvrLT1s6/uP/nqjlDvt+0Iu3b6x/poLd0L5hVy6fWPd4EJt7Q/lMs06xik8vcnPndd+IZcsLpDLG/neXbl0e0LT4NKv333NpV+/+5pLv373JRfuLgEXcunX777mIr+LucjvYi5ZXCAX+V3MRX4Xc5HfxVzkdzEX+V3IhbtTx4Vc5HcxF/ldzEV+F3PJ4gK5yO9iLvK7mIv8LuYiv4u5yO9CLtzdci7kIr+LucjvYi7yu5hLFhfIRX4Xc5HfxVzkdzEX+V3MRX4XcRm5O1ZdyEV+F3OR38Vc5HcxlywukIv8LuYiv4u5yO9iLvK7mIv8LuTC3TXuQi7yu5iL/C7mIr+LuWRxgVzkdzEX+V3MRX4Xc5HfxVzkdyGXfjsKGlzkdzEX+V3MRX4Xc8niArnI72Iu8ruYi/wu5iK/i7nI70Iu3H0QL+SiDtqog/bI3a/wQi7cfjekOd+zhpJfX2ztjNzNTLk96Z4z5XaZe86U2zfuOdM3coI7pxmP3J3prmXD3XHuYjZv5Ap3Z/NGznB3Nm/0bejubDJ1V4e0NF+47f74ePGneu5eapZ67i5mlnru/mGWeu7OXZZ67p5ZhnryNliWeu7OVpZ67mZVlnruPk6Wete1lrt3kaneda3l7v9jqndda7l76VjquTvemOpd11ru7jGmete1lrsTi6neda3l7mpiqndda7k7hJjqXdda7m4bpnrXtZa7c4Wp3nWt5e4CYap3XWu5OyqY6l3XWu7uBKZ617WWO+nfVO+61nKn5pvqXdda7gR6U73rWsud5m6qd11ruZPRTfWuay13yrip3nWt5U7sNtW7rrXc6demete1ljtJ2lTvutZypzKb6j3X2sqdcGyq91xrK3dasKnec62tg+daW7nzcU31nmtt5c6aNdV7rrWVO7fVUs+drmqqd11ruZNKTfWuay136qep3nWt5U7QNNW7rrXcaZSmete1ljvZ0VTvutZypySa6l3XWu7EQVO961rLnd5nqndda7mT8Ez1rmstd6qcqd51reVOaDPVu6613NlopnrXtZY7w8xU77rWcmeNmepd11ruvC5Tvetay515Zap3XWtd50ZV17lR1XVuVHWdG1Vd50ZV17lR1XVuVHWdG1Vd50ZV17lR1XVuVHWdG1Vd50ZV17lR1XVuVHWdG1Vd50ZV17lR1XVuVHWdG1Vd50ZV17lR1XVuVHWdG1Vd50ZV17lR1XVuVHWdG1W5c6Mu66hVuROpLuSSxQVy6baDrMGl2w6yBpduO8gaXLh9WIllFl9qfH1xGBeIoX6w+LX0cpu2PadKnla261S57eC3plofpvrzXeBzqtzf0+w6Ve4vdXadaqaeagtL+WhlMqY65Ln9VxjqXUebYGGqS8m7i0gFXZtiTPME43hnGKcvhtzfQ3EwTGletCm1+syQ+9swHwy5v5PzwZDbkfpgyG11XdQU8hRCF+uQPAvRB0Nu1++DIffjhA+GWQw31xQ9p2xfh3pO2c5QzynbGeo5ZTtDPadsrSmNPMHVwzps5DmyPhjqOWU7Qz2nbGeYxdBkeP+bVGrDA8P8xfCNnlNCXRj+GPvO8HOqb/Q4YU31jVy/NdU3MucxxXmqN/2vbwJhyuPXxXEI7X4biBXeX8ryctDt3zlZ17e6SGnTw00mw19RKMuvaMyPF3/+iuT97ft0S3WZYAlP92nyRGkfDKm9//feDBzavPunMNx3M34zMKbSZuQxjaH+dP0nmzd6W313Nt2+sd7Sw7a+/+j6xSWLC+TS7RvrBpdu31g3uHT7xrrBhdraH8plmnWMU4hPXKj99HVcuJPgL+TyRr53Vy7dntA0uPTrd19zyeICufTrd19z6dfvvubSr999zUV+F3OR34VcuLsxXMhFfhdzkd/FXOR3MZcsLpCL/C7mIr+LucjvYi7yu5iL/C7kwt0R5UIu8ruYi/wu5iK/i7lkcYFc5HcxF/ldzEV+F3OR38Vc5HchF+6uRBdykd/FXOR3MRf5XcwliwvkIr+LucjvYi7yu5iL/C7mIr8LuXB3BruQi/wu5iK/i7nI72IuWVwgF/ldzEV+F3OR38Vc5HcxF/ldyIW7O9+FXOR3MRf5XcxFfhdzyeICucjvYi7yu5iL/C7mIr+LucjvQi7cvQov5CK/i7nI72Iu8ruYSxYXyEV+F3OR38Vc1EEbddBu3P0KL+TC7XdDmvM9ayj59cXGzuDuFLjrTLk96Z4z5XaZe86U2zfuOdOsNOPfpRlzd6a7mM0bOcLd2byRK9ydzRs5w93ZvNG3oTuzmcg7uqWl+cKYH4rs7eJP9dy91Cz13F3MLPXc/cMs9dm1eu6eWZZ67jZYlnruzlaWeu5mVZZ67j5OhnryDkqWete1lru7kKneda3l7tJjqndda7k73pjqXdda7u4xpnrXtZa7E4up3nWt5e5qYqp3XWu5O4SY6l3XWu5uG6Z617WWu3OFqd51reXuAmGqd11ruTsqmOpd11ru7gSmete1ljvp31TvutZyp+ab6l3XWu4EelO961rLneZuqndda7mT0U31rmstd8q4qd51reVO7DbVu6613OnXpnrXtZY7SdpU77rWcqcym+pd11ruhGNTvetay50WbKp3XWu5k3dN9a5rLXeKraneda3lToQ11buutdzpqqZ617WWO6nUVO+61nKnfprqXdda7gRNU73rWsudRmmqd11ruZMdTfWuay13SqKp3nWt5U4cNNW7rrXc6X2mete1ljsJz1TvutZyp8qZ6l3XWu6ENlO961rLnY1mqndda7kzzEz1rmstd9aYqd51reXO6zLVu6613JlXpnrHtfb2kxzX2ttPclxrbz/Jca29/STHtfb2kxzX2ttPclxrbz/Jca29/STHtfb2kxzX2ttPcl1rPedG3dS7rrWec6Nu6l3XWs+5UTf1rmut59yom3rXtdZzbtRNveta6zk36qbeda31nBt1U++61nrOjbqpd11rPedG3dS7rrXcuVFXddS6cem2g+xrLtxZVxdy6baDrMGl2w6yBpduO8gaXDJ1NS2xzOJLja8vDuMCMdQPFr+UXvIAsl2nyu3wdp0qtx381lTrw1R/vgt8TpX7e5pdp8r9pc6eUyVPWGthKR+tTMZUhzy3/wpDvetoEyxMdSl5dxGpoGtTjGmeYBzvDOP0xZD7eygOhinNizalVp8Zcn8b5oMh93dyPhhmMdzMkNvq+qgp3B7axzrkNuc+GHK7fh8MuR8nXDAkT6d0UVPIMzJ9rEM9p2xnqOeU7QyzGG5mqOeU7TVFzynb16GeU7Yz1HPKdoZ6TtnMkDzZl4Ph/W9SqQ0PDPMXwzd6Tgl1Yfhj7DvDz6m+0eOENdU3cv3WVPP7TDWmOE/1pv/1TSBMefy6OA6h3W8DscL7S1leDrr9Oyfr+lYXKW16uMlk+CsKZfkVjfnx4s9fkby/fZ9uqS4TLOH5Pi3vv50htff/3puBQ5t3/xSG+27GbwbGVNqMPKYx1J+u/2TzRm+r786m2zfWW3rY1vcf/fVGKXfa94Vcun1j3eDS7RvrBpdu31g3uORuuUyzjnEKT2/yc+e1X8iF2iNfyOWNfO+uXLo9oWlw6dfvvuTCnbh/IZd+/e5rLv363ddc+vW7r7lkcYFc5HcxF/ldzEV+F3OR38Vc5HchF+6uFxdykd/FXOR3MRf5XcwliwvkIr+LucjvYi7yu5iL/C7mIr+LuATuzjMXcpHfxVzkdzEX+V3MJYsL5CK/i7nI72Iu8ruYi/wu5iK/C7lwd3+6kIv8LuYiv4u5yO9iLllcIBf5XcxFfhdzkd/FXOR3MRf5XciFuwPbhVzkdzEX+V3MRX4Xc8niArnI72Iu8ruYi/wu5iK/i7nI70Iu/XYUNLjI72Iu8ruYi/wu5pLFBXKR38Vc5Hf/BLnI72Iu8ruYi/wu5MLdX/FCLvK7mIv8LuaiDtp/Ah20A3e/wgu5cPvdm4+YdYSSX19s7QxuB7vnTLk96Z4z5XaZe86U2zfuOFPuDnaXphkH7s50F7N5I0e4O5s3coW7s8li81s2b/Rt6O5suLs6pKX5wpgfiuzt4k/13L3ULPXcXcws9dz9wwz15J27LPXcPbMs9dxtsCz13J2tLPXZtXruPk6Wete1lrt3kaneda3l7v9jqefu0mOqd11ruTvemOpd11ru7jGmete1lrsTi6neda3l7mpiqndda7k7hJjqXdda7m4bpnrXtZa7c4Wp3nWt5e4CYap3XWu5OyqY6l3XWu7uBKZ617WWO+nfVO+61nKn5pvqXdda7gR6U73rWsud5m6q91xrI3cyuqnec62N3CnjpnrPtTYOnmtt5M7VNtV7rrWRO6PaVO+51kbuvGdLPXcqs6neda3lTjg21buutdxpwaZ617WWO3nXVO+61nKn2JrqXdda7kRYU73rWsudrmqqd11ruZNKTfWuay136qep3nWt5U7QNNW7rrXcaZSmete1ljvZ0VTvutZypySa6l3XWu7EQVO961rLnd5nqndda7mT8Ez1rmstd6qcqd51reVOaDPVu6613NlopnrXtZY7w8xU77rWcmeNmepd11ruvC5Tvetay515Zap3XWtd50ZF17lR0XVuVHSdGxVd50ZF17lR0XVuVHSdGxVd50ZF17lR0XVuVHSdGxVd50ZF17lR0XVuVHSdGxVd50ZF17lR0XVuVHSdGxVd50ZF17lR0XVuVHSdGxVd50ZF17lR0XVuVHSdGxW5c6Mu66gVuROpLuTSbQdZg0u3HWQNLt12kDW4dNtB9jUX8kyxEsssvtT4+uIwLhBD/WDxS+klDyDbdarcDm/XqXLbwW9NtT5M9ee7wOdUcz9T5f5SZ9epcn8D1MJSPlqZjKkOeW7/FYZ619EmWJjqUvLuIlJB136cPp0nePvz1HJ1nL4Ycn8PxcEwpXnRptTqM0Pub8N8MOT+Ts4Dw0SevOeDIbfV9VBTEnkKoY91yG3OfTDMYriZIffjhA+Gek7ZXlP0nLJ9Heo5ZTtDPadsZkieWuqDoZ5TNtcU8gRXH+tQzynbGWYx3MxQzynbGeo5xWZ4/5tUasMDw/zF8I2eU0JdGP4Y+87wc6pv9DhhTfWNXL8xVfKY429NNaY4T/Wm//VNIEx5/Lo4DqHdbwOxwvtLWV4Ouv07J+v6VhcpbXq4yWT4Kwpl+RWN+fHiz1+RvL99n26pLhMs4ek+TZ4o7YMhtff/3puBQ5t3/xSG+27GbwbGVNqMPKYx1J+u/2STxea3bLp9Y72lh219/9H1i0u3b6wbXLp9Y93g0u0b6waXbt9Yf82FO1X9UC7TrGOcQnziQu2nL+RC7ZEv5PJGvndXLllcIJd+/e5rLv363ddc+vW7r7n063dfc+nX777kwt3Z4EIu8ruYi/wu5iK/i7lkcYFc5HcxF/ldzEV+F3OR38Vc5HchF+7uIhdykd/FXOR3MRf5XcwliwvkIr+LucjvYi7yu5iL/C7mIr8LuXB3+LmQi/wu5iK/i7nI72IuWVwgF/ldzEV+F3OR38Vc5HcxF/ldyIW7y9aFXOR3MRf5XcxFfhdzyeICucjvYi7yu5iL/C7mIr+LucjvQi7cne4u5CK/i7nI72Iu8ruYSxYXyEV+F3OR38Vc5HcxF/ldzEV+F3Lh7ih4IRf5XcxFfhdzkd/FXLK4QC7yu5iL/C7mIr+LucjvYi7qoI06aGfufoUXcuH2uyHN+Z41lPz64tc7I3N3Ctx1ptyedM+Z5m5myu0b95zpGznBndOMM3dnuovZvJEj3J3NG7nCvdlwd4i7mM0bfRu6Oxvurg5pab4w5ocie7v4Uz13LzVLfXatnrt/mKWeu3OXpZ67Z5alnrsNlqWeu7OVoZ68WZWlnruPk6Xeda3l7l1kqndda7n7/5jqXdda7l46pnrXtZa7L42lnrt7jKneda3l7sRiqndda7m7mpjqXdda7g4hpnrXtZa724ap3nWt5e5cYap3XWu5u0CY6l3XWu6OCqZ617WWuzuBqd51reVO+jfVu6613Kn5pnrXtZY7gd5U77rWcqe5m+pd11ruZHRTvetay50ybqp3XWu5E7tN9a5rLXf6taneda3lTpI21buutdypzKZ617WWO+HYVO+61nKnBZvqXdda7uRdU73rWsudYmuqd11ruRNhTfWuay13uqqp3nWt5U4qNdW7rrXcqZ+mete1ljtB01TvutZyp1Ga6l3XWu5kR1O961rLnZJoqndda7kTB031rmstd3qfqd51reVOwjPVu6613KlypnrPtbZwJ7SZ6j3X2sKdjWaq91xry+C51hbuXDJTvedaW7jTwEz1nmtt4U7UstRzZ16Z6l3XWte5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFe7cqMs6ahXuRKoLuXTbQdbg0m0HWYNLFhfIpdsOsgYXbh92+0ZpFl9qfH1xGBeIoX6w+LX0cpu2XafK7fB2nSq3HfzWVOvDVH++C/yYKnkO2q5T5f5SZ9epcn8D1MJSPlqZjKkOeW7/FYZ619EmWJjqUvLuIlJB16YY0zzBON4ZxumLIff3UBwMU5oXbUqtPjPMYriZIfd3cj4YcjtSHwy5ra6PmsLtoX2sQ25z7oIheSKjD4bcjxM+GOo5ZXNNIc/I9LEOsxhuZqjnlO0M9ZyynaGeU7bXFD2nbF+Hek7ZzJA8zdYHQz2nbGeo5xSb4f1vUqkNDwzzF8M3ek4JdWH4Y+w7w8+p5n6m+kau35rqG5nzmOI81Zv+1zeBMOXx6+I4hHa/DcQK7y9leTno9u+crOtbXaS06eEmk+GvKJTlVzTmx4s/f0Xy/vZ9uqW6TLCE5/u0vP92htTe/3tvBg5t3v1TGO67Gb8ZGFNpM/KYxlB/uv4HG+7U7IvZdPvGeksP2/r+o7/eKOVO+76QS7dvrBtcsrhALt2+sW5wobb2h3KZZh3jFJ7e5OfOa7+QC7VHvpDLG/nePblwp9dfyKVfv/uaS79+9zWXfv3uay5ZXCCXfv3uay7yu5iL/C7mIr+LucjvIi4jdweJC7nI72Iu8ruYi/wu5pLFBXKR38Vc5HcxF/ldzEV+F3OR34VcuLu4XMhFfhdzkd/FXOR3MZcsLpCL/C7mIr+LucjvYi7yu5iL/C7kwt1J6UIu8ruYi/wu5iK/i7lkcYFc5HcxF/ldzEV+F3OR38Vc5HchF+5uZhdykd/FXOR3MRf5XcwliwvkIr+LucjvYi7yu5iL/C7mIr8LufTbUdDgIr+LucjvYi7yu5hLFhfIRX4Xc5HfxVzkdzEX+V3MRX4XcuHugnghF/ldzEV+F3OR38VcsrhALuqgjTpoj9z9Ci/kwu13Q5rzPWso+fXF1s7gdrB7zpTbk+44U+6ue7vOlNs37jnTN3KCO6cZj9yd6S5mk8Xmt2zeyBXuzuaNnOHubN7o29Dd2XB3dUhL84Xb31jj48Wf6rl7qRnqybuYWeq5+4dZ6rk7d1nquXtmWeqza/Xcna0s9dzNqiz13H2cLPWuay137yJLPXd3IVO961rL3aXHVO+61nJ3vDHVu6613N1jTPWuay13JxZTvetay93VxFTvutZydwgx1buutdzdNkz1rmstd+cKU73rWsvdBcJU77nWVu6OCqZ6z7W2cncnMNV7rrV18FxrK3cev6nec62t3Nn2pnrPtbZy58Rb6rnT3E31rmstdzK6qd51reVOGTfVu6613IndpnrXtZY7/dpU77rWcidJm+pd11ruVGZTvetay51wbKp3XWu504JN9a5rLXfyrqneda3lTrE11buutdyJsKZ617WWO13VVO+61nInlZrqXdda7tRPU73rWsudoGmqd11rudMoTfWuay13sqOp3nWt5U5JNNW7rrXciYOmete1lju9z1TvutZyJ+GZ6l3XWu5UOVO961rLndBmqndda7mz0Uz1rmstd4aZqd51reXOGjPVu6613HldpnrXtZY788pU77rWus6Nqq5zo6rr3KjqOjequs6Nqq5zo6rr3KjqOjequs6Nqq5zo6rr3KjqOjequs6Nqq5zo6rr3KjqOjequs6Nqq5zo6rr3KjqOjequs6Nqq5zo6rr3KjqOjequs6Nqq5zo6rr3KjqOjeqcudGXdZRq3InUl3IpdsOsgaXbjvIvuTSuPO5LuTSbQdZgwu3DyuxzOJLja8vDuMCMdQPFj+X3kYeQLbrVHM/U+W2g9+aan2Y6s93gc+pcn9Ps+tUub/U2XWq3N8AtbCUj1YmY6pDntt/haHedbQJFqa6lLy7iFTQtSnGNE8wjneGcfpiyP09FAfDlOZFm1KrTwzJ0+Z8MOT+Ts4HQ25H6oMht9V1UVPIUwh9rENuc+6DIbfr98GQ+3HCB0M9p2yvKXpO2bwOyZM6fTDUc8p2hnpO2c5Qzymbawp5gquPdajnlO0M9ZyynaGeU7Yz1HOKzfD+N6mPv7XdGeYvhm/0nBLqwvDH2HeGP6ZKHka861TfyPVbU30jcx5TnKd60//6JhCmPH5dHIfQ7reBWOH9pSwvB93+nZN1fauLlDY93GQy/BWFsvyKxvx48eevSN7fvk+3VJcJlvB0nyZPlPbBkNr7f+/NwKHNu38Kw3034zcDYyptRh7TGOpP13+yeaO31Xdn0+0b6y09bOv7j/56o5Q77ftCLt2+sf6aC3dC+YVcun1j3eBCbe0P5TLNOsYpPL3Jz53XfiGXLC6Qyxv53l25dHtC0+DSr999zaVfv/uaS79+9yUX7i4BF3Lp1+++5iK/i7nI72IuWVwgF/ldzEV+F3OR38Vc5HcxF/ldyIW7U8eFXOR3MRf5XcxFfhdzyeICucjvYi7yu5iL/C7mIr+LucjvQi7c3XIu5CK/i7nI72Iu8ruYSxYXyEV+F3OR38Vc5HcxF/ldzEV+F3Lh7lh1IRf5XcxFfhdzkd/FXLK4QC7yu5iL/C7mIr+LucjvYi7yu5ALd9e4C7nI72Iu8ruYi/wu5pLFBXKR38Vc5HcxF/ldzEV+F3OR30Vcpn47Chpc5HcxF/ldzEV+F3PJ4gK5yO9iLvK7mIv8LuYiv4u5yO9CLtx9EC/kog7aqIP2xN2v8EIu3H43pDnfs4aSX19s7YzczUy5PemeM+V2mXvOlNs37jnTN3KCO6cZT9yd6a5lw91x7mI2b+QKd2fzRs5wdzZv9G3o7mwydVeHtDRfGPNDkb1d/Kmeu5eapZ67i5mlnrt/mKWeu3OXpZ67Z5ahnrwNlqWeu7OVpZ67WZWlnruPk6Xeda3l7l1kqndda7n7/5jqXdda7l46lnrujjemete1lrt7jKneda3l7sRiqndda7m7mpjqXdda7g4hpnrXtZa724ap3nWt5e5cYap3XWu5u0CY6l3XWu6OCqZ617WWuzuBqd51reVO+jfVu6613Kn5pnrXtZY7gd5U77rWcqe5m+pd11ruZHRTvetay50ybqp3XWu5E7tN9a5rLXf6taneda3lTpI21buutdypzKZ617WWO+HYVO+61nKnBZvqXdda7uRdU73rWsudYmuqd11ruRNhTfWuay13uqqp3nWt5U4qNdW7rrXcqZ+mete1ljtB01TvutZyp1Ga6h3X2jxwJzua6h3X2pt6x7X2pt5xrb2pd1xrb+od19qbese19qbeca29qXdca2/qXdda7lQ5U73rWsud0Gaqd11rubPRTPWuay13hpmp3nWt5c4aM9W7rrXceV2mete1ljvzylTvutZ6zo26qXddaz3nRt3Uu661nnOjbupd11rPuVE39a5rrefcqJt617XWc27UTb3rWus5N+qm3nWt9ZwbdVPvutZ6zo26qXddaz3nRt3Uu661nnOjbupd11rPuVE39a5rrefcqJt617XWc27UTb3rWsudG3VVR60bl247yBpcsrhALt12kDW4dNtB1uDSbQdZgwu3DyuxzOJLja8vDuMCMdQPFr+WXm7TtudUydPKdp0qtx381lTrw1R/vgt8TpX7e5pdp8r9pc6uU83UU21hKR+tTMZUb4/181SHetfRJliY6lLy7iJSQdemGNM8wTjeGcbpiyH391AcDFOaF21KrT4z5P42zAdD7u/kfDDkdqQ+GHJbXRc1hTyF0MU6JM9C9MGQ2/X7YMj9OOGDYRbDzTVFzynb16GeU7Yz1HPKdoZ6TtnOUM8pm2sKeYKri3VIniPrg6GeU7Yz1HPKdoZZDE2G979JpTY8MMxfDN/oOSXUheGPse8MP6f6Ro8T1lTfyPVbU30jcx5TnKd60//6JhCmPH5dHIfQ7reBWOH9pSwvB93+nZN1fauLlDY93GQy/BWFsvyKxvx48eevSN7fvk+3VJcJlvB0nyZPlPbBkNr7f+/NwFs1+7p4CsN9N+M3A2MqbUYe0xjqT9d/snmjt9V3Z9PtG+stPWzr+4/+eqOUO+37Qi7dvrFucOn2jXWDS7dvrBtcqK39oVymWcc4hac3+bnz2i/jEriT4C/k8ka+d1cu3Z7QNLj063dfc8niArn063dfc+nX777m0q/ffc1Ffhdzkd+FXLi7MVzIRX4Xc5HfxVzkdzGXLC6Qi/wu5iK/i7nI72Iu8ruYi/wu5MLdEeVCLvK7mIv8LuYiv4u5ZHGBXOR3MRf5XcxFfhdzkd/FXOR3IRfurkQXcpHfxVzkdzEX+V3MJYsL5CK/i7nI72Iu8ruYi/wu5iK/C7lwdwa7kIv8LuYiv4u5yO9iLllcIBf5XcxFfhdzkd/FXOR3MRf5XciFuzvfhVzkdzEX+V3MRX4Xc8niArnI72Iu8ruYi/wu5iK/i7nI70Iu3L0KL+Qiv4u5yO9iLvK7mEsWF8hFfhdzkd/FXNRBG3XQDtz9Ci/kwu13Q5rzPevtK5HXFxs7g7tT4K4z5fake86U22XuOVNu37jnTLPSjH+TZhy4O9NdzOaNHOHubN7IFe7O5o2c4e5s3ujb0L3ZkHd0S0vzhTE/FNnbxZ/quXupWeq5u5hZ6rn7h1nqs2v13D2zLPXcbbAs9dydrSz13M2qLPXcfZwM9eQdlCz1rmstd3chU73rWsvdpcdU77rWcne8MdW7rrXc3WNM9Z5rbeTuxGKq91xrI3dXE1O951obB8+1NnL38TDVe661kbsnhqnec62N3P0lLPXcXSBM9a5rLXdHBVO961rL3Z3AVO+61nIn/ZvqXdda7tR8U73rWsudQG+qd11rudPcTfWuay13Mrqp3nWt5U4ZN9W7rrXcid2mete1ljv92lTvutZyJ0mb6l3XWu5UZlO961rLnXBsqndda7nTgk31rmstd/Kuqd51reVOsTXVu6613ImwpnrXtZY7XdVU77rWcieVmupd11ru1E9Tvetay52gaap3XWu50yhN9a5rLXeyo6neda3lTkk01buutdyJg6Z617WWO73PVO+61nIn4ZnqXdda7lQ5U73rWsud0Gaqd11rubPRTPWuay13hpmp3nWt5c4aM9W7rrXceV2mete1ljvzylTvuta6zo2KrnOjouvcqOg6Nyq6zo2KrnOjouvcqOg6Nyq6zo2KrnOjouvcqOg6Nyq6zo2KrnOjouvcqOg6Nyq6zo2KrnOjouvcqOg6Nyq5zo1KrnOjkuvcqOQ6NyoNnmttcp0blVznRiXXuVGJOzfqso5aiTuR6jou3FlXF3LptoOswaXbDrIGl247yBpcMnU1LbHM4kuNry8O4wIx1A8Wv5Re8gCyXafK7fB2nSq3HfzWVOvDVH++C3xOlft7ml2nyv2lzp5TJU9Ya2EpH61MxlSHPLf/CkO962gTLEx1KXl3Eamga1OMaZ5gHO8M4/TFkPt7KA6GKc2LNqVWnxlyfxvmgyH3d3I+GGYx3MyQ2+r6qCncHtrHOuQ25z4Ycrt+Hwy5HydcMCRPp3RRU8gzMn2sQz2nbGeo55TtDLMYbmao55TtNUXPKdvXoZ5TtjPUc8p2hnpO2cyQPNmXg+H9b1KpDQ8M8xfDN3pOCXVh+GPsO8PPqb7R44Q11Tdy/dZU8/tMNaY4T/Wm//VNIEx5/Lo4DqHdbwOxwvtLWV4Ouv07J+v6VhcpbXq4yWT4Kwpl+RWN+fHiz1+RvL99n26pLhMs4fk+Le+/nSG19//em4FDm3f/FIb7bsZvBsZU2ow8pjHUn67/ZPNGb6vvzqbbN9ZbetjW9x/99UYpd9r3hVy6fWPd4NLtG+sGl27fWDe45G65TLOOcQpPb/Jz57VfyIXaI1/I5Y18765cuj2haXDp1+++5MKduH8hl3797msu/frd11z69buvuWRxgVzkdzEX+V3MRX4Xc5HfxVzkdyEX7q4XF3KR38Vc5HcxF/ldzCWLC+Qiv4u5yO9iLvK7mIv8LuYivwu5cHeeuZCL/C7mIr+LucjvYi5ZXCAX+V3MRX4Xc5HfxVzkdzEX+V3Ihbv704Vc5HcxF/ldzEV+F3PJ4gK5yO9iLvK7mIv8LuYiv4u5yO8iLpm7A9uFXOR3MRf5XcxFfhdzyeICucjvYi7yu5iL/C7mIr+LucjvQi79dhQ0uMjvYi7yu5iL/C7mksUFcpHfxVzkdzEX+V3MRX4Xc5HfhVy4+yteyEV+F3OR38Vc1EEbddDO3P0KL+TC7XdDmvM9ayj59cXWzuB2sHvOlNuT7jlTbpe550y5feOOM+XuYHdpmnHm7kx3MZs3coS7s3kjV7g7myw2v2XzRt+G7s6Gu6tDWpovjPmhyN4u/lTP3UvNUs/dxcxSz90/zFBP3rnLUs/dM8tSz90Gy1LP3dnKUp9dq+fu42Spd11ruXsXmepd11ru/j+Weu4uPaZ617WWu+ONqd51reXuHmOqd11ruTuxmOpd11ruriamete1lrtDiKneda3l7rZhqndda7k7V5jqXdda7i4QpnrXtZa7o4Kp3nWt5e5OYKp3XWu5k/5N9a5rLXdqvqneda3lTqA31buutdxp7qZ617WWOxndVO+61nKnjJvqXdda7sRuU73rWsudfm2qd11ruZOkTfWuay13KrOp3nWt5U44NtW7rrXcacGmete1ljt511TvutZyp9ia6j3X2sKdCGuq91xrC3e6qqnec60tg+daW7jzRE31nmtt4c7mNNV7rrWFO+fSUs+dRmmqd11ruZMdTfWuay13SqKp3nWt5U4cNNW7rrXc6X2mete1ljsJz1TvutZyp8qZ6l3XWu6ENlO961rLnY1mqndda7kzzEz1rmstd9aYqd51reXO6zLVu6613JlXpnrXtdZ1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UcV1blRxnRtVXOdGFde5UYU7N+qyjlqFO5HqQi7ddpA1uHTbQdbg0m0HWYNLtx1kX3MhzxQrscziS42vLw7jAjHUDxa/lF7yALJdp8rt8HadKrcd/NZU68NUf74LfE419zNV7i91dp0q9zdALSzlo5XJmOqQ5/ZfYah3HW2ChakuJe8uIhV0bYoxzROM451hnL4Ycn8PxcEwpXnRptTqM0Pub8N8MOT+Ts4FQ/LkPR8Mua2ui5pCnkLoYx1ym3MfDLMYbmbI/Tjhg6GeU7bXFD2nbF+Hek7ZzlDPKZsZkqeW+mCo55TNNYU8wdXHOtRzynaGWQw3M9RzynaGek6xGd7/JpXa8MAwfzF8o+eUUBeGP8a+M/yc6hs9TlhTfSPX/3qqI3nM8bemGlOcp3rT//omEKY8fl0ch9Dut4FY4f2lLC8H3f6dk3V9q4uUNj3cZDL8FYWy/IrG/Hjx569I3t++T7dUlwmW8Ot9eiRPlPbBkNr7f+/NwKHNu38Kw3034zcDY7p9lzbfLNIY6k/Xf7LJYvNbNt2+sd7Sw7a+/+j6xaXbN9YNLt2+sW5w6faNdYNLt2+sv+bCnap+KJdp1jFOIT5xofbTF3Kh9sgXcnkj37srlywukEu/fvc1l3797msu/frd11z69buvufTrd19y4e5scCEX+V3MRX4Xc5HfxVyyuEAu8ruYi/wu5iK/i7nI72Iu8ruQC3d3kQu5yO9iLvK7mIv8LuaSxQVykd/FXOR3MRf5XcxFfhdzkd+FXLg7/FzIRX4Xc5HfxVzkdzGXLC6Qi/wu5iK/i7nI72Iu8ruYi/wu5MLdZetCLvK7mIv8LuYiv4u5ZHGBXOR3MRf5XcxFfhdzkd/FXOR3IRfuTncXcpHfxVzkdzEX+V3MJYsL5CK/i7nI72Iu8ruYi/wu5iK/C7lwdxS8kIv8LuYiv4u5yO9iLllcIBf5XcxFfhdzkd/FXOR3MRduvxvSnNdYQ8mvLzZmyt2BcNeZcnvSPWfK7TL3nCm3b9xzplnptL9Lp+XueHcxmzdyhLuzeSNXuDubN3KGu7N5o29D92ZD3ikuLWH6Y34osreLP9Vz92mw1HN3SLDUc/cls9Rn1+q5e3FZ6rm7YFnquftPWeq5W0pZ6rm7RL1WX8kbP1nqPdfaSt6NyFLvudbWwXOtrdy9dEz1nmtt5e5LY6r3XGsrd48XSz13JxZTvetay93VxFTvutZydwgx1buutdzdNkz1rmstd+cKU73rWsvdBcJU77rWcndUMNW7rrXc3QlM9a5rLXfSv6neda3lTs031buutdwJ9KZ617WWO83dVO+61nIno5vqXdda7pRxU73rWsud2G2qd11rudOvTfWuay13krSp3nWt5U5lNtW7rrXcCcemete1ljst2FTvutZyJ++a6l3XWu4UW1O961rLnQhrqndda7nTVU31rmstd1Kpqd51reVO/TTVu6613AmapnrXtZY7jdJU77rWcic7mupd11rulERTvetay504aKp3XWu50/tM9a5rLXcSnqneda3lTpUz1buutdwJbaZ617WWOxvNVO+61nJnmJnqXdda7qwxU73rWsud12Wqd11ruTOvTPWua63r3KjqOjequs6Nqq5zo6rr3KjqOjequs6Nqq5zo6rr3KjqOjequc6Naq5zo5rr3KjmOjeqDZ5rbXOdG9Vc50Y117lRzXVuVHOdG9Vc50Y117lRzXVuVHOdG9Vc50Y117lRzXVuVHOdG9V+kxtVxnmIWlp9VP/5qWnNp36Tk2R9Kqz6VFz1qbTqU3nVp8qqT42rPlVXfWrV2oir1kZatTbSqrWRVq2NtGptpFVrI61aG2nV2kir1kZatTbSqrWRV62NvGpt5FVrI69aG3nV2sir1kZetTbyqrWRV62NvGptlFVro6xaG2XV2iir1kZZtTbKqrVRVq2NsmptlFVro6xaG+OqtTGuWhvjqrUxrlob46q1Ma5aG+OqtTGuWhvjqrUxrlobddXaqKvWRl21NuqqtVFXrY26am3g92xDjfOTT6gpP3+qrvpUW/Wpac2n8HuU5qfCqk/FVZ9Kqz6VV32qrPrUqrXRVq2N9t21AR6T89JXbiwPj+u/6cY8LBfn+yN1SLOeabueUoZFzzgZemIt84+Otd5b6IVxRN825FTmbxvK0IyrwzCN82xv/273bydSrOj62+1uvrxNd5IfM36+OIRZSghjfrz4X27/8a//8Ze//vUv/+u///Xv//bnf/7l73/7x8dHh4//g78qnepd6XAXGuHvcJy/chlrfbz09ivEX2Xu9tPz5p8+3fv05l9/etn+0+dvjGpsv/708dCfXrf+9PtGqGP89ae3Q3/6tPmnT3MfzNvf73756firs+/99PmG0h7ub18/PWz96bdvEeaf/kQmxh1/+i+76fYf4eNC/GrU7Tlv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",
  "file_map": {
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
    },
    "24": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "25": {
      "path": "std/field/bn254.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "26": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"
    },
    "29": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"
    },
    "34": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "35": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"
    },
    "58": {
      "path": "std/option.nr",
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "59": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "65": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "68": {
      "path": "std/uint128.nr",
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"
    },
    "70": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/NewAddressNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: u32 = 3;\n// CARD_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: u32 = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\n#[derive(Deserialize)]\nstruct NewAddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let header = NoteHeader::empty();\n        NewAddressNote { address, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//serialize is a macro now?\n// impl Serialize<3> for NewAddressNote {\n//     fn serialize(self) -> [Field; 3] {\n//         [self.address.to_field(), self.shared_secret, self.npk_m_hash.to_field()]\n//     }\n// }\n\n"
    },
    "71": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/StringNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n//going to make the max length 10 characters just to keep it simple\n//pretty sure the only thing that this changes is the amount of compute needed\nglobal STRING_NOTE_LENGTH: Field = 3;\nglobal STRING_NOTE_BYTES_LENGTH: Field = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n"
    },
    "80": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PrivateGroups {\n\n    use dep::aztec::{prelude::{Map, AztecAddress, PrivateImmutable, PrivateSet}};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use value_note::{balance_utils, utils::{increment, decrement}, value_note::ValueNote};\n    use std::hash::pedersen_hash;\n    use aztec::context::inputs::private_context_inputs::PrivateContextInputs;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    //Storage for the contract, we have an admin that creates the group, they add members to the group, and they can add notes to the group\n    //The reason there is a credit and a debt is for note tracking.\n\n    #[storage]\n   struct Storage<Context> {\n        admin: PrivateImmutable<NewAddressNote, Context>,\n        group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        group_balances_credit: Map<Field, PrivateSet<ValueNote,Context>, Context>,\n        group_balances_debt: Map<Field, PrivateSet<ValueNote, Context>, Context>,\n   }\n\n    //The Constructor\n    // - Admin creates the group\n    // - Admin adds members to the group\n    // - Each group member is added to a private set of members so that they can see all of the members\n    // - This is very expensive, highlights some of the inefficiencies of the current system\n    // - Since the 0.57 update, this cannot compile, it uses too much memory. I have to get rid of the group member logic which doesnt allow for access gating\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 3]) {\n        //setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let mut admin_address_note = NewAddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n        // this is for adding members to the private set, so they can see the other members, going to be expensive\n        for i in 0..3 {\n            let member = group_members[i as u32];\n            if (member != ZERO_ADDRESS) {\n                let member_keys = get_public_keys(member);\n                for i in 0..3 {\n                    let member_add = group_members[i as u32];\n                    let mut memberNote = NewAddressNote::new(member_add, member_keys.npk_m.hash());\n                    storage.group_members.at(member).insert(&mut memberNote).emit(\n                        encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, member_keys.ivpk_m, member)\n                    );\n                }\n            }\n        }\n    }\n\n    //need to constrain this so that only group members can read this \n    #[private]\n    fn get_admin() -> pub AztecAddress {\n        let admin_note = storage.admin.get_note();\n        admin_note.address\n    }\n\n    //For each group member, we have a private set of members so that they can see all of the members\n    #[private]\n    fn get_group_members(member: AztecAddress) -> [AztecAddress; 3] {\n        let mut options = NoteGetterOptions::new();\n        let member_note = storage.group_members.at(member).get_notes(options);\n        let mut member_array : [AztecAddress; 3] = [ZERO_ADDRESS; 3];\n        //if you call this and u are not part of the group, it will return the zero address\n        for i in 0..3 {\n            let note = member_note.get_unchecked(i);\n            let address: AztecAddress = note.address;\n            member_array[i] = address;\n        }\n        member_array\n    }\n\n    //Setting the balance for the creditor and debtor\n    #[private]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        //TODO:: add assertions here to make sure that the creditor and debtor are part of the group\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, amount, debtor, creditor);\n    }\n\n    //can have a timestamp here for when the payment is made. \n    #[private]\n    fn make_payment(debtor: AztecAddress, creditor: AztecAddress, amount: Field) {\n        //do not do any assertions for now\n        //reason it does a increment with a negative amount is because decrement would not work.\n        //it always failed an assertion. \n        let new_amount = amount * -1;\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, new_amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, new_amount, debtor, creditor);\n    }\n\n    #[private]\n    fn setup_group_payments(creditor: AztecAddress, debtors: [AztecAddress; 2], amount: Field) {\n        //can be called by anyone\n\n        //increase the credit for the creditor with each member\n        let shared_amount : u32 = amount as u32 / (debtors.len() + 1);\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n            let loc_credit = storage.group_balances_credit.at(key);\n            increment(loc_credit, shared_amount.to_field(), creditor, debtor);\n        }\n        //increase the debt for each member with the creditor\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n            let loc_debt = storage.group_balances_debt.at(key);\n            increment(loc_debt, shared_amount.to_field(), debtor, creditor);\n        }\n    }\n\n    #[private]\n    fn read_balance_credit(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //for this function i need to also get the notes that the debtor has sent if they have sent any\n        //if they have sent new notes, i need to nullify the old ones that i have sent to the debtor\n        //make a new one with the new outstanding balance\n        //tricky part is listening for new notes that the debtor has sent, updating the balance\n\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                let note = balance_notes_credit.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_balance_debt(debtor: AztecAddress, creditor: AztecAddress) -> u64 {\n        let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_total_balance(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //going to have to hand type this, could not call the other private functions\n\n        //keys to check in storage\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n\n        //options for the notes \n        let options_1 = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options_1);\n\n        let options_2 = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options_2);\n\n        //sum the notes\n        let mut total_balance_credit = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                // let note = balance_notes_credit.get_unchecked(i);\n                let note = balance_notes_credit.get(i);\n                total_balance_credit += note.value;\n            }\n        }\n\n        //sum the notes\n        let mut total_balance_debt = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get(i);\n                total_balance_debt += note.value;\n            }\n        }\n\n        //convert the note to integer\n\n        let total_debt = U128::from_integer(total_balance_debt);\n        let total_credit = U128::from_integer(total_balance_credit);\n        let tot_debt: i64 = total_debt.to_integer();\n        let tot_credit: i64 = total_credit.to_integer();\n        let total_balance = tot_credit - tot_debt;\n        total_balance as u64\n        // let total_balance = total_credit - total_debt;\n        // total_balance\n    }\n\n    // #[private]\n    // fn read_total_balance_2(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n\n    //     let total_balance_credit = read_balance_credit(&mut context, creditor, debtor);\n    //     let total_balance_debt = read_balance_debt(&mut context, debtor, creditor);\n    //     let total_balance = total_balance_credit - total_balance_debt;\n\n    //     total_balance    \n    // }\n\n    unconstrained pub(crate) fn admin() -> pub AztecAddress {\n        let admin_note: NewAddressNote = storage.admin.view_note();\n        admin_note.address\n    }\n}\n\n//TODO:: add the token transfer, have tests for that too. \n//add block time to storage for notes being paid\n"
    },
    "82": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/address-note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "88": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "89": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "91": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"
    },
    "94": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "103": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "105": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "110": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"
    },
    "112": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext}};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"
    },
    "125": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "126": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "128": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "129": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"
    },
    "130": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "131": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "135": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"
    },
    "139": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"
    },
    "143": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr",
      "source": "// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"
    },
    "147": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"
    },
    "165": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"
    },
    "166": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "169": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "171": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"
    },
    "179": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "186": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "232": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"
    },
    "310": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "311": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "317": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    public_keys::PublicKeys, contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys : PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11]\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize(\n                [\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15]\n            ]\n            )\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"
    },
    "318": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n    partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n    salted_initialization_hash::SaltedInitializationHash\n},\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(contract_class_id, salted_initialization_hash);\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "320": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "321": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "325": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "327": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(_vk: VerificationKey<N>) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "328": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "358": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/utils.nr",
      "source": "use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(\n        encode_and_encrypt_note(\n            balance.context,\n            outgoing_viewer_ovpk_m,\n            recipient_keys.ivpk_m,\n            recipient\n        )\n    );\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n"
    },
    "359": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "decompose_hint",
    "get_notes_internal",
    "get_collapse_hints",
    "pack_returns_oracle_wrapper",
    "directive_invert",
    "directive_integer_quotient"
  ]
}