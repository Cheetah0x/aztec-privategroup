{
  "noir_version": "0.35.0+df29d315d6b71131ffe0180c97130395edb2e4ba-aarch64",
  "hash": 0,
  "abi": {
    "error_types": {},
    "parameters": [
      {
        "name": "inputs",
        "type": {
          "fields": [
            {
              "name": "call_context",
              "type": {
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::function_selector::FunctionSelector"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::call_context::CallContext"
              }
            },
            {
              "name": "historical_header",
              "type": {
                "fields": [
                  {
                    "name": "last_archive",
                    "type": {
                      "fields": [
                        {
                          "name": "root",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "next_available_leaf_index",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                    }
                  },
                  {
                    "name": "content_commitment",
                    "type": {
                      "fields": [
                        {
                          "name": "num_txs",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "txs_effects_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "in_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "out_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::content_commitment::ContentCommitment"
                    }
                  },
                  {
                    "name": "state",
                    "type": {
                      "fields": [
                        {
                          "name": "l1_to_l2_message_tree",
                          "type": {
                            "fields": [
                              {
                                "name": "root",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "next_available_leaf_index",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                          }
                        },
                        {
                          "name": "partial",
                          "type": {
                            "fields": [
                              {
                                "name": "note_hash_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "nullifier_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "public_data_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::partial_state_reference::PartialStateReference"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::state_reference::StateReference"
                    }
                  },
                  {
                    "name": "global_variables",
                    "type": {
                      "fields": [
                        {
                          "name": "chain_id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "version",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "block_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "slot_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "timestamp",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        },
                        {
                          "name": "coinbase",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::eth_address::EthAddress"
                          }
                        },
                        {
                          "name": "fee_recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "gas_fees",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::global_variables::GlobalVariables"
                    }
                  },
                  {
                    "name": "total_fees",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::header::Header"
              }
            },
            {
              "name": "tx_context",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "version",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "gas_settings",
                    "type": {
                      "fields": [
                        {
                          "name": "gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "teardown_gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "max_fees_per_gas",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        },
                        {
                          "name": "inclusion_fee",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::gas_settings::GasSettings"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::transaction::tx_context::TxContext"
              }
            },
            {
              "name": "start_side_effect_counter",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
        },
        "visibility": "private"
      },
      {
        "name": "creditor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      },
      {
        "name": "debtor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      },
      {
        "name": "amount",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "fields": [
          {
            "name": "call_context",
            "type": {
              "fields": [
                {
                  "name": "msg_sender",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "storage_contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "function_selector",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::function_selector::FunctionSelector"
                  }
                },
                {
                  "name": "is_delegate_call",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "is_static_call",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::call_context::CallContext"
            }
          },
          {
            "name": "args_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "returns_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "min_revertible_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "is_fee_payer",
            "type": {
              "kind": "boolean"
            }
          },
          {
            "name": "max_block_number",
            "type": {
              "fields": [
                {
                  "name": "_opt",
                  "type": {
                    "fields": [
                      {
                        "name": "_is_some",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "_value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::option::Option"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::max_block_number::MaxBlockNumber"
            }
          },
          {
            "name": "note_hash_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "nullifier_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "key_validation_requests_and_generators",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "request",
                    "type": {
                      "fields": [
                        {
                          "name": "pk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        },
                        {
                          "name": "sk_app",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                    }
                  },
                  {
                    "name": "sk_app_generator",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
              }
            }
          },
          {
            "name": "note_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::note_hash::NoteHash"
              }
            }
          },
          {
            "name": "nullifiers",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::nullifier::Nullifier"
              }
            }
          },
          {
            "name": "private_call_requests",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "returns_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "start_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::private_call_request::PrivateCallRequest"
              }
            }
          },
          {
            "name": "public_call_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::public_call_request::PublicCallRequest"
              }
            }
          },
          {
            "name": "public_teardown_call_request",
            "type": {
              "fields": [
                {
                  "name": "contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "args_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::public_call_request::PublicCallRequest"
            }
          },
          {
            "name": "l2_to_l1_msgs",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
              }
            }
          },
          {
            "name": "start_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "end_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "note_encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "note_hash_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::NoteLogHash"
              }
            }
          },
          {
            "name": "encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::EncryptedLogHash"
              }
            }
          },
          {
            "name": "unencrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::LogHash"
              }
            }
          },
          {
            "name": "historical_header",
            "type": {
              "fields": [
                {
                  "name": "last_archive",
                  "type": {
                    "fields": [
                      {
                        "name": "root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "next_available_leaf_index",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                  }
                },
                {
                  "name": "content_commitment",
                  "type": {
                    "fields": [
                      {
                        "name": "num_txs",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "txs_effects_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "in_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "out_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::content_commitment::ContentCommitment"
                  }
                },
                {
                  "name": "state",
                  "type": {
                    "fields": [
                      {
                        "name": "l1_to_l2_message_tree",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "partial",
                        "type": {
                          "fields": [
                            {
                              "name": "note_hash_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "nullifier_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "public_data_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::partial_state_reference::PartialStateReference"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::state_reference::StateReference"
                  }
                },
                {
                  "name": "global_variables",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "block_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "slot_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "timestamp",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 64
                        }
                      },
                      {
                        "name": "coinbase",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "fee_recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "gas_fees",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::global_variables::GlobalVariables"
                  }
                },
                {
                  "name": "total_fees",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::header::Header"
            }
          },
          {
            "name": "tx_context",
            "type": {
              "fields": [
                {
                  "name": "chain_id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "version",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "gas_settings",
                  "type": {
                    "fields": [
                      {
                        "name": "gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "teardown_gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "max_fees_per_gas",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      },
                      {
                        "name": "inclusion_fee",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::gas_settings::GasSettings"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::transaction::tx_context::TxContext"
            }
          }
        ],
        "kind": "struct",
        "path": "protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
      },
      "visibility": "databus"
    }
  },
  "bytecode": "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",
  "debug_symbols": "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2FHPabHjTc/psaOe02NHPafFc6ubntNjx2HHFjvqOT121HN6fM/Rc3rsqOf02FHPabHjXc/psaOe02NHPafHjnpOjx2HHVvsqOf02FHP6bGjntNjRz2nx456TosdH3pOi+dWDz2nx456To8d9ZweOw47tvieo+f02FHP6bGjntNjRz2nx456Tocd7yc9p8eOek6PHfWcHjvqOT12HHZssaOe02NHPafHjnpOjx31nA7Pre4nPafFjpue02NHPafHjnpOi+85m57TY8dhxxY76jk9dtRzeuyo5/TYUc/psaOe02LHXc/psaOe02NHPafHjnpOjx2HHVvsqOf02FHPafHcatdzeuyo5/TYUc9pseNZz2nxPees5/TYUc/psaOe02PHYccWO+o5PXbUc3rsqOf02FHP6bGjntNix6Hn9NhRz+mxo57TY0c9p8eOw44dnlsNPafHjnpOjx31nB476jk9vufoOS12vOg5PXbUc3rsqOf02FHP6bHjsGOLHfWcHjvqOT121HN67Kjn9NhRz2mx41XP6bGjntNjRz2nxXOrq57TY8dhxxY76jk9dtRzenzP0XN67Kjn9NhRz2mx403P6bGjntNjRz2nx456To8dhx1b7Kjn9NhRz+mxo57TY0c9p8eOek6LHe96TovnVnc9p8eOek6PHfWcHjsOO7b4nqPn9NhRz+mxo57TY0c9p8eOek6LHR96To8d9ZweO+o5PXbUc3rsOOzYYkc9p8eOek6PHfWcHjvqOS2eWz30nA47Pk56To8d9ZweO+o5Hb7nPE56To8dhx1b7Kjn9NhRz+mxo57TY0c9p8eOek6LHTc9p8eOek6PHfWcHjvqOT12HHZssaOe02NHPafFc6tNz+mxo57TY0c9p8WOu57T4nvOruf02FHP6bGjntNjx2HHFjvqOT121HN67Kjn9NhRz+mxo57TYsezntNjRz2nx456To8d9ZweOw47dnhuddZzeuyo5/TYUc/psaOe0+N7jp7TYseh5/TYUc/psaOe02NHPafHjsOOLXbUc3rsqOf02FHP6bGjntNjRz2nxY4XPafHjnpOjx31nBbPrS56To8dhx1b7Kjn9NhRz+nxPUfP6bGjntNjRz2nxY5XPafHjnpOjx31nB476jk9dhx2bLGjntNjRz2nx456To8d9ZweO+o5LXa86Tktnlvd9JweO+o5PXbUc3rsOOzY4nuOntNjRz2nx456To8d9ZweO+o5LXa86zk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5PXbUc3rsqOe0eG5113Na7PjQc3rsqOf02FHPafE956Hn9Nhx2LHFjnpOjx31nB476jk9dtRzeuyo5zTY8Xw66Tk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5DZ5bve2o5/TYUc/psaOe02LHTc9p8T1n03N67Kjn9NhRz+mx47Bjix31nB476jk9dtRzeuyo5/TYUc9pseOu5/TYUc/psaOe02NHPafHjsOOHZ5b7XpOjx31nB476jk9dtRzenzP0XNa7HjWc3rsqOf02FHP6bGjntNjx2HHFjvqOT121HN67Kjn9NhRz+mxo57TYseh5/TYUc/psaOe0+K51dBzeuw47NhiRz2nx456To/vOXpOjx31nB476jktdrzoOT121HN67Kjn9NhRz+mx47Bjix31nB476jk9dtRzeuyo5/TYUc9pseNVz2nx3Oqq5/TYUc/psaOe02PHYccW33P0nB476jk9dtRzeuyo5/TYUc9pseNNz+mxo57TY0c9p8eOek6PHYcdW+yo5/TYUc/psaOe02NHPafFc6ubntNix7ue02NHPafHjnpOi+85dz2nx47Dji121HN67Kjn9NhRz+mxo57TY0c9p8WODz2nx456To8d9ZweO+o5PXYcdmyxo57TY0c9p8Vzq4ee02NHPafHjnpOhx23k57T4XvOdtJzeuyo5/TYUc/pseOwY4sd9ZweO+o5PXbUc3rsqOf02FHPabHjpuf02FHP6bGjntNjRz2nx47Djh2eW216To8d9ZweO+o5PXbUc3p8z9FzWuy46zk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5PXbUc3rsqOf02FHPabHjWc/psaOe02NHPafFc6uzntNjx2HHFjvqOT121HN6fM/Rc3rsqOf02FHPabHj0HN67Kjn9NhRz+mxo57TY8dhxxY76jk9dtRzeuyo5/TYUc/psaOe02LHi57T4rnVRc/psaOe02NHPafH5+OwY4sd9ZweO+o5PXbUc3rsqOf02FHPaeEdVz2nx456To8d9ZwWn49XPafHjsOOLXbUc3rsqOf02FHP6bGjntPDO/ScFjve9JweO+o5PXbUc1p8z7npOT12HHZssaOe02NH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FxdCV1tc21xs8SFXrra4Arna4qLiaovrhKstPiy+2OJq3mqLC3SrLa65rba45rba4prbYotfNLfVFtfcVltcc1ttcc1ttcWHxRdbXHNbbXHNbbXFNbfVFtfcVltcc1ts8avmttrimttqi2tuqy2uua22+LD4Yotrbqstrrmttrjmttrimttqi2tuiy1+09xWW1xzW21xzW21xTW31RYfFl9scc1ttcU1t9UW19xWW1xzW21xzW2xxe+a22qLa26rLa65rba45rba4sPiiy2uua22uOa22uKa22qLa26rLa65Lbb4Q3NbbXHNbbXFNbfVFtfcVlt8WHyxxTW31RbX3FZbXHNbbXHNbbXFNbe1Fr+cNLfVFtfcui3+9n/ef937/nFxzW21xTW31RYfFl9scc1ttcU1t9UW19xWW1xzW21xzW2xxTfNbbXFNbfVFtfcVltcc1tt8WHxxRbX3FZbXHNbbXHNbbXFNbfVFtfcFlt819xWW1xzW21xzW21xTW31RYfFl9scc1ttcU1t9UW19xWW1xzW21xzW2xxc+a22qLa26rLa65rba45rba4sPiiy2uua22uOa22uKa22qLa26rLa65Lbb40NxWW1xzW21xzW21xTW31RYfFl9scc1ttcU1t9UW19xWW1xzW21xzW2xxS+a22qLa26rLa65rba45rba4sPiiy2uua22uOa22uKa22qLa26rLa65Lbb4VXNbbXHNbbXFNbfVFtfcVlt8WHyxxTW3Zotf9/356173+/Xj4prbaotrbqstrrmttrjmttjiN81ttcU1t9UW19xWW1xzW23xYfHFFtfcVltcc1ttcc1ttcU1t9UW19wWW/yuua22uOa22uKa22qLa26rLT4svtjimttqi2tuqy2uua22uOa22uKa22KLPzS31RbX3FZbXHNbbXHNbbXFh8UXW1xzW21xzW21xTW31RbX3FZbXHNba/HrSXNbbXHNbbXFNbfVFtfcVlt8WHyxxTW31RbX3Lotfjk957he9tvHxTW31RbX3FZbXHNbbPFNc1ttcc1ttcU1t9UW19xWW3xYfLHFNbfVFtfcVltcc1ttcc1ttcU1t8UW3zW31RbX3FZbXHNbbXHNbbXFh8UXW1xzW21xzW21xTW31RbX3FZbXHNbbPGz5rba4prbaotrbqstrrmttviw+GKLa26rLa65rba45rba4prbaotrbostPjS31RbX3FZbXHNbbXHNbbXFh8UXW1xzW21xzW21xTW31RbX3FZbXHNbbPGL5rba4prbaotrbqstrrmttviw+GKLa26rLa65rba45rba4prbaotrbostftXcVltcc1ttcc2t2+L3y/25+P3++Li45rba4sPiiy2uuXVb/HF6/grXx/n8+Q/fz9vzd7ifz48vfng8md2v54+XpOW5pDmXpBG6pDmXpD26pDmXpGm6pCmXdNNKXdKcS9JgXdKcS9J2XdKcS9KMXdKcSxouySVNuSSN2yXNuSSN2yXNuSSN2yXNuSSN2yXNuSSN2yVNuaS7xu2S5lySxu2S5lySxu2S5lySxu2S5lzScEkuacoladwuac4ladwuac4ladwuac4ladwuac4ladwuacolPTRulzTnkjRulzTnkjRulzTnkjRulzTnkoZLcklTLknjdklzLknjdklzLknjdklzLknjdklzLknjdkkzLul20rhd0pxL0rhd0pxL0rhd0pxL0rhd0pxLGi7JJU25JI3bJc25JI3bJc25JI3bJc25JI3bJc25JI3bJU25pE3jdklzLknjdklzLknjdklzLknjdklzLmm4JJc05ZI0bpc055I0bpc055I0bpc055I0bpc055I0bpc05ZJ2jdslzbkkjdslzbkkjdslzbkkjdslzbmk4ZJc0pRL0rhd0pxL0rhd0pxL0rhd0pxL0rhd0pxL0rhd0pRLOmvcLmnOJWncLmnOJWncLmnOJWncLmnOJQ2X5JKmXJLG7ZLmXJLG7ZLmXJLG7ZLmXJLG7ZLmXJLG7ZKmXNLQuF3SnEvSuF3SnEvSuF3SnEvSuF3SnEsaLsklTbkkjdslzbkkjdslzbkkjdslzbkkjdslzbkkjdslTbmki8btkuZcksbtkuZcksbtkuZcksbtkuZc0nBJLmnKJWncLmnOJWncLmnOJWncLmnOJWncLmnOJWncLmnKJV01bpc055I0bpc055I0bpc055I0bpc055KGS3JJUy5J43ZJcy5J43ZJcy5J43ZJcy5J43ZJcy5J43ZJUy7ppnG7pDmXpHG7pDmXpHG7pDmXpHG7pDmXNFzSypf0A/H9PG4fz0O4dh6fnIca7Tw+OQ+J2Xl8ch66sfP45DzEYOfxz8/jrvA6j0/OQ7Z1Hp+chxbrPD45D4HVeXxyHsN5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0wNRUh3IpweipDqQTw9ESXUgnx3IVUl1IJ8eiJLqQD49ECXVgXx6IEqqA/n0QIYDcSCfHYiS6kA+PRAl1YF8eiBKqgP59ECUVAfy6YEoqe0O5LLfnoNczqf7h81v4uh6m+ud620uYa63uSq53ubD5sttrh2ut7kcuN7mCt96m4t2622uwy23+V2HW29zHW69zXW49TbX4dbbfNh8uc11uPU21+HW21yHW29zHW69zXW45TZ/6HDrba7Drbe5Drfe5jrcepsPmy+3uQ633uY63Hqb63Drba7Drbe5Drfa5ueTDrfe5jrcepvrcOttrsOtt/mw+XKb63Drba7Drbe5Drfe5jrcepvrcMttvulw622uw623uQ633uY63HqbD5svt7kOt97mOtx6m+tw622uw623uQ633Oa7Drfe5jrcepvrcOttrsOtt/mw+XKb63Drba7Drbe5Drfe5jrcepvrcMttftbh1ttch1tvcx1uvc11uH6bv/2f91/3vn/cfNh8uc11uPU21+HW21yHW29zHW69zXW45TYfOtx6m+tw622uw623uQ633ubD5sttrsOtt7kOt97mOtx6m+tw622uwy23+UWHW29zHW69zXW49TbX4dbbfNh8uc11uPU21+HW21yHW29zHW69zXW45Ta/6nDrba7Drbe5Drfe5jrcepsPmy+3uQ633uY63Hqb63Drba7Drbe5Drfc5jcdbr3Ndbj1Ntfh1ttch1tv82Hz5TbX4dbbXIdbb3Mdbr3Ndbj1Ntfhltv8rsOtt7kOt97mOtx6m+tw620+bL7c5jrcepvrcOttrsOtt7kOt97mOtxymz90uPU21+HW21yHW29zHW69zYfNl9tch1tvcx1uvc11uHabX/f9+ete9/v14+Y63Hqb63CrbT5OOtx6m+tw622uw623uQ633ubD5sttrsOtt7kOt97mOtx6m+tw622uwy23+abDrbe5Drfe5jrcepvrcOttPmy+3OY63Hqb63Drba7Drbe5Drfe5jrccpvvOtx6m+tw622uw623uQ633ubD5sttrsOtt7kOt97mOtx6m+tw622uwy23+VmHW29zHW69zXW49TbX4dbbfNh8uc11uPU21+HW21yHW29zHa7f5pfTc5DrZb993FyHW27zocOtt7kOt97mOtx6m+tw620+bL7c5jrcepvrcOttrsOtt7kO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Pn22HLZss6Xu02dL3afPlrpPny11nz5b6j5dthwn3afPlrpPny11ny7PvMZJ9+mz5bBlmy11nz5b6j59vvvoPn221H36bKn7tNly0336bKn79NlS9+mzpe7TZ8thyzZb6j59ttR9+myp+/TZUvfps6Xu02bLXfdp88xr1336bKn79NlS9+mz5bBlm+8+uk+fLXWfPlvqPn221H36bKn7tNnyrPv02VL36bOl7tNnS92nz5bDlm221H36bKn79NlS9+mzpe7T5pnXWfdps+XQffpsqfv02VL3afPdZ+g+fbYctmyzpe7TZ0vdp8+Wuk+fLXWfPlvqPm22vOg+fbbUffpsqfv02VL36bPlsGWbLXWfPlvqPm2eeV10nz5b6j59ttR92mx51X3afPe56j59ttR9+myp+/TZctiyzZa6T58tdZ8+W+o+fbbUffpsqfu02fKm+/TZUvfps6Xu02dL3afPlsOWXZ553XSfPlvqPn221H36bKn79Pnuo/u02fKu+/TZUvfps6Xu02dL3afPlsOWbbbUffpsqfv02VL36bOl7tNnS92nzZYP3afPlrpPny11nzbPvB66T58thy3bbKn79NlS9+nz3Uf36bOl7tNnS92ny5aXk+7TZ0vdp8+Wuk+fLXWfPlsOW7bZUvfps6Xu02dL3afPlrpPny11nzZbbrpPl2del0336bOl7tNnS92nz5bDlm2+++g+fbbUffpsqfv02VL36bOl7tNmy1336bOl7tNnS92nz5a6T58thy3bbKn79NlS9+mzpe7TZ0vdp80zr133abPlWffps6Xu02dL3afNd5+z7tNny2HLNlvqPn221H36bKn79NlS9+mzpe7TZsuh+/TZUvfps6Xu02dL3afPlsOWbbbUffpsqfu0eeY1dJ8+W+o+fbbUfdpsedF92nz3ueg+fbbUffpsqfv02XLYss2Wuk+fLXWfPlvqPn221H36bKn7tNnyqvv02VL36bOl7tNnS92nz5bDll2eeV11nz5b6j59ttR9+myp+/T57qP7tNnypvv02VL36bOl7tNnS92nz5bDlm221H36bKn79NlS9+mzpe7TZ0vdp82Wd92nz5a6T58tdZ82z7zuuk+fLYct22yp+/TZUvfp891H9+mzpe7TZ0vdp82WD92nz5a6T58tdZ8+W+o+fbYctmyzpe7TZ0vdp8+Wuk+fLXWfPlvqPl22vJ50ny7PvN5+R1u22VL36bOl7tNny2HLNt99dJ8+W+o+fbbUffpsqfv02VL3abPlpvv02VL36bOl7tNnS92nz5bDlm221H36bKn79NlS9+mzpe7T5pnXpvu02XLXffpsqfv02VL3afPdZ9d9+mw5bNlmS92nz5a6T58tdZ8+W+o+fbbUfdpsedZ9+myp+/TZUvfps6Xu02fLYcs2W+o+fbbUfdo88zrrPn221H36bKn7tNly6D5tvvsM3afPlrpPny11nz5bDlu22VL36bOl7tNnS92nz5a6T58tdZ82W150nz5b6j59ttR9+myp+/TZctiyyzOvi+7TZ0vdp8+Wuk+fLXWfPt99dJ82W151nz5b6j59ttR9+myp+/TZctiyzZa6T58tdZ8+W+o+fbbUffpsqfu02fKm+/TZUvfps6Xu0+aZ10336bPlsGWbLXWfPlvqPn2+++g+fbbUffpsqfu02fKu+/TZUvfps6Xu02dL3afPlsOWbbbUffpsqfv02VL36bOl7tNnS92nzZYP3afNM6+H7tNnS92nz5a6T58thy3bfPfRffpsqfv02VL36bOl7tNnS92ny5a3k+7TZ0vdp8+Wuk+fLXWfPlsOW7bZUvfps6Xu02dL3afPlrpPl2det5Pu02bLTffps6Xu02dL3afNd59N9+mz5bBlmy11nz5b6j59ttR9+myp+/TZUvdps+Wu+/TZUvfps6Xu02dL3afPlsOWbbbUffpsqfu0eea16z59ttR9+myp+7TZ8qz7tPnuc9Z9+myp+/TZUvfps+WwZZstdZ8+W+o+fbbUffpsqfv02VL3abPl0H36bKn79NlS9+mzpe7TZ8thyy7PvIbu02dL3afPlrpPny11nz7ffXSfNltedJ8+W+o+fbbUffpsqfv02XLYss2Wuk+fLXWfPlvqPn221H36bKn7tNnyqvv02VL36bOl7tPmmddV9+mz5bBlmy11nz5b6j59vvvoPn221H36bKn7tNnypvv02VL36bOl7tNnS92nz5bDlm221H36bKn79NlS9+mzpe7TZ0vdp82Wd92nzTOvu+7TZ0vdp8+Wuk+fLYct23z30X36bKn79NlS9+mzpe7TZ0vdp82WD92nz5a6T58tdZ8+W+o+fbYctmyzpe7TZ0vdp8+Wuk+fLXWfNs+8HrpPly3vJ92nz5a6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PtuRW5/dyM/WZzty67MdufXZjtz6bEe+IO9Gbn22I7c+25Fbn93x9mx9tiO3PruRX6zPduTWZ/fL58X6bEdufbYjX5B3I7c+25Fbn+3Irc925NZnO3Lrsxv51fpsR259tiO3PtuRW5/tyBfk3citz+54e7U+25Fbn+3Irc925NZn98vnsj7bkVuf7citz3bk1mc78gV5N3Lrsx259dmO3PpsR259tiO3PruR36zPduTWZzty67MdufXZHW9vC/Ju5NZnO3Lrsx259dn+8ml9tiO3PruR363PduTWZzty67MdufXZjnxB3o3c+mxHbn22I7c+25Fbn+3Irc9u5A/rsx259dkdbx/WZzty67Md+YK8G7n12f7yaX22I7c+25Fbn+3Irc9u5E/rsx259dmO3PpsR259tiNfkHcjtz7bkVuf7citz3bk1mc7cuuzO96+rM925NZnO3Lrsx259dn98vlakHcjtz7bkVuf7citz3bk1mc7cuuzGfnrZH22I7c+25Fbn+3Irc925AvybuTWZzty67MdufXZHG9fJ+uzHbn12Y38bH22I7c+u18+z9ZnO3Lrsx35grwbufXZjtz6bEdufbYjtz7bkVuf3cgv1mc7cuuzHbn12Y7c+mxHviDvRm59dsfbi/XZjtz6bEdufbYjtz67Xz6v1mc7cuuzHbn12Y7c+mxHviDvRm59tiO3PtuRW5/tyK3PduTWZzfyZX22I7c+25Fbn+3Irc/ueLsW5N3Irc925NZnO3Lrs/3l0/psR259diO/WZ/tyK3PduTWZzty67Md+YK8G7n12Y7c+mxHbn22I7c+25Fbn93I79ZnO3Lrszve3q3PduTWZzvyBXk3cuuz/eXT+mxHbn22I7c+25Fbn93IH9ZnO3Lrsx259dmO3PpsR74g70ZufbYjtz7bkVuf7citz3bk1md3vH1an+3Irc925NZnO3Lrs/vl87kg70ZufbYjtz7bkVuf7citz3bk1mc38pf12Y7c+mxHbn22I7c+25EvyLuRW5/tyK3PduTWZ3e8fVmf7citz17k59PJ+mxHbn32vnz+Qm59tiO3PtuRL8i7kVuf7citz3bk1mc7cuuzHbn12Y38bH22I7c+25Fbn+3Irc925AvybuTWZ3e8PVuf7citz3bk1mc7cuuz++XzYn22I7c+25Fbn+3Irc925AvybuTWZzty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3ZbaF+07alfpttSu0m2pXaXbUrtKt6V2lW5H7XeVbkvtKt2W2lW6LbWrdFtqX7TvqF2l21K7SreldpVuS+0q3ZbaVbodtT9Uui21q3RbalfpttSu0m2pfdG+o3aVbkvtKt2W2lW6LbWrdFtqV+l21P5U6bbUrtJtqV2l21K7Srel9kX7jtpVui21q3RbalfpttSu0m2pXaXbUftLpdtSu0q3pXaVbkvtKt2W2hftO2pX6bbUrtJtqV2l21K7SreldpVuQ+3nk0q3pXaVbkvtKt2W2lW6LbUv2nfUrtJtqV2lS9T+4//en709L59oV+m21K7SbaldpdtR+1ml21K7SreldpVuS+0q3ZbaF+07alfpttSu0m2pXaXbUrtKt6V2lW5H7ReVbkvtKt2W2lW6LbWrdFtqX7TvqF2l21K7SreldpVuS+0q3ZbaVbodtV9Vui21q3RbalfpttSu0m2pfdG+o3aVbkvtKt2W2lW6LbWrdFtqV+l21L5Uui21q3RbalfpttSu0m2pfdG+o3aVbkvtKt2W2lW6LbWrdFtqV+l21H5T6bbUrtJtqV2l21K7Srel9kX7jtpVui21q3RbalfpttSu0m2pXaXbUftdpdtSu0q3pXaVbkvtKt2W2hftO2pX6bbUrtJtqV2l21K7SreldpVuR+0PlS5Q+/1yebO4X573T7SrdFtqV+m21K7Sbal90b6jdpVuS+0q3ZbaVbottat0W2pX6XbU/lTpttSu0m2pXaXbUrtKt6X2RfuO2lW6LbWrdFtqV+m21K7SbaldpdtR+0ul21K7SreldpVuS+0q3ZbaF+07alfpttSu0m2pXaXbUrtKt6V2lW5D7ZeTSreldpVuS+0q3ZbaVbottS/ad9Su0m2pXaXbUrtKt6V2lW5L7SrdjtrPKt2W2lW6RO2301vJ/XZ5fKJdpdtSu0q3pfZF+47aVbottat0W2pX6bbUrtJtqV2l21H7RaXbUrtKt6V2lW5L7SrdltoX7TtqV+m21K7SbaldpdtSu0q3pXaVbkftV5VuS+0q3ZbaVbottat0W2pftO+oXaXbUrtKt6V2lW5L7SrdltpVuh21L5VuS+0q3ZbaVbottat0W2pftO+oXaXbUrtKt6V2lW5L7SrdltpVuh2131S6LbWrdFtqV+m21K7Sbal90b6jdpVuS+0q3ZbaVbottat0W2pX6XbUflfpttSu0m2pXaXbUrtKt6X2RfuO2lW6LbWrdFtqV+kStT9vz7e/5/P1iXaVbkvtKt2O2h8qXaL21+n9U7i/rtdff/h5Pb9/Ds/r9fXFh9db3/N+/eSc1D/ndOA5qYrO6cBzUiud04HntJyTczrunNRV53TgOam2zunAc1KDndOB56QyO6cDz0m9dk7HndNTFXdOB56TKu6cDjwnVdw5HXhOqrhzOvCclnNyTsedkyrunA48J1XcOR14Tqq4czrwnFRx53TgOanizum4c3qp4s7pwHNSxZ3TgeekijunA89JFXdOB57Tck7O6bhzUsWd04HnpIo7pwPPSRV3TgeekyrunA48J1XcOR12TteTKu6cDjwnVdw5HXhOqrhzOvCcVHHndOA5LefknI47J1XcOR14Tqq4czrwnFRx53TgOanizunAc1LFndNx53RWxZ3TgeekijunA89JFXdOB56TKu6cDjyn5Zyc03HnpIo7pwPPSRV3TgeekyrunA48J1XcOR14Tqq4czrunC6quHM68JxUced04Dmp4s7pwHNSxZ3Tgee0nJNzOu6cVHHndOA5qeLO6cBzUsWd04HnpIo7pwPPSRV3Tsed01UVd04HnpMq7pwOPCdV3DkdeE6quHM68JyWc3JOx52TKu6cDjwnVdw5HXhOqrhzOvCcVHHndOA5qeLO6bhzWqq4czrwnFRx53TgOanizunAc1LFndOB57Sck3M67pxUced04Dmp4s7pwHNSxZ3TgeekijunA89JFXdOx53TTRV3TgeekyrunA48J1XcOR14Tqq4czrwnJZzck7HnZMq7pwOPCdV3DkdeE6quHM68JxUced04Dmp4s7puHO6q+LO6cBzUsWd04HnpIo7pwPPSRV3Tgee03JOzum4c1LFndOB56SKO6cDz0kVd04HnpMq7pwOPCdV3Dkdd04PVdw5HXhOqrhzOvCcVHHndOA5qeLO6cBzWs7JOR13Tqq4czrwnFRx53TgOanizunAc1LFndOB56SKb39Of2J+XtfjrzfylLq3v5G13v5+/IJy+/WHL6/r29/ldfvzR77cP/nw7fR8fPyUT7efP/zH9Snjrq/v+oR019d3fbq76+u7vuX6XF/b9an6rq/v+rwEcH191+edgevruz6vGFxf3/V5I+H62q7v5V2H6+u7Pu86XF/f9XnX4fr6rs+7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",
  "file_map": {
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
    },
    "24": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "25": {
      "path": "std/field/bn254.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "26": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"
    },
    "29": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"
    },
    "34": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "35": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"
    },
    "58": {
      "path": "std/option.nr",
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "59": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "65": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "68": {
      "path": "std/uint128.nr",
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"
    },
    "70": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/NewAddressNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n        address::AztecAddress,\n        traits::{Serialize, Deserialize},\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator\n    },\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random,\n    keys::getters::get_nsk_app,\n    context::PrivateContext\n};\n\n// Custom Address Note implementation, as the default one lacks serialization and the Eq trait.\n\n#[note]\n#[derive(Serialize)]    // Adds serialization support for the struct.\n#[derive(Deserialize)]  // Adds deserialization support for the struct.\nstruct NewAddressNote {\n    address: AztecAddress, // The AztecAddress for the note.\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,  \n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    /**\n     * Computes the nullifier for the note using the provided private context.\n     * This is necessary to ensure that the note can be nullified (spent) privately.\n     *\n     * @param context - A mutable reference to the private context, used to retrieve the note's nullifying secret key.\n     * @param note_hash_for_nullify - The precomputed note hash used as part of the nullifier.\n     * @returns A `Field` value representing the nullifier for this note.\n     */\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        // Retrieves the nullifying secret key from the context.\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        \n        // Uses Poseidon hashing to compute the nullifier, incorporating the note hash and the secret.\n        poseidon2_hash_with_separator(\n            [\n                note_hash_for_nullify,\n                secret\n            ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    /**\n     * Computes the nullifier for the note without needing the context.\n     * This is an unconstrained function that allows generating the nullifier for use in tests or specific use cases\n     * where the context is not required.\n     *\n     * @returns Field value representing the nullifier for this note, computed without context.\n     */\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // Computes the note hash for nullification.\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        // Retrieves the nullifying secret key directly without context.\n        let secret = get_nsk_app(self.npk_m_hash);\n        \n        // Uses Poseidon hashing to compute the nullifier, incorporating the note hash and the secret.\n        poseidon2_hash_with_separator(\n            [\n                note_hash_for_nullify,\n                secret\n            ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    /**\n     * Creates a new instance of `NewAddressNote` with the provided Aztec address and nullifying public key hash.\n     * \n     * @param address - The AztecAddress associated with the note.\n     * @param npk_m_hash - The nullifying public key hash, used to ensure private spending.\n     * @returns A new `NewAddressNote` instance.\n     */\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // Initializes an empty note header (can be extended with more fields if necessary).\n        let header = NoteHeader::empty();\n        NewAddressNote { address, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    /**\n     * Custom equality implementation for `NewAddressNote`.\n     * Compares the address and npk_m_hash fields to determine if two notes are equal.\n     *\n     * @param other - The other note to compare with.\n     * @returns `true` if both notes are equal, `false` otherwise.\n     */\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n"
    },
    "71": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/StringNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n//going to make the max length 10 characters just to keep it simple\n//pretty sure the only thing that this changes is the amount of compute needed\nglobal STRING_NOTE_LENGTH: Field = 3;\nglobal STRING_NOTE_BYTES_LENGTH: Field = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n"
    },
    "80": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/main.nr",
      "source": "//TODO:: add the token transfer, have tests for that too. \n//add block time to storage for notes being paid\n\n//This is just a demo contract of how you could make a Splitwise like contract on Aztec\n// During the exploration phase, the way this is done is by sending lots of notes to the members of the group.\n//This is very expensive to do so, and is not scalable, especially as the size of the group grows.\n\n//The next exploration is using a shared account contract which others can register in their PXE.\n\n//This is expensive in terms of the gate count, which increases the cost and the proving time of the functions withint the contract.\n//The main constraints on the Aztec network.\n\n//This will be used for the purpose of showing the cost of certain functions within the contract. \n//How different design patterns can be used to optimize the cost of the contract. \n\n//Hopefully this can be used as an example for pepople building contracts on Aztec. \n\n\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PrivateGroups {\n\n    use dep::aztec::{prelude::{Map, AztecAddress, PrivateImmutable, PrivateSet}};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use value_note::{balance_utils, utils::{increment, decrement}, value_note::ValueNote};\n    use std::hash::poseidon2;\n    use aztec::context::inputs::private_context_inputs::PrivateContextInputs;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    //Contract Storage\n    // - `admin`: The admin who creates and manages the group\n    // - `group_members`: A map of group members, each with a private set of other group members so they can see all members\n    // - `group_balances_credit`: A map of balances owed to the creditor, stored with a unique key for each creditor and debtor pair\n    // - `group_balances_debt`: A map of balances owed by the debtor, stored with a unique key for each debtor and creditor pair\n    #[storage]\n   struct Storage<Context> {\n        admin: PrivateImmutable<NewAddressNote, Context>,\n        group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        group_balances_credit: Map<Field, PrivateSet<ValueNote,Context>, Context>,\n        group_balances_debt: Map<Field, PrivateSet<ValueNote, Context>, Context>,\n   }\n\n    // Contract Constructor:\n    // - The admin creates the group and initializes group members.\n    // - Each group member is added to the private set, allowing them to see other members.\n    // - This operation can be expensive due to encryption and note handling for each member.\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 3]) {\n        //setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let mut admin_address_note = NewAddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n        // this is for adding members to the private set, so they can see the other members, going to be expensive\n        for i in 0..3 {\n            let member = group_members[i as u32];\n            if (member != ZERO_ADDRESS) {\n                let member_keys = get_public_keys(member);\n                for i in 0..3 {\n                    let member_add = group_members[i as u32];\n                    let mut memberNote = NewAddressNote::new(member_add, member_keys.npk_m.hash());\n                    storage.group_members.at(member).insert(&mut memberNote).emit(\n                        encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, member_keys.ivpk_m, member)\n                    );\n                }\n            }\n        }\n    }\n\n    // Retrieves the admin's address.\n    // for testing purposes, only the admin can read this.\n    #[private]\n    fn get_admin() -> pub AztecAddress {\n        let admin_note = storage.admin.get_note();\n        admin_note.address\n    }\n\n    //For each group member, we have a private set of members so that they can see all of the members\n    #[private]\n    fn get_group_members(member: AztecAddress) -> [AztecAddress; 3] {\n        let mut options = NoteGetterOptions::new();\n        let member_note = storage.group_members.at(member).get_notes(options);\n        let mut member_array : [AztecAddress; 3] = [ZERO_ADDRESS; 3];\n        //if you call this and u are not part of the group, it will return the zero address\n        for i in 0..3 {\n            let note = member_note.get_unchecked(i);\n            let address: AztecAddress = note.address;\n            member_array[i] = address;\n        }\n        member_array\n    }\n\n    //Setting the balance for the creditor and debtor\n    #[private]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        //TODO:: add assertions here to make sure that the creditor and debtor are part of the group\n\n        //notes for the creditor\n        let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n        let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, amount, creditor, debtor);\n\n        // notes for the debtor\n        let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n        let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, amount, debtor, creditor);\n    }\n\n    //can have a timestamp here for when the payment is made. \n    #[private]\n    fn make_payment(debtor: AztecAddress, creditor: AztecAddress, amount: Field) {\n        //do not do any assertions for now\n        //reason it does a increment with a negative amount is because decrement would not work.\n        //it always failed an assertion. \n        let new_amount = amount * -1;\n\n        //notes for the creditor\n        let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n        let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, new_amount, creditor, debtor);\n\n        // notes for the debtor\n        let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n        let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, new_amount, debtor, creditor);\n    }\n\n    #[private]\n    fn setup_group_payments(creditor: AztecAddress, debtors: [AztecAddress; 2], amount: Field) {\n        //can be called by anyone\n\n        //increase the credit for the creditor with each member\n        let shared_amount : u32 = amount as u32 / (debtors.len() + 1);\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n            let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n            let loc_credit = storage.group_balances_credit.at(key_credit);\n            increment(loc_credit, shared_amount.to_field(), creditor, debtor);\n        }\n        //increase the debt for each member with the creditor\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n            let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n            let loc_debt = storage.group_balances_debt.at(key_debt);\n            increment(loc_debt, shared_amount.to_field(), debtor, creditor);\n        }\n    }\n\n    #[private]\n    fn read_balance_credit(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //for this function i need to also get the notes that the debtor has sent if they have sent any\n        //if they have sent new notes, i need to nullify the old ones that i have sent to the debtor\n        //make a new one with the new outstanding balance\n        //tricky part is listening for new notes that the debtor has sent, updating the balance\n\n        let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n        let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n        let options = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key_credit).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                let note = balance_notes_credit.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_balance_debt(debtor: AztecAddress, creditor: AztecAddress) -> u64 {\n        let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n        let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n        let options = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key_debt).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_total_balance(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //going to have to hand type this, could not call the other private functions\n\n        //keys to check in storage\n\n        let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n        let key = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n\n        //options for the notes \n        let options_1 = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options_1);\n\n        let options_2 = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options_2);\n\n        //sum the notes\n        let mut total_balance_credit = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                // let note = balance_notes_credit.get_unchecked(i);\n                let note = balance_notes_credit.get(i);\n                total_balance_credit += note.value;\n            }\n        }\n\n        //sum the notes\n        let mut total_balance_debt = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get(i);\n                total_balance_debt += note.value;\n            }\n        }\n\n        //convert the note to integer\n\n        let total_debt = U128::from_integer(total_balance_debt);\n        let total_credit = U128::from_integer(total_balance_credit);\n        let tot_debt: i64 = total_debt.to_integer();\n        let tot_credit: i64 = total_credit.to_integer();\n        let total_balance = tot_credit - tot_debt;\n        total_balance as u64\n        // let total_balance = total_credit - total_debt;\n        // total_balance\n    }\n\n\n    unconstrained pub(crate) fn admin() -> pub AztecAddress {\n        let admin_note: NewAddressNote = storage.admin.view_note();\n        admin_note.address\n    }\n}\n\n\n"
    },
    "82": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/address-note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "88": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "89": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "91": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"
    },
    "94": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "103": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "105": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "110": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"
    },
    "112": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext}};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"
    },
    "125": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "126": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "128": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "129": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"
    },
    "130": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "131": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "135": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"
    },
    "139": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"
    },
    "143": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr",
      "source": "// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"
    },
    "147": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"
    },
    "165": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"
    },
    "166": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "169": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "171": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"
    },
    "179": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "186": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "232": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"
    },
    "310": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "311": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "317": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    public_keys::PublicKeys, contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys : PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11]\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize(\n                [\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15]\n            ]\n            )\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"
    },
    "318": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n    partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n    salted_initialization_hash::SaltedInitializationHash\n},\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(contract_class_id, salted_initialization_hash);\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "320": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "321": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "325": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "327": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(_vk: VerificationKey<N>) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "328": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "358": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/utils.nr",
      "source": "use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(\n        encode_and_encrypt_note(\n            balance.context,\n            outgoing_viewer_ovpk_m,\n            recipient_keys.ivpk_m,\n            recipient\n        )\n    );\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n"
    },
    "359": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "get_public_keys_and_partial_address",
    "random",
    "decompose_hint",
    "notify_created_note_oracle_wrapper",
    "get_key_validation_request",
    "lt_32_hint",
    "lte_16_hint",
    "build_msg_block_iter",
    "pad_msg_block",
    "attach_len_to_msg_block",
    "build_msg_block_iter",
    "emit_encrypted_note_log_oracle_wrapper",
    "directive_invert",
    "directive_integer_quotient"
  ]
}