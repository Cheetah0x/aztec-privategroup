{
  "noir_version": "0.35.0+df29d315d6b71131ffe0180c97130395edb2e4ba-aarch64",
  "hash": 0,
  "abi": {
    "error_types": {},
    "parameters": [
      {
        "name": "inputs",
        "type": {
          "fields": [
            {
              "name": "call_context",
              "type": {
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::function_selector::FunctionSelector"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::call_context::CallContext"
              }
            },
            {
              "name": "historical_header",
              "type": {
                "fields": [
                  {
                    "name": "last_archive",
                    "type": {
                      "fields": [
                        {
                          "name": "root",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "next_available_leaf_index",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                    }
                  },
                  {
                    "name": "content_commitment",
                    "type": {
                      "fields": [
                        {
                          "name": "num_txs",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "txs_effects_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "in_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "out_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::content_commitment::ContentCommitment"
                    }
                  },
                  {
                    "name": "state",
                    "type": {
                      "fields": [
                        {
                          "name": "l1_to_l2_message_tree",
                          "type": {
                            "fields": [
                              {
                                "name": "root",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "next_available_leaf_index",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                          }
                        },
                        {
                          "name": "partial",
                          "type": {
                            "fields": [
                              {
                                "name": "note_hash_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "nullifier_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "public_data_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::partial_state_reference::PartialStateReference"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::state_reference::StateReference"
                    }
                  },
                  {
                    "name": "global_variables",
                    "type": {
                      "fields": [
                        {
                          "name": "chain_id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "version",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "block_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "slot_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "timestamp",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        },
                        {
                          "name": "coinbase",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::eth_address::EthAddress"
                          }
                        },
                        {
                          "name": "fee_recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "gas_fees",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::global_variables::GlobalVariables"
                    }
                  },
                  {
                    "name": "total_fees",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::header::Header"
              }
            },
            {
              "name": "tx_context",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "version",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "gas_settings",
                    "type": {
                      "fields": [
                        {
                          "name": "gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "teardown_gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "max_fees_per_gas",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        },
                        {
                          "name": "inclusion_fee",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::gas_settings::GasSettings"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::transaction::tx_context::TxContext"
              }
            },
            {
              "name": "start_side_effect_counter",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
        },
        "visibility": "private"
      },
      {
        "name": "debtor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      },
      {
        "name": "creditor",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      },
      {
        "name": "amount",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "fields": [
          {
            "name": "call_context",
            "type": {
              "fields": [
                {
                  "name": "msg_sender",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "storage_contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "function_selector",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::function_selector::FunctionSelector"
                  }
                },
                {
                  "name": "is_delegate_call",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "is_static_call",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::call_context::CallContext"
            }
          },
          {
            "name": "args_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "returns_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "min_revertible_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "is_fee_payer",
            "type": {
              "kind": "boolean"
            }
          },
          {
            "name": "max_block_number",
            "type": {
              "fields": [
                {
                  "name": "_opt",
                  "type": {
                    "fields": [
                      {
                        "name": "_is_some",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "_value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::option::Option"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::max_block_number::MaxBlockNumber"
            }
          },
          {
            "name": "note_hash_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "nullifier_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "key_validation_requests_and_generators",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "request",
                    "type": {
                      "fields": [
                        {
                          "name": "pk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        },
                        {
                          "name": "sk_app",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                    }
                  },
                  {
                    "name": "sk_app_generator",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
              }
            }
          },
          {
            "name": "note_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::note_hash::NoteHash"
              }
            }
          },
          {
            "name": "nullifiers",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::nullifier::Nullifier"
              }
            }
          },
          {
            "name": "private_call_requests",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "returns_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "start_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::private_call_request::PrivateCallRequest"
              }
            }
          },
          {
            "name": "public_call_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::public_call_request::PublicCallRequest"
              }
            }
          },
          {
            "name": "public_teardown_call_request",
            "type": {
              "fields": [
                {
                  "name": "contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "args_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::public_call_request::PublicCallRequest"
            }
          },
          {
            "name": "l2_to_l1_msgs",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
              }
            }
          },
          {
            "name": "start_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "end_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "note_encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "note_hash_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::NoteLogHash"
              }
            }
          },
          {
            "name": "encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::EncryptedLogHash"
              }
            }
          },
          {
            "name": "unencrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::LogHash"
              }
            }
          },
          {
            "name": "historical_header",
            "type": {
              "fields": [
                {
                  "name": "last_archive",
                  "type": {
                    "fields": [
                      {
                        "name": "root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "next_available_leaf_index",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                  }
                },
                {
                  "name": "content_commitment",
                  "type": {
                    "fields": [
                      {
                        "name": "num_txs",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "txs_effects_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "in_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "out_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::content_commitment::ContentCommitment"
                  }
                },
                {
                  "name": "state",
                  "type": {
                    "fields": [
                      {
                        "name": "l1_to_l2_message_tree",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "partial",
                        "type": {
                          "fields": [
                            {
                              "name": "note_hash_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "nullifier_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "public_data_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::partial_state_reference::PartialStateReference"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::state_reference::StateReference"
                  }
                },
                {
                  "name": "global_variables",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "block_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "slot_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "timestamp",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 64
                        }
                      },
                      {
                        "name": "coinbase",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "fee_recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "gas_fees",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::global_variables::GlobalVariables"
                  }
                },
                {
                  "name": "total_fees",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::header::Header"
            }
          },
          {
            "name": "tx_context",
            "type": {
              "fields": [
                {
                  "name": "chain_id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "version",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "gas_settings",
                  "type": {
                    "fields": [
                      {
                        "name": "gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "teardown_gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "max_fees_per_gas",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      },
                      {
                        "name": "inclusion_fee",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::gas_settings::GasSettings"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::transaction::tx_context::TxContext"
            }
          }
        ],
        "kind": "struct",
        "path": "protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
      },
      "visibility": "databus"
    }
  },
  "bytecode": "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Lc+HrJdPCaZbYNwkRK3qED3JImtnheVELTVcQaDhp0ANP2NC1Mj+9bnlPUfm5HOCnvMFEfl9QUjUSgv0GULW05dEun7p6WqSLvMzsbGo9VUWocNfEdDl15bTpYz7awK61PmKOCBfExxi4MEjz7etGiLj/obJMPElMOaVlg8TMtZvCIaJby0fvmVeviXuOdFq+B3R4PDdfzA45BENDt9nETr8PcHgsMrywUHGvYrJ4CALeRXBIQYePPJ826ohMu4fmAwO3wFjXm354CBj/YFgcPjR8sFB5uVH4p4TrYZriAaHNVn07+HnZuLu9RPwDJkcln4C50+tn7MIHf6ZYFhaa/mwJONea2hYcqJb7hrPV/Rbh2uAOULme53lD1DZ6NYRPEDXW/4AlTGvJ4j7F6KH3i+aj4CgNaHOGeKMryUYepDnfYPldS813ECg4TqghhuZgBbymfOr5c8JmZNfCfrlJqJ+uYnw7V6lBfoMIevpN6IzhNbyN/BsrVZxsJ8u7pVjNxEIl5sJIG2kL9d7Gv01d8jr3b7rXb7rnb7rHb7r7b7rbb7rrb7rLb7rP3zXv/uuN/uuf/Ndb/Jd/+q73ui73uC7/sV3vd53vc53vdZ3/bPv+iff9Rrf9Y++69W+6x9816t819/7rr/zXX/ru17pux6Xdvh6rO96jO96tO96lO96pO96hO96uO96mO96qO96iO96sO96kO96oO96gO+6v++6n++6r++6j++6t++6l++6p++6h++6u++6m++6q++6i++6s++6k+/6Jt91R991oe+6SuPD15V91yf4riv5riv6riv4rsv7rsv5rsv6rsv4rkv7rkv5rkv6rkv4rov7ruN918V813G+64Pph68P+K73+67/9F3v813v9V3v8V3v9l3v8l3v9F3v8F1v911v811v9V1vzjp8Hco8fN3Qd93Id53qu07zXaf7rhv7rsO+6wzfdabvOst33cR3ne27buq7vth3fYnvupnvurnvuoXv+lLfdUvf9WW+68t911f4rlv5rlv7rq/0XV/lu27ju27ru27nu+7lu+7pu+7hu+7uu+7mu+7qu+7iu+7su+7ku77Jd93Rd13ouy7wXef7rvN817m+61G+65G+6xG+6+G+62G+66G+6yG+68G+60G+64G+6wG+6/6+636+676+6z6+697e9W1xf63fxRn4Q9gWYVuF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",
  "debug_symbols": "7P3djiRZtl1pvkte80JFdOsfX6XRaLC7WA0CBbLRZF0RfPeyyDhq7nnM0yyj1vapYmt/vMoqGIOWY64M1TEkwuV//u1/+8//7//z//v/+i//9X//b//9b//x//E///Z//Lf/z3/6H//lv/3Xt/+v//m3bfz9/99////9p//6x//nf/8f/+n//z/+9h+32z7+w9/+83/93/74j+fxv/7D3/73//J//Oe//cf76X/9hw8/vN8uzx/eb7fr+w9v1+svfvo8zpd/++nz5XT/4qe302N/PH+T02Ps7z9/3m+/+vlxuj9/fPzxE8+fHr/64W17/irbdh0///D/8z/8bbsg80/IXJH5J2RuRydzvf4g88f/+5+Tud/254/fH1uJzB2Zf0LmUSZzvp+fF3y+33788Ha6/PH/wn767f8vbOX/F7b9/D7Aftt+2uvyi59+nE9PpI/zvv/D7/OLyzlf7s9f/+3/me324fffv/nvf/7V73/Zr6d/+791OW+XL37/8Xj/u+Dl/ON/Xfvjl+e/v//w/XL5/Iff/vudn7ezX//hr/zHrz6O/Kuff/xN5O3u//2vfvm+1K/fl/ot+6vv5/Pt/X97jw8gf/m5djmP/f23uX3xd47Hvj3/VvDz3zduv+R4ef7s9vjpm8q2/eqv+9je/8KPy+OLT7Tz/fmdaZxPn3+e7bf75f2D+PH44sNv3ifl/sA6xfp8wjrGesM6xnovs95O4/2b3nY6f0V7e5zef/on3r+e8fL8NR7XH0ze/gp//9XP3/dXH9/3V79831/911/y3r7EPH/1MW5f/eq3269+9Tch+aUDjfO7A/30xW17+3vSH7/P7WC/z/1gv8/jWL/POKV/n/N4D3fn+/4Pv88vPkLG+197Hz9/KuyXX/7P6v3D6e1/VtefPvfOv/prb+//w9rf/i9+9df+2W7Gj99k//tHzthgnIFxh3EGxjOM/yLGH5/a95+++v4bxgHjDIwXGGdgvML4r2G8/fhr36+nf4/xti7G/fT8L7nv41L7iLnDOAPjA8YJGC8LW8xfxPjZR8xlYYuZiXFhi5mJcWGL+WsYP/3Ccxkrf2/cfmC8/sNf+w8yS4vJp2QWdo39+u4a59OXf+3Pv5as7BoTMa7sGhMxruwafw3jZ19Lriu7xkSMK7vGRIwru8Zfwvjpl+Tr0k9Mth8Y93//VfA6kPknZBbWh/P2459Vv9Ta3XVh15iJcWHXmIlxYdf4ixg//VqysGtMxHhb2DVmYlzYNf4axk+/JN+W/qezfnwVvHzopTf68M/IjGOTufz4F7+u+/0rMqfxeP+XFE6X08//c/rN/9b57eCy8W04Htw2vg3Hg+vGt+F4cN/4NhwPLhzfheP94MbxbTgeXDm+DceDO8e34XhwQ/k2HAeOUzjymTkc+cwcjnxmDkc+M4djL5+5/PSnNV7G+SuO8/4skEcvn3kdx+/rM3/89nmL2N9/epy++u236/ufFLjdfvqTRt6e3RzsCs44TuE4cJzC8YLjFI55i9ju/4zjH7/PhG/j2/ufZrttt9NXv8/nf0rO436w3+dxrN9nO52O9gttR/uF9vQv1PKPtnn7WwuOUzgOHKdwvOD4t/qfbrOdrjhO4XjDcQrHO45/q/9xS9vpsS7HiX/CzZtT4TiF44bjFI4L+8zEP+TmjQGOUzgOHKdwXNhnJv6pS9u2tM989ocLbdvSivI5moWtY+IfdbNtK1vHRI77ytYxk+PK1jHvT7vZ9pWtYybHla1jJseB49/qf/zSti/9FOWzP2Vo24nEP0WzsEhM/DNvtn1h65jKcWHrmMnxvLB1TPxjb7bzwtYxlePC1jGV48LWMfHPYdrOC1vH53/c0HYmEv8UzcFF4rv8q3nb+eDa8X1AHtw7vg/Ig4vHtwE5Dm4e3wfkwdXj+4A8uHt8H5AHl4/vA3IAOQfkwV3l+4BkNpNAMptJIJnNJJC9zOZl/4b/dullNi8E+X3N5u+/ft4nWv6RGdvlDOQckCMO8tM/fGSb8V7gfX/ns//0w7/+he6PJ5/Hdvrib33nx/N3H+eff/ZXf93HY3s+EXg8Lo8vNj2/P2z4h7/yrxbdb/fnb7zfHo8v5p95KzO+6T/eL32/fHUr+3n8+Kfc/uGnH3/+QhO+Mb/9dd///v7zf+VfH+91vAO6Pn58Fdsev/pr396/uN23H3/l+6/+wtfH8+8ut5//ab4/zubjqez78w87Oe/XH4+a9n+Dcl8Syvn8/CXO55/+BJgnlIdL+XApM16m2+5SZrwat9+l7C7l46WcXcrHSxku5eOlXJaEcrs+vwCf76efoPz5bXLGq2d/I5T7fXtXsvP5Cyq355fa2+2H9G/P9Y/9LfUtML7/tU/X/fP/ppfLuwZf3n7tH3/p0+WX398v9x//4N11u/3Dz/+dzbG/rL6WzeTvrPevdOt8ff7+55/O+PFLB/2h2G+fBz/+TrBtvxby2/s/mbp/+Q/erS3Zt9OBV9/e//b/tv9Xq7/t8fzpx3W7fvG/h8f9+mPJ0+nD/xpuGy6/5LLj8ksuZ1x+yWWsyWU77dfx4xvdtn8kc0Hmn5C5rkrmern++P53O3/x84t/c7m5krf/fL9//N/PHZl/QubIjvNSMvcje8D+/lu8qevtCzL3dy2+X+5f/Oz58v4H+Z8vP/30r/6Vq/vt+aOPn1558cdf9+/8juwL34Hfkb3iO/A7sn/8JX5//P3p/W9V9/HFT/+VQjx+/Ck2Y//pl96vv8prY9vf0f30Jejth//Oe+Ad5X1kW+rI+8gO1pH3kW2mI+8jO1JH3od+utSP96ONz30T3m3875vwbuOL34Q3v8zyHnhHefPLLG9+meXNL7O8+WWWN79M8t5P/DLLm19mefPLLG9+meU98I7y5pdZ3vwyy5tfZnnzyyxvfhnlvfHLLG9+meXNL7O8+WWW98A7yptfZnnzyyxvfpnlzS+zvPlllPfOL7O8+WWWN7/M8uaXWd4D7yhvfpnlzS+zvPlllje/zPLml1HeZ36Z5c0vs7z55de8r9vzv+C47tcPCCljGeGAsIqQ2JURcrV/AeH7nxM8rrePCOlXGSGjKiMkSVWEg/eUEVKZ6ifyYCdlhOykjHBAWEXITsofJ+ykjJCdlBGykzJCdlJFeGEnZYTspIyQnZQRspMywgFhFSE7KSNkJ2WE7KSMkJ2UEbKTauy6spMyQnZSRshOygjZSfXj5DogrCJkJ2WE7KSMkJ2UEbKTMkJ2UkV4YydlhOykjJCdlBGykzLCAWEVITspI2QnZYTspBq7buykjJCdVBHe2UkZITupfpzc2UkZITspIxwQVhGykzJCdlJGyE7KCNlJGSE7qSJ8sJMyQnZSRshOygjZSRnhgLCKkJ1UY9eDnZQRspMyQnZSRshOih8n5xM7KSNkJ2WE7KSMkJ2UEQ4IqwjZSRkhOykjZCdlhOykjJCdVBFu7KSMkJ2UEbKTMkJ2Uoxd521AWEXITsoI2UkZITspf5ywkzJCdlJFuLOTMkJ2UkbITsoI2UkZ4YCwipCdlBGykzJCdlJGyE7KCNlJFaG30NcRspNq7PKu+DpCdlJGOCCsImQn5Y8TdlJGyE7KCNlJGSE7qSL0rvg6QnZSRshOygjZSRnhgLCKkJ2UEbKTMkJ2UkbITsoI2Uk1dnlXfB0hOykjZCdlhOyk+nHiXfF1hOykjJCdlBGykzJCdlJGyE6qCL0rvo6QnZQRspMyQnZSRjggrCJkJ2WE7KSMkJ1UY5d3xdcRspMqQu+KryNkJ9WPE++KryNkJ2WEA8IqQnZSRshOygjZSRkhOykjZCdVhN4VX0fITsoI2UkZITspIxwQVhGyk2rs8q74OkJ2UkbITsoI2Un148S74usI2UkZITspI2QnZYQDwipCdlJGyE7KCNlJGSE7KSNkJ0WEw7vi6wjZSRkhOykjZCfF2DVOA8IqQnZSRshOygjZSfnjhJ2UEbKTKkLviq8jZCdlhOykjJCdlBEOCKsI2UkZITspI2QnZYTspIyQnVQReld8HSE7qcYu74qvI2QnZYQDwipCdlL+OGEnZYTspIyQnZQRspMqQu+KryNkJ2WE7KSMkJ2UEQ4IqwjZSRkhOykjZCdlhOykjJCdVGOXd8XXEbKTMkJ2UkbITqofJ94VX0fITsoI2UkZITspI2QnZYTspIrQu+LrCNlJGSE7KSNkJ2WEA8IqQnZSRshOygjZSTV2eVd8HSE7qSL0rvg6QnZS/Tjxrvg6QnZSRjggrCJkJ2WE7KSMkJ2UEbKTMkJ2UkXoXfF1hOykjJCdlBGykzLCAWEVITupxi7viq8jZCdlhOykjJCdVD9OvCu+jpCdlBGykzJCdlJGOCCsImQnZYTspIyQnZQRspMyQnZSRehd8XWE7KSMkJ2UEbKTauzyrvg6QnZSRshOygjZSfnjhJ2UEbKTIsKLd8XXEbKTMkJ2UkbITsoIB4RVhOykjJCdlBGykzJCdlJGyE6qCL0rvo6QnRRj18W74usI2UkZ4YCwipCdlD9O2EkZITspI2QnZYTspIrQu+LrCNlJGSE7KSNkJ2WEA8IqQnZSRshOygjZSRkhOykjZCfV2OVd8XWE7KSMkJ2UEbKT6seJd8XXEbKTMkJ2UkbITsoI2UkZITupIvSu+DpCdlJGyE7KCNlJGeGAsIqQnZQRspMyQnZSjV3eFV9HyE6qCL0rvo6QnVQ/Trwrvo6QnZQRDgirCNlJGSE7KSNkJ2WE7KSMkJ1UEXpXfB0hOykjZCdlhOykjHBAWEXITqqxy7vi6wjZSRkhOykjZCfVjxPviq8jZCdlhOykjJCdlBEOCKsI2UkZITspI2QnZYTspIyQnVQReld8HSE7KSNkJ2WE7KQau7wrvo6QnZQRspMyQnZS/jhhJ2WE7KSK0Lvi6wjZSRkhOykjZCdlhAPCKkJ2UkbITsoI2UkZITspI2QnRYRX74qvI2Qnxdh19a74OkJ2UkY4IKwiZCfljxN2UkbITsoI2UkZITupIvSu+DpCdlJGyE7KCNlJGeGAsIqQnZQRspMyQnZSRshOygjZSTV2eVd8HSE7KSNkJ2WE7KT6ceJd8XWE7KSMkJ2UEbKTMkJ2UkbITqoIvSu+jpCdlBGykzJCdlJGOCCsImQnZYTspIyQnVRjl3fF1xGykypC74qvI2Qn1Y8T74qvI2QnZYQDwipCdlJGyE7KCNlJGSE7KSNkJ1WE3hVfR8hOygjZSRkhOykjHBBWEbKTauzyrvg6QnZSRshOygjZSfXjxLvi6wjZSRkhOykjZCdlhAPCKkJ2UkbITsoI2UkZITspI2QnVYTeFV9HyE7KCNlJGSE7qcYu74qvI2QnZYTspIyQnZQ/TthJGSE7qSL0rvg6QnZSRshOygjZSRnhgLCKkJ2UEbKTMkJ2UkbITsoI2UkVoXfF1xGyk2rs8q74OkJ2UkY4IKwiZCfljxN2UkbITsoI2UkZITspIrx5V3wdITspI2QnZYTspIxwQFhFyE7KCNlJGSE7KSNkJ2WE7KQYu27eFV9HyE7KCNlJGSE7qX6ceFd8HSE7KSNkJ2WE7KSMkJ2UEbKTKkLviq8jZCdlhOykjJCdlBEOCKsI2UkZITspI2Qn1djlXfF1hOykitC74usI2Un148S74usI2UkZ4YCwipCdlBGykzJCdlJGyE7KCNlJFaF3xdcRspMyQnZSRshOyggHhFWE7KQau7wrvo6QnZQRspPy3wvZSRWhd8XXEbKTMkJ2UkbITsoIB4TFLzXeFV9HyE7KCNlJ+e+F7KSMkJ1UEXpXfB0hOykjZCdlhOyk+qXGu+LrCNlJGSE7KSNkJ+WPE3ZSRshOqgi9K76OkJ2UEbKTMkJ2UkY4IKwiZCdlhOykjJCdlBGyk68R3u7PH377j48PCNnJ1wj36/5EuP/0S/9RHD6iG9v+ju58+ve8vVg+zJv3ZHmTpCxvRpXlPfCO8uZqWd7ELsubBWZ5U8Ysb34Z5f3gl1ne/DLLm19mefPLLO+Bd5Q3v8zy5pdZ3vwyy5tfZnnzyyTv+4lfZnnzyyxvfpnlzS+zvAfeUd78MsubX2Z588ssb36Z5c0vo7w3fpnlzS+zvPlllje/zPIeeEd588ssb36Z5c0vs7z5ZZY3v4zy3vlllje/zPLml1ne/DLLe+Ad5c0vs7z5ZZY3v8zy5pfFP9b2vlPGKsIzCywjJHZlhFyt+CfA3c/0q4xwQFhFSJLKCHlPGSGVKX8is5MyQnZSRTjYSRkhO6l+nAx2UkbITsoIB4RVhOykjJCdlBGykzJCdlJGyE6qCC/spIyQnZQRspMyQnZSRjggrCJkJ9XYdWEnZYTspIyQnZQRspPqx8mVnZQRspMyQnZSRshOyggHhFWE7KSMkJ2UEbKTMkJ2UkbITqoIb+ykjJCdlBGykzJCdlKNXbcBYRUhOykjZCdlhOyk/HHCTsoI2UkV4Z2dlBGykzJCdlJGyE7KCAeEVYTspIyQnZQRspMyQnZSRshOqggf7KSMkJ1UY9eDnZQRspMywgFhFSE7KX+csJMyQnZSRshOygjZSRHh48ROygjZSRkhOykjZCdlhAPCKkJ2UkbITsoI2UkZITspI2Qnxdj12NhJGSE7KSNkJ2WE7KT6cbINCKsI2UkZITspI2QnZYTspIyQnVQR7uykjJCdlBGykzJCdlJGOCCsImQnZYTspIyQnVRjl3fF1xGykypC74qvI2Qn1Y8T74qvI2QnZYQDwipCdlJGyE7KCNlJGSE7KSNkJ1WE3hVfR8hOygjZSRkhOykjHBBWEbKTauzyrvg6QnZSRshOygjZSfXjxLvi6wjZSRkhOykjZCdlhAPCKkJ2UkbITsoI2UkZITspI2QnVYTeFV9HyE7KCNlJGSE7qcYu74qvI2QnZYTspIyQnZQ/TthJGSE7qSL0rvg6QnZSRshOygjZSRnhgLCKkJ2UEbKTMkJ2UkbITsoI2UkVoXfF1xGyk2rs8q74OkJ2UkY4IKwiZCfljxN2UkbITsoI2UkZITupIvSu+DpCdlJGyE7KCNlJGeGAsIqQnZQRspMyQnZSRshOygjZSTF2bScvi5/AkJ/UGRKUOkOGUvxIeWM4MCwz5Ch1hiSlzpCl1BnSlDpDnlJm6LXxExjylDpDnlJnyFPqDAeGZYY8pc6Qp9QZ8pRy+/L6+AkMeUqZoRfIT2DIU8qfKV4hP4EhT6kzHBiWGfKUOkOeUmfIU+oMeUqdIU8pM/Qq+QkMeUqdIU+pM+QpdYYDwzJDnlJuX14oP4EhT6kz5Cl1hjyl/JnipfITGPKUOkOeUmfIU+oMB4ZlhjylzpCn1BnylDpDnlJnyFPKDL1efgJDnlJnyFPqDHlKuX15xfwEhjylzpCn1BnylPpnCk+pM+QpZYZeND+BIU+pM+QpdYY8pc5wYFhmyFPqDHlKnSFPqTPkKXWGPKXM0CvnJzDkKeX25aXzExjylDrDgWGZIU+pf6bwlDpDnlJnyFPqDHlKmaGXz09gyFPqDHlKnSFPqTMcGJYZ8pQ6Q55SZ8hT6gx5Sp0hTym3L6+hn8CQp9QZ8pQ6Q55S/kzxKvoJDHlKnSFPqTPkKXWGPKXOkKdUGW7eRz+BIU+pM+QpdYY8pc5wYFhmyFPqDHlKnSFPqbavzfvoJzDkKWWG3kc/gSFPKX+meB/9BIY8pc5wYFhmyFPqDHlKnSFPqTPkKXWGPKXM0PvoJzDkKXWGPKXOkKfUGQ4Mywx5Srl9eR/9BIY8pc6Qp9QZ8pTyZ4r30U9gyFPqDHlKnSFPqTMcGJYZ8pQ6Q55SZ8hT6gx5Sp0hTykz9D76CQx5Sp0hT6kz5Cnl9uV99BMY8pQ6Q55SZ8hT6p8pPKXOkKeUGXof/QSGPKXOkKfUGfKUOsOBYZkhT6kz5Cl1hjylzpCn1BnylDJD76OfwJCnlNuX99FPYMhT6gwHhmWGPKX+mcJT6gx5Sp0hT6kz5Cllht5HP4EhT6kz5Cl1hjylznBgWGbIU+oMeUqdIU+pM+QpdYY8pdy+vI9+AkOeUmfIU+oMeUr5M8X76Ccw5Cl1hjylzpCn1BnylDpDnlJm6H30ExjylDpDnlJnyFPqDAeGZYY8pc6Qp9QZ8pRy+/I++gkMeUqV4e599BMY8pTqZ8ruffQTGPKUOsOBYZkhT6kz5Cl1hjylzpCn1BnylDJD76OfwJCn1BnylDpDnlJnODAsM+Qp5fblffQTGPKUOkOeUmfIU8qfKd5HP4EhT6kz5Cl1hjylznBgWGbIU+oMeUqdIU+pM+QpdYY8pczQ++gnMOQpdYY8pc6Qp5Tbl/fRT2DIU+oMeUqdIU+pf6bwlDpDnlJm6H30ExjylDpDnlJnyFPqDAeGZYY8pc6Qp9QZ8pQ6Q55SZ8hTygy9j34CQ55Sbl/eRz+BIU+pMxwYlhnylPpnCk+pM+QpdYY8pc6Qp5QZeh/9BIY8pc6Qp9QZ8pQ6w4FhmSFPqTPkKXWGPKXOkKfUGfKUcvvyPvoJDHlKnSFPqTPkKeXPFO+jn8CQp9QZ8pQ6Q55SZ8hT6gx5Spmh99FPYMhT6gx5Sp0hT6kzHBiWGfKUOkOeUmfIU8rty/voJzDkKWWG3kc/gSFPKX+meB/9BIY8pc5wYFhmyFPqDHlKnSFPqTPkKXWGPKXK8Ox99BMY8pQ6Q55SZ8hT6gwHhmWGPKXavs7eRz+BIU+pM+QpdYY8pfyZ4n30ExjylDpDnlJnyFPqDAeGZYY8pc6Qp9QZ8pQ6Q55SZ8hTygy9j34CQ55SZ8hT6gx5Srl9eR/9BIY8pc6Qp9QZ8pT6ZwpPqTPkKWWG3kc/gSFPqTPkKXWGPKXOcGBYZshT6gx5Sp0hT6kz5Cl1hjylzND76Ccw5Cnl9uV99BMY8pQ6w4Fh+e+HPKXOkKfUGfKUOkOeUmfIU8oMvY++/t3G++gnMOQpdYY8pf73w4FhmSFPqTPkKXWGPKXOkKfUGfKU8ncb76OfwJCn1BnylDpDnlL+TPE++gkMeUqdIU+pM+QpdYY8pc6Qp5QZeh/9BIY8pc6Qp9QZ8pQ6w4Hhlwxv9+cPv/3Hx0eGPOVrhvt1fzLcf/ql/8gPH9GNbX9Hdz59BE5qwsAZUBg4XQoD51ZZ4HciFgbO2sLAKV4YOB8MAx+AZ4EzzTBwphkGzjTDwJlmGDjTzAJ/MM0wcKYZBs40w8CZZhj4ADwLnGmGgTPNMHCmGQbONMPAmWYU+DgxzTBwphkGzjTDwJlmGPgAPAucaYaBM80wcKYZBs40w8CZZhb4xjTDwJlmGDjTDANnmmHgA/AscKYZBs40w8CZZhg40wwDZ5pZ4DvTDANnmmHgTDMMnGmGgQ/Ai38o7tjJY50hH6wzpHh1hqyt+gfHjZ2IlRmeuVWdIV2qM2RAdYakpvy5fB4YlhnylDpDnlJnyFPqnyk8pc6Qp5QZDp5SZ8hT6gx5Sp0hT6kzHBiWGfKUOkOeUmfIU+oMeUqdIU8pM7zwlDpDnlJuXxeeUmfIU+oMB4Zlhjyl/pnCU+oMeUqdIU+pM+QpZYZXnlJnyFPqDHlKnSFPqTMcGJYZ8pQ6Q55SZ8hT6gx5Sp0hTym3rxtPqTPkKXWGPKXOkKeUP1NuA8MyQ55SZ8hT6gx5Sp0hT6kz5CllhneeUmfIU+oMeUqdIU+pMxwYlhnylDpDnlJnyFPK7evOU+oMeUqZ4YOn1BnylPJnyoOn1BnylDrDgWGZIU+pM+QpdYY8pc6Qp9QZ8pQqw8uJp9QZ8pQ6Q55SZ8hT6gwHhmWGPKXavi4nnlJnyFPqDHlKnSFPKX+mbDylzpCn1BnylDpDnlJnODAsM+QpdYY8pc6Qp9QZ8pQ6Q55SZrjzlDpDnlJnyFPqDHlKuX15H/0EhjylzpCn1BnylPpnCk+pM+QpZYbeRz+BIU+pM+QpdYY8pc5wYFhmyFPqDHlKnSFPqTPkKXWGPKXM0PvoJzDkKeX25X30ExjylDrDgWGZIU+pf6bwlDpDnlJnyFPqDHlKmaH30U9gyFPqDHlKnSFPqTMcGJYZ8pQ6Q55SZ8hT6gx5Sp0hTym3L++jn8CQp9QZ8pQ6Q55S/kzxPvoJDHlKnSFPqTPkKXWGPKXOkKeUGXof/QSGPKXOkKfUGfKUOsOBYZkhT6kz5Cl1hjyl3L68j34CQ55SZuh99BMY8pTyZ4r30U9gyFPqDAeGZYY8pc6Qp9QZ8pQ6Q55SZ8hTygy9j34CQ55SZ8hT6gx5Sp3hwLDMkKeU25f30U9gyFPqDHlKnSFPqX6mXL2PfgJDnlJnyFPqDHlKneHAsMyQp9QZ8pQ6Q55SZ8hT6gx5Spmh99FPYMhT6gx5Sp0hT6m2r6v30U9gyFPqDHlKnSFPqX+m8JQ6Q55SZuh99BMY8pQ6Q55SZ8hT6gwHhmWGPKXOkKfUGfKUOkOeUmfIU8oMvY9+AkOeUm5f3kc/gSFPqTMcGJYZ8pT6ZwpPqTPkKXWGPKXOkKeUGXof/QSGPKXOkKfUGfKUOsOBYZkhT6kz5Cl1hjylzpCn1BnylHL78j76CQx5Sp0hT6kz5CnlzxTvo5/AkKfUGfKUOkOeUmfIU+oMeUqZoffRT2DIU+oMeUqdIU+pMxwYlhnylDpDnlJnyFPK7cv76Ccw5Cllht5HP4EhTyl/pngf/QSGPKXOcGBYZshT6gx5Sp0hT6kz5Cl1hjylzND76Ccw5Cl1hjylzpCn1BkODMsMeUq5fXkf/QSGPKXOkKfUGfKU8meK99FPYMhT6gx5Sp0hT6kzHBiWGfKUOkOeUmfIU+oMeUqdIU+pMrx5H/0EhjylzpCn1BnylGr7up0GhmWGPKXOkKfUGfKU+mcKT6kz5Cllht5HP4EhT6kz5Cl1hjylznBgWGbIU+oMeUqdIU+pM+QpdYY8pczQ++gnMOQp5fblffQTGPKUOsOBYZkhT6l/pvCUOkOeUmfIU+oMeUqZoffRT2DIU+oMeUqdIU+pMxwYlhnylDpDnlJnyFPqDHlKnSFPKbcv76OfwJCn1BnylDpDnlL+TPE++gkMeUqdIU+pM+QpdYY8pc6Qp5QZeh/9BIY8pc6Qp9QZ8pQ6w4FhmSFPqTPkKXWGPKXcvryPfgJDnlJm6H30ExjylPJnivfRT2DIU+oMB4ZlhjylzpCn1BnylDpDnlJnyFPKDL2PfgJDnlJnyFPqDHlKneHAsMyQp5Tbl/fRT2DIU+oMeUqdIU8pf6Z4H/0EhjylzpCn1BnylDrDgWGZIU+pM+QpdYY8pc6Qp9QZ8pQyQ++jn8CQp9QZ8pQ6Q55Sbl/eRz+BIU+pM+QpdYY8pf6ZwlPqDHlKleHd++gnMOQpdYY8pc6Qp9QZDgzLDHlKnSFPqTPkKXWGPKXOkKeUGXof/QSGPKXavu7eRz+BIU+pMxwYlhnylPpnCk+pM+QpdYY8pc6Qp5QZeh/9BIY8pc6Qp9QZ8pQ6w4FhmSFPqTPkKXWGPKXOkKfUGfKUcvvyPvoJDHlKnSFPqTPkKeXPFO+jn8CQp9QZ8pQ6Q55SZ8hT6gx5Spmh99FPYMhT6gx5Sp0hT6kzHBiWGfKUOkOeUmfIU8rty/voJzDkKWWG3kc/gSFPKX+meB/9BIY8pc5wYFhmyFPqDHlKnSFPqTPkKXWGPKXM0PvoJzDkKXWGPKXOkKfUGQ4Mywx5Srl9eR/9BIY8pc6Qp9QZ8pTyZ4r30U9gyFPqDHlKnSFPqTMcGJYZ8pQ6Q55SZ8hT6gx5Sp0hTykz9D76CQx5Sp0hT6kz5Cnl9uV99BMY8pQ6Q55SZ8hT6p8pPKXOkKeUGXof/QSGPKXOkKfUGfKUOsOBYZkhT6kz5Cl1hjylzpCn1BnylCrDh/fRT2DIU6rt6+F99BMY8pQ6w4FhmSFPqX+m8JQ6Q55SZ8hT6gx5Spmh99FPYMhT6gx5Sp0hT6kzHBiWGfKUOkOeUmfIU+oMeUqdIU8pty/vo5/AkKfUGfKUOkOeUv5M8T76CQx5Sp0hT6kz5Cl1hjylzpCnlBl6H/0EhjylzpCn1BnylDrDgWGZIU+pM+QpdYY8pdy+vI9+AkOeUmboffT1vx96H/0EhjylzpCn1BkODMsMeUqdIU+pf7fhKXWGPKXOkKeU/37offQTGPKUOkOeUmfIU+oMB4Zlhjyl/N3G++gnMOQpdYY8pc6Qp5Q/U7yPfgJDnlJnyFPqDHlKneHAsMyQp9QZ8pQ6Q55SZ8hT6gx5Spmh99H/Cwxv9+cPv/3Hx0eGPOVrhvt1fzLcf/ql/8gPH9GNbX9Hdz59BE5qwsAZUBj4ADwLnFuFgROxMHDWFgZO8cLA+WAW+J08hoEzzTBwphkGzjTDwAfgWeBMMwycaYaBM80wcKYZBs40s8AfTDMMnGmGgTPNMHCmGQY+AM8CZ5ph4EwzDJxphoEzzTBwppkEvp9OTDMMnGmGgTPNMHCmGQY+AM8CZ5ph4EwzDJxphoEzzTBwppkFvjHNMHCmGQbONMPAmWYY+AA8C5xphoEzzTBwphkGzjTDwJlmFvjONIt/KO4bQ/JYZ8gH6wwpXp3hwLD2B8e9MSRidYbcqs6QLtUZMqA6Q1JT/lw+85Q6Q55SZ8hT6gx5Svkz5TwwLDPkKXWGPKXOkKfUGfKUOkOeUmY4eEqdIU+pM+QpdYY8pc5wYFhmyFPqDHlKnSFPKbevwVPqDHlKmeGFp9QZ8pTyZ8qFp9QZ8pQ6w4FhmSFPqTPkKXWGPKXOkKfUGfKUMsMrT6kz5Cl1hjylzpCn1BkODMsMeUq5fV15Sp0hT6kz5Cl1hjyl/Jly4yl1hjylzpCn1BnylDrDgWGZIU+pM+QpdYY8pc6Qp9QZ8pQywztPqTPkKXWGPKXOkKeU29d9YFhmyFPqDHlKnSFPqX+m8JQ6Q55SZvjgKXWGPKXOkKfUGfKUOsOBYZkhT6kz5Cl1hjylzpCn1BnylCrD7cRT6gx5SrV9bSeeUmfIU+oMB4Zlhjyl/pnCU+oMeUqdIU+pM+QpZYYbT6kz5Cl1hjylzpCn1BkODMsMeUqdIU+pM+QpdYY8pc6Qp5Tbl/fRT2DIU+oMeUqdIU8pf6Z4H/0EhjylzpCn1BnylDpDnlJnyFPKDL2PfgJDnlJnyFPqDHlKneHAsMyQp9QZ8pQ6Q55Sbl/eRz+BIU8pM/Q++gkMeUr5M8X76Ccw5Cl1hgPDMkOeUmfIU+oMeUqdIU+pM+QpZYbeRz+BIU+pM+QpdYY8pc5wYFhmyFPK7cv76Ccw5Cl1hjylzpCnlD9TvI9+AkOeUmfIU+oMeUqd4cCwzJCn1BnylDpDnlJnyFPqDHlKmaH30U9gyFPqDHlKnSFPKbcv76OfwJCn1BnylDpDnlL/TOEpdYY8pczQ++gnMOQpdYY8pc6Qp9QZDgzLDHlKnSFPqTPkKXWGPKXOkKeUGXof/QSGPKXcvryPfgJDnlJnODAsM+Qp9c8UnlJnyFPqDHlKnSFPqTLcvY9+AkOeUmfIU+oMeUqd4cCwzJCn1BnylDpDnlJnyFPqDHlKtX3t3kc/gSFPqTPkKXWGPKX8meJ99BMY8pQ6Q55SZ8hT6gx5Sp0hTykz9D76CQx5Sp0hT6kz5Cl1hgPDMkOeUmfIU+oMeUq5fXkf/QSGPKXM0PvoJzDkKeXPFO+jn8CQp9QZDgzLDHlKnSFPqTPkKXWGPKXOkKeUGXof/QSGPKXOkKfUGfKUOsOBYZkhTym3L++jn8CQp9QZ8pQ6Q55S/kzxPvoJDHlKnSFPqTPkKXWGA8MyQ55SZ8hT6gx5Sp0hT6kz5Cllht5HP4EhT6kz5Cl1hjyl3L68j34CQ55SZ8hT6gx5Sv0zhafUGfKUMkPvo5/AkKfUGfKUOkOeUmc4MCwz5Cl1hjylzpCn1BnylDpDnlJm6H30ExjylHL78j76CQx5Sp3hwLDMkKfUP1N4Sp0hT6kz5Cl1hjylzND76Ccw5Cl1hjylzpCn1BkODMsMeUqdIU+pM+QpdYY8pc6Qp1Tb19n76Ccw5Cl1hjylzpCnVD9TzqeBYZkhT6kz5Cl1hjylzpCn1BnylDJD76OfwJCn1BnylDpDnlJnODAsM+QpdYY8pc6Qp5Tbl/fRT2DIU8oMvY9+AkOeUv5M8T76CQx5Sp3hwLDMkKfUGfKUOkOeUmfIU+oMeUqZoffRT2DIU+oMeUqdIU+pMxwYlhnylHL78j76CQx5Sp0hT6kz5CnlzxTvo5/AkKfUGfKUOkOeUmc4MCwz5Cl1hjylzpCn1BnylDpDnlJm6H30ExjylDpDnlJnyFPK7cv76Ccw5Cl1hjylzpCn1D9TeEqdIU8pM/Q++gkMeUqdIU+pM+QpdYYDwzJDnlJnyFPqDHlKnSFPqTPkKWWG3kc/gSFPKbcv76OfwJCn1BkODMsMeUr9M4Wn1BnylDpDnlJnyFPKDL2PfgJDnlJnyFPqDHlKneHAsMyQp9QZ8pQ6Q55SZ8hT6gx5Srl9eR/9BIY8pc6Qp9QZ8pTyZ4r30U9gyFPqDHlKnSFPqTPkKXWGPKXKcHgf/QSGPKXOkKfUGfKUOsOBYZkhT6kz5Cl1hjyl2r6G99FPYMhTygy9j34CQ55S/kzxPvoJDHlKneHAsMyQp9QZ8pQ6Q55SZ8hT6gx5Spmh99FPYMhT6gx5Sp0hT6kzHBiWGfKUcvvyPvoJDHlKnSFPqTPkKeXPFO+jn8CQp9QZ8pQ6Q55SZzgwLDPkKXWGPKXOkKfUGfKUOkOeUmboffQTGPKUOkOeUmfIU8rty/voJzDkKXWGPKXOkKfUP1N4Sp0hTykz9D76CQx5Sp0hT6kz5Cl1hgPDMkOeUmfIU+oMeUqdIU+pM+QpZYbeRz+BIU8pty/vo5/AkKfUGQ4Mywx5Sv0zhafUGfKUOkOeUmfIU8oMvY9+AkOeUmfIU+oMeUqd4cCwzJCn1BnylDpDnlJnyFPqDHlKuX15H/0EhjylzpCn1BnylPJnivfRT2DIU+oMeUqdIU+pM+QpdYY8pczQ++gnMOQpdYY8pc6Qp9QZDgzLDHlKnSFPqTPkKeX25X30ExjylCrDi/fRT2DIU6qfKRfvo5/AkKfUGQ4Mywx5Sp0hT6kz5Cl1hjylzpCnlBl6H/0EhjylzpCn1BnylDrDgWGZIU8pty/vo5/AkKfUGfKUOkOeUv5M8T76CQx5Sp0hT6kz5Cl1hgPDMkOeUmfIU+oMeUqdIU+pM+QpZYbeRz+BIU+pM+QpdYY8pdy+vI9+AkOeUmfIU+p/P+QpdYY8pc6Qp5QZeh/9BIY8pc6Qp5S/23gf/QSGA8MyQ55S//shT6kz5Cl1hjylzpCnlBl6H/0Ehjyl/N3G++gnMOQpdYYDwzJDnlL/TOEpdYY8pc6Qp9QZ8pQyQ++jn8CQp9QZ8pQ6Q55SZzgwLDPkKXWGPOVrhrf784ff/uPjI8M+nrKN8fw19v2rn769M7z/VBG2bf/Vr7yf9ufvvG+nf/jpPyH2EZXfB/F8Oz9/53E6fYl8f//p/frT//Qf/0a8j9Ychfj5fHn+9Pl++0C80cvufx/xsT3eiY/xxU+Py+n94+1yPv8g/qv/iufb+2fhG7rbzz/85zx9/OpbznO/v/+v5/GrefqoW8t5+lhhy3mGeY48Tx+XbTlPH01uOQ8DP/Q83P7Q8wgBR57nvmg1eJyfv8bjun8B/LI9/8KXy49Au51+lXMv44n78hOK7fr4v5EM7osmg0Ns89X/bhbtBd9im0VjwbfYZtjmsNssmgm+xTaLNoJvsc2igeBbbLNoHfgW2yyaBr7DNg9dYOo219PzV76eL19sc78+f/Z+//GPj21vvP+cRhZ42TSP6/Ov+/j5f2J/8P7ws2O/Pv+ptLH/BO6PHPiL/+1u+/t859PPP/zn6HrDgqMLGQuOPoy+3ujSy4KjazoLji4WLTi6CrXg6PLWcqNfT7rZgqMrcguOrsgtOLoit+Dow+jrja7ILTi6Irfg6IrcgqMrcguOrsitN/qmyC04uiK34OiK3IKjK3ILjj6Mvt7oityCoytyC46uyC04uiK34OiK3Hqj74rcgqMrcguOrsgtOLoit+Dow+jrja7ILTi6Irfg6IrcgqMrcguOrsitN/pZkVtwdEVuwdEVuQVHV+QWHH0Yfb3RFbkFR1fkFhxdkVtwdEVuwdEVufVGH4rcgqMrct9j9Ov2hDyuP73d9X1Hka3HjrpZjx2HHVvsqG59kx3fX2w9rrdf7ChY9dhRg+qxo6zUY0elqMWOF/GnxffVi57TY0c9p8eOek6PHYcdW3zP0XN67Kjn9NhRz+mxo57TY0c9p8WOVz2nx456To8d9ZweO+o5PXYcdmyxo57TY0c9p8eOek6PHfWcFs+trnpOix1vek6PHfWcHjvqOS2+59z0nB47Dju22FHP6bGjntNjRz2nx456To8d9ZwWO971nB476jk9dtRzeuyo5/TYcdixxY56To8d9ZwWz63uek6PHfWcHjvqOS12fOg5Lb7nPPScHjvqOT121HN67Djs2GJHPafHjnpOjx31nB476jk9dtRzOux4O+k5PXbUc3rsqOf02FHP6bHjsGOD51a3k57TY0c9p8eOek6PHfWcHt9z9JwWO256To8d9ZweO+o5PXbUc3rsOOzYYkc9p8eOek6PHfWcHjvqOT121HNa7LjrOT121HN67KjntHhutes5PXYcdmyxo57TY0c9p8f3HD2nx456To8d9ZwWO571nB476jk9dtRzeuyo5/TYcdixxY56To8d9ZweO+o5PXbUc3rsqOe02HHoOS2eWw09p8eOek6PHfWcHjsOO7b4nqPn9NhRz+mxo57TY0c9p8eOek6LHS96To8d9ZweO+o5PXbUc3rsOOzYYkc9p8eOek6PHfWcHjvqOS2eW130nBY7XvWcHjvqOT121HNafM+56jk9dhx2bLGjntNjRz2nx456To8d9ZweO+o5LXa86Tk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5LZ5b3fScHjvqOT121HNa7HjXc1p8z7nrOT121HN67Kjn9Nhx2LHFjnpOjx31nB476jk9dtRzeuyo57TY8aHn9NhRz+mxo57TY0c9p8eOw44dnls99JweO+o5PXbUc3rsqOf0+J6j53TY8X7Sc3rsqOf02FHP6bGjntNjx2HHFjvqOT121HN67Kjn9NhRz+mxo57TYsdNz+mxo57TY0c9p8Nzq/um5/TYcdixxY56To8d9Zwe33P0nB476jk9dtRzWuy46zk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5PXbUc3rsqOf02FHPabHjWc9p8dzqrOf02FHP6bGjntNjx2HHFt9z9JweO+o5PXbUc3rsqOf02FHPabHj0HN67Kjn9NhRz+mxo57TY8dhxxY76jk9dtRzeuyo5/TYUc9p8dxq6DktdrzoOT121HN67KjntPiec9Fzeuw47NhiRz2nx456To8d9ZweO+o5PXbUc1rseNVzeuyo5/TYUc/psaOe02PHYccWO+o5PXbUc1o8t7rqOT121HN67KjntNjxpue0+J5z03N67Kjn9NhRz+mx47Bjix31nB476jk9dtRzeuyo5/TYUc9pseNdz+mxo57TY0c9p8eOek6PHYcdOzy3uus5PXbUc3rsqOf02FHP6fE9R89pseNDz+mxo57TY0c9p8eOek6PHYcdW+yo5/TYUc/psaOe02NHPafHjnpOhx0fJz2nx456To8d9ZwOz60eJz2nx47Dji121HN67Kjn9Pieo+f02FHP6bGjntNix03P6bGjntNjRz2nx456To8dhx1b7Kjn9NhRz+mxo57TY0c9p8eOek6LHXc9p8Vzq13P6bGjntNjRz2nx47Dji2+5+g5PXbUc3rsqOf02FHP6bGjntNix7Oe02NHPafHjnpOjx31nB47Dju22FHP6bGjntNjRz2nx456TovnVmc9p8WOQ8/psaOe02NHPafF95yh5/TYcdixxY56To8d9ZweO+o5PXbUc3rsqOe02PGi5/TYUc/psaOe02NHPafHjsOOLXbUc3rsqOe0eG510XN67Kjn9NhRz2mx41XPafE956rn9NhRz+mxo57TY8dhxxY76jk9dtRzeuyo5/TYUc/psaOe02LHm57TY0c9p8eOek6PHfWcHjsOO3Z4bnXTc3rsqOf02FHP6bGjntPje46e02LHu57TY0c9p8eOek6PHfWcHjsOO7bYUc/psaOe02NHPafHjnpOjx31nBY7PvScHjvqOT121HNaPLd66Dk9dhx2bLGjntNjRz2nx/ccPafHjnpOjx31nAY7nk8nPafHjnpOjx31nB476jk9dhx2bLGjntNjRz2nx456To8d9ZweO+o5LXbc9JwGz63edtRzeuyo5/TYUc/pseOwY4vvOXpOjx31nB476jk9dtRzeuyo57TYcddzeuyo5/TYUc/psaOe02PHYccWO+o5PXbUc3rsqOf02FHPafHcatdzWux41nN67Kjn9NhRz2nxPees5/TYcdixxY56To8d9ZweO+o5PXbUc3rsqOe02HHoOT121HN67Kjn9NhRz+mx47Bjix31nB476jktnlsNPafHjnpOjx31nBY7XvScFt9zLnpOjx31nB476jk9dhx2bLGjntNjRz2nx456To8d9ZweO+o5LXa86jk9dtRzeuyo5/TYUc/pseOwY4fnVlc9p8eOek6PHfWcHjvqOT2+5+g5LXa86Tk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5PXbUc3rsqOf02FHPabHjXc/psaOe02NHPafFc6u7ntNjx2HHFjvqOT121HN6fM/Rc3rsqOf02FHPabHjQ8/psaOe02NHPafHjnpOjx2HHVvsqOf02FHP6bGjntNjRz2nx456Tocdt5Oe0+G51XbSc3rsqOf02FHP6bHjsGOL7zl6To8d9ZweO+o5PXbUc3rsqOe02HHTc3rsqOf02FHP6bGjntNjx2HHFjvqOT121HN67Kjn9NhRz2nx3GrTc1rsuOs5PXbUc3rsqOe0+J6z6zk9dhx2bLGjntNjRz2nx456To8d9ZweO+o5LXY86zk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5LZ5bnfWcHjvqOT121HNa7Dj0nBbfc4ae02NHPafHjnpOjx2HHVvsqOf02FHP6bGjntNjRz2nx456TosdL3pOjx31nB476jk9dtRzeuw47NjhudVFz+mxo57TY0c9p8fno57TY0c9p8WOVz2nx456To8d9ZweO+o5LbzjOuzYYkc9p8eOek6Pz0c9p8eOek6PHfWcFjve9JweO+o5PXbUc1p4x03P6bHjsGOLHfWcHjvqOT2+5+g5PXbUc3rsqOe02PGu5/TYUc/psaOe02NHPafHjsOOLXbUc3rsqOf02FHP+R473u7PX/jtPz4+7qjnvGzHbZyf/xvbxuX6xZLXy3spv17O55+X/AXl+/35O5/vjx//BffLr374cr48f/gytp9/+M8b0YrcyBc38tCh3MhXN6JxuZGvbkQ/cyPXy/35w9fb+Hgj2pwb+epGhhtxI4/z+yan+xc/vJ/e/8r7dv38h/fr9flX3q/3L354vF/GeJw/CPhD2HSo3+JQlVuH+vsO9XZ6PBe8nffSoUrTDvVbHKr27lB/36E+Lvtzwcdj++KH9/HEse/XUbpqTwtcdber3k+eb7jqo1z1/d3pzqdr6ao9kXHV/a7aMyRX/deuepzer/ryxV95vzzGe1LbPjzB3E+eTrm+33d904Lu29/JHapD/Q6H6hGZQ/0Wh+oRmUP9fYc67cnDfvKIzKF+i0P1iMyh/r5Dve/vzwfuP93Ru8p7lOX6XnZ9m0dOru911+fRkOt73fV5hOP6ft/1/aUHk6fH+w9v2/njqXre41S/yakOp+pUj3Gq8/7RvM3jIVfd76o9S3LV/a7agydXfZSrnvYPnG6eUrnqflft6Zer/ktXfd7e/0yW86XYKnZPv1zf667P0y/X9/uub55Q7R6UOdRvcagekznUb3Gow6E61N93qNP8fPfcy6F+i0P1KMuh3q6PH5uMr/LoX/lTJr749/F3j5xc3++7vnn/9ujuKZJD/RaH6sGQQ/0Oh3r2DMmh/r5DnfevOZ89bnKo3+JQPW5yqL/vUL/4twLPniG5vtdd33B9ru9l1+dpj+t73fV5hOP6ft/1zfyXnM+e9zjVb3Kqnvg41YOc6rx/gO7s8ZCrbnfVw7MkV93vqj14ctVHuepp/8Dp8JTKVfe7ak+/XPVfu+rXvAZlDIfqUL/DoXqm5lB/36HO+8euhsdvDvVbHKqHbw719x3qqyqZ53Suut9Ve07nqo9y1dMq2cVzOlfd76o9p3PVf+mqZ/5pmBfP01zf667Pcy/X9/uub55QXYZDdajf4VA993Ko3+JQPfdyqL/xUOf5uedeDvVbHKpHWa871Pvp8vyN7/v2D4f65zieyBx3nKsHCwceRx8/8Djy8THG2cYvxlFXDzzOMM5xx1HRDjyOcnTgcdSSA39bUwgOPI5CcNxxbgrBgcdRCA48jkJw4HEUggOPM4xz3HEUggOPoxAceByF4MDjKASH/Idd/hxHITjuOHeF4MDjKAQHHkchOPA4CsHUcW7j+S/E3bfTF+Nc3//snuv+41Hb+e3/3p/TDNMcdRp14LDTaAOHnUYZOOw0usBhp1EFjjrNQxM47DSKwGGn0QMOO40acNhphmmOOo0acNhp1IDDTqMGHHYaNeCw06gBB53mfFIDDjuNGnDYadSAw06jBhx2mmGao06jBhx2GjXgsNOoAYedRg047DRqwFGn2dSAw06jBhx2GjXgsNOoAYedZpjmqNOoAYedRg047DRqwGGnUQMOO40acNRpdjXgsNOoAYedRg047DRqwGGnGaY56jRqwGGnUQMOO40acNhp1IDDTqMGHHWasxpw2GnUgMNOowYcdho14LDTDNMcdRo14LDTqAGHnUYNOOw0asBhp1EDjjrNUAMOO40acNhp1IDDTqMGTJ3m/jg//7pfvvBhvz5fALX/hOKP/2sffnQ8notfttsXP3oaz8XH6fH4+Yf/XHxYfLHFtYvVFpdEVltcaVltcQFntcV1ocUWv8hNqy2uYq22uDi22uKa22qLD4svtrjmttrimttqi2tuqy2uua22uOa22OJXzW21xTW31RbX3FZbXHNbbfFh8cUW19xWW1xzW21xzW21xTW31RbX3BZb/Ka5rba45rba4prbaotrbqstPiy+2OKa22qLa26rLa65rba45rba4prbYovfNbfVFtfcVltcc1ttcc1ttcWHxRdbXHNbbXHNbbXFNbfVFtfcVltcc1ts8Yfmttrimttqi2tuqy2uua22+LD4Yotrbqstrrmttrjmttrimttqi2tuay0+Tprbaotrbqstrrmttrjmttriw+KLLa65rba45rba4prbaotrbt0W36/35+Ln/fL5D+/b9vx99zd+H89DoHMe//w8NjXPeXxyHtKf8/jkPHRC5/HJeYiKzuOT8xjOw3n88/OQK53HJ+ehbTqPT85DCHUen5yHauo8PjkP1dR5/PPz2FVT5/HJeaimzuOT81BNnccn56GaOo9PzmM4D+fxz89DNXUen5yHauo8PjkP1dR5fHIeqqnz+OQ8VFPn8c/P46yaOo9PzkM1dR6fnIdq6jw+OQ/V1Hl8ch7DeTiPf34eqqnz+OQ8VFPn8cl5qKbO45PzUE2dxyfnoZo6j39+HkM1dR6fnIdq2uw8LvvtOcflfLp/XFwIXW1xbXO1xYfFF1tcgVxtcVFxtcV1wtUWl/5WW1zNW2zxi0C32uKa22qLa26rLa65rbb4sPhii2tuqy2uua22uOa22uKa22qLa26LLX7V3FZbXHNbbXHNbbXFNbfVFh8WX2xxzW21xTW31RbX3FZbXHNbbXHNbbHFb5rbaotrbqstrrmttrjmttriw+KLLa65rba45rba4prbaotrbqstrrkttvhdc1ttcc1ttcU1t9UW19xWW3xYfLHFNbfVFtfcVltcc1ttcc1ttcU1t8UWf2huqy2uua22uOa22uKa22qLD4svtrjmttrimttqi2tuqy2uua22uOa21uKXk+a22uKa22qLa26rLa65rbb4sPhii2tu3RZ/+z/vv+59/7i45rba4prbaotrbqstrrkttvimua22uOa22uKa22qLa26rLT4svtjimttqi2tuqy2uua22uOa22uKa22KL75rbaotrbqstrrmttrjmttriw+KLLa65rba45rba4prbaotrbqstrrkttvhZc1ttcc1ttcU1t9UW19xWW3xYfLHFNbfVFtfcVltcc1ttcc1ttcU1t8UWH5rbaotrbqstrrmttrjmttriw+KLLa65rba45rba4prbaotrbqstrrkttvhFc1ttcc1ttcU1t9UW19xWW3xYfLHFNbfVFtfcVltcc1ttcc1ttcU1t8UWv2puqy2uua22uOa22uKa22qLD4svtrjmttrimttqi2tuqy2uua22uObWbPHrvj9/3et+v35Y/Ka5rba45rba4prbaotrbqstPiy+2OKa22qLa26rLa65rba45rba4prbYovfNbfVFtfcVltcc1ttcc1ttcWHxRdbXHNbbXHNbbXFNbfVFtfcVltcc1ts8Yfmttrimttqi2tuqy2uua22+LD4Yotrbqstrrmttrjmttrimttqi2tuay1+PWluqy2uua22uOa22uKa22qLD4svtrjmttrimttqi2tuqy2uua22uOa22OKb5tZt8cvpOcf1st8+Lq65rba45rba4prbaosPiy+2uOa22uKa22qLa26rLa65rba45rbY4rvmttrimttqi2tu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IBKmA/n0QPROB/LpgYijDuSzA7koqQ7k0wNRUh3IpweipDqQTw9ESXUgnx7IcCAO5LMDUVIdyKcHoqQ6kE8PREl1IJ8eiJLqQD49ECXVgXx2IFcl1YF8eiBKqgP59ECUVAfy6YEoqQ7k0wMZDsSBfHYgSqoD+fRAlFQH8umBKKkO5NMDUVIdyKcHoqQ6kM8O5KakOpBPD0RJdSCfHoiS6kA+PRAltd2B/PHF4fmz59P94+bD5sttrneut7mEud7mquR6mwuN622uHS63+V0OXG9zhW+9zUW79TbX4dbbfNh8uc11uPU21+HW21yHW29zHW69zXW45TZ/6HDrba7Drbe5Drfe5jrcepsPmy+3uQ633uY63Hqb63Drba7Drbe5Drfa5ueTDrfe5jrcepvrcOttrsOtt/mw+XKb63Drba7Drbe5Drfe5jrcepvrcMttvulw622uw623uQ633uY63HqbD5svt7kOt97mOtx6m+tw622uw623uQ633Oa7Drfe5jrcepvrcOttrsOtt/mw+XKb63Drba7Drbe5Drfe5jrcepvrcMttftbh1ttch1tvcx1uvc11uPU2HzZfbnMdbr3Ndbj1Ntfh+m3+9n/ef937/nFzHW69zXW45TYfOtx6m+tw622uw623uQ633ubD5sttrsOtt7kOt97mOtx6m+tw622uwy23+UWHW29zHW69zXW49TbX4dbbfNh8uc11uPU21+HW21yHW29zHW69zXW45Ta/6nDrba7Drbe5Drfe5jrcepsPmy+3uQ633uY63Hqb63Drba7Drbe5Drfc5jcdbr3Ndbj1Ntfh1ttch1tv82Hz5TbX4dbbXIdbb3Mdbr3Ndbj1Ntfhltv8rsOtt7kOt97mOtx6m+tw620+bL7c5jrcepvrcOttrsOtt7kOt97mOtxymz90uPU21+HW21yHW29zHW69zYfNl9tch1tvcx1uvc11uPU21+HW21yHW23zcdLh1ttch2u3+XXfn7/udb9fP26uw623uQ633ubD5sttrsOtt7kOt97mOtx6m+tw622uwy23+abDrbe5Drfe5jrcepvrcOttPmy+3OY63Hqb63Drba7Drbe5Drfe5jrccpvvOtx6m+tw622uw623uQ633ubD5sttrsOtt7kOt97mOtx6m+tw622uwy23+VmHW29zHW69zXW49TbX4dbbfNh8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nz5b6j59ttR92mx51336bKn79NlS9+mzpe7TZ8thyzZb6j59ttR9+myp+/TZUvdp88zrrvu02fKh+/TZUvfps6Xu0+a7z0P36bPlsGWbLXWfPlvqPn221H36bKn79NlS9+my5TjpPn221H36bKn79NlS9+mz5bBlmy11nz5b6j5dnnmNk+7TZ0vdp8+Wuk+bLTfdp813n0336bOl7tNnS92nz5bDlm221H36bKn79NlS9+mzpe7TZ0vdp82Wu+7TZ0vdp8+Wuk+fLXWfPlsOW3Z55rXrPn221H36bKn79NlS9+nz3Uf3abPlWffps6Xu02dL3afPlrpPny2HLdtsqfv02VL36bOl7tNnS92nz5a6T5sth+7TZ0vdp8+Wuk+bZ15D9+mz5bBlmy11nz5b6j59vvvoPn221H36bKn7tNnyovv02VL36bOl7tNnS92nz5bDlm221H36bKn79NlS9+mzpe7TZ0vdp82WV92nzTOvq+7TZ0vdp8+Wuk+fLYct23z30X36bKn79NlS9+mzpe7TZ0vdp82WN92nz5a6T58tdZ8+W+o+fbYctmyzpe7TZ0vdp8+Wuk+fLXWfNs+8brpPmy3vuk+fLXWfPlvqPm2++9x1nz5bDlu22VL36bOl7tNnS92nz5a6T58tdZ82Wz50nz5b6j59ttR9+myp+/TZctiyzZa6T58tdZ82z7weuk+fLXWfPlvqPl22vJx0ny7ffS4n3afPlrpPny11nz5bDlu22VL36bOl7tNnS92nz5a6T58tdZ82W266T58tdZ8+W+o+fbbUffpsOWzZ5ZnXpvv02VL36bOl7tNnS92nz3cf3afNlrvu02dL3afPlrpPny11nz5bDlu22VL36bOl7tNnS92nz5a6T58tdZ82W551nz5b6j59ttR92jzzOus+fbYctmyzpe7TZ0vdp893H92nz5a6T58tdZ82Ww7dp8+Wuk+fLXWfPlvqPn22HLZss6Xu02dL3afPlrpPny11nz5b6j5ttrzoPm2eeV10nz5b6j59ttR9+mw5bNnmu4/u02dL3afPlrpPny11nz5b6j5ttrzqPn221H36bKn79NlS9+mz5bBlmy11nz5b6j59ttR9+myp+7R55nXVfdpsedN9+myp+/TZUvdp893npvv02XLYss2Wuk+fLXWfPlvqPn221H36bKn7tNnyrvv02VL36bOl7tNnS92nz5bDlm221H36bKn7tHnmddd9+myp+/TZUvdps+VD92nz3eeh+/TZUvfps6Xu02fLYcs2W+o+fbbUffpsqfv02VL36bOl7tNly+tJ9+mzpe7TZ0vdp8+Wuk+fLYctmzzzup50nz5b6j59ttR9+myp+/T57qP7tNly0336bKn79NlS9+mzpe7TZ8thyzZb6j59ttR9+myp+/TZUvfps6Xu02bLXffps6Xu02dL3afNM69d9+mz5bBlmy11nz5b6j59vvvoPn221H36bKn7tNnyrPv02VL36bOl7tNnS92nz5bDlm221H36bKn79NlS9+mzpe7TZ0vdp82WQ/dp88xr6D59ttR9+myp+/TZctiyzXcf3afPlrpPny11nz5b6j59ttR92mx50X36bKn79NlS9+mzpe7TZ8thyzZb6j59ttR9+myp+/TZUvdp88zrovu02fKq+/TZUvfps6Xu0+a7z1X36bPlsGWbLXWfPlvqPn221H36bKn79NlS92mz5U336bOl7tNnS92nz5a6T58thy3bbKn79NlS92nzzOum+/TZUvfps6Xu02bLu+7T5rvPXffps6Xu02dL3afPlsOWbbbUffpsqfv02VL36bOl7tNnS92nzZYP3afPlrpPny11nz5b6j59thy27PLM66H79NlS9+mzpe7TZ0vdp893H92ny5a3k+7TZ0vdp8+Wuk+fLXWfPlsOW7bZUvfps6Xu02dL3afPlrpPny11nzZbbrpPny11nz5b6j5dnnndNt2nz5bDlm221H36bKn79Pnuo/v02VL36bOl7tNmy1336bOl7tNnS92nz5a6T58thy3bbKn79NlS9+mzpe7TZ0vdp8+Wuk+bLc+6T5tnXmfdp8+Wuk+fLXWfPlsOW7b57qP79NlS9+mzpe7TZ0vdp8+Wuk+bLYfu02dL3afPlrpPny11nz5bDlu22VL36bOl7tNnS92nz5a6T5tnXkP3abPlRffps6Xu02dL3afNd5+L7tNny2HLNlvqPn221H36bKn79NlS9+mzpe7TZsur7tNnS92nz5a6T58tdZ8+Ww5bttlS9+mzpe7T5pnXVffps6Xu02dL3afNljfdp813n5vu02dL3afPlrpPny2HLdtsqfv02VL36bOl7tNnS92nz5a6T5st77pPny11nz5b6j59ttR9+mw5bNnlmddd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1K7SbaldpdtSu0q3o/arSreldpVuS+0q3ZbaVbottS/ad9Su0m2pXaXbUrtKt6V2lW5L7SrdjtqXSreldpVuS+0q3ZbaVbottS/ad9Su0m2pXaXbUrtKt6V2lW5L7SrdjtpvKt2W2lW6LbWrdFtqV+m21L5o31G7SreldpVuS+0q3ZbaVbottat0O2q/q3RbalfpttSu0m2pXaXbUvuifUftKt2W2lW6LbWrdFtqV+m21K7S7aj9odJtqV2l21K7SreldpVuS+2L9h21q3SJ2p+351v78/n6RLtKt6V2lW5L7SpdovbX6f1TuL+u119/+Hk9v38Oz+v19cWH11vf83795JzUP+d03Dk9VUXndOA5qZXO6cBzUkGd04HnpK46pwPPaTkn53TcOanBzunAc1KZndOB56ReO6cDz0kVd04HnpMq7pyOO6eXKu6cDjwnVdw5HXhOqrhzOvCcVHHndOA5LefknI47J1XcOR14Tqq4czrwnFRx53TgOanizunAc1LFndNh53Q9qeLO6cBzUsWd04HnpIo7pwPPSRV3Tgee03JOzum4c1LFndOB56SKO6cDz0kVd04HnpMq7pwOPCdV3Dkdd05nVdw5HXhOqrhzOvCcVHHndOA5qeLO6cBzWs7JOR13Tqq4czrwnFRx53TgOanizunAc1LFndOB56SKO6fjzumiijunA89JFXdOB56TKu6cDjwnVdw5HXhOyzk5p+POSRV3TgeekyrunA48J1XcOR14Tqq4czrwnFRx53TcOV1Vced04Dmp4s7pwHNSxZ3TgeekijunA89pOSfndNw5qeLO6cBzUsWd04HnpIo7pwPPSRV3TgeekyrunI47p6WKO6cDz0kVd04HnpMq7pwOPCdV3DkdeE7LOTmn485JFXdOB56TKu6cDjwnVdw5HXhOqrhzOvCcVHHndNw53VRx53TgOanizunAc1LFndOB56SKO6cDz2k5J+d03Dmp4s7pwHNSxZ3TgeekijunA89JFXdOB56TKu6cjjunuyrunA48J1XcOR14Tqq4czrwnFRx53TgOS3n5JyOOydV3DkdeE6quHM68JxUced04Dmp4s7pwHNSxZ3Tcef0UMWd04HnpIo7pwPPSRV3TgeekyrunA48p+WcnNNx56SKO6cDz0kVd04HnpMq7pwOPCdV3DkdeE6quHM67pyeqrhzOvCc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",
  "file_map": {
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
    },
    "24": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "25": {
      "path": "std/field/bn254.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "26": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"
    },
    "29": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"
    },
    "34": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "35": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"
    },
    "58": {
      "path": "std/option.nr",
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "59": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "65": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "68": {
      "path": "std/uint128.nr",
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"
    },
    "70": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/NewAddressNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: u32 = 3;\n// CARD_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: u32 = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\n#[derive(Deserialize)]\nstruct NewAddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let header = NoteHeader::empty();\n        NewAddressNote { address, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//serialize is a macro now?\n// impl Serialize<3> for NewAddressNote {\n//     fn serialize(self) -> [Field; 3] {\n//         [self.address.to_field(), self.shared_secret, self.npk_m_hash.to_field()]\n//     }\n// }\n\n"
    },
    "71": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/StringNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n//going to make the max length 10 characters just to keep it simple\n//pretty sure the only thing that this changes is the amount of compute needed\nglobal STRING_NOTE_LENGTH: Field = 3;\nglobal STRING_NOTE_BYTES_LENGTH: Field = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n"
    },
    "80": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PrivateGroups {\n\n    use dep::aztec::{prelude::{Map, AztecAddress, PrivateImmutable, PrivateSet}};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use value_note::{balance_utils, utils::{increment, decrement}, value_note::ValueNote};\n    use std::hash::pedersen_hash;\n    use aztec::context::inputs::private_context_inputs::PrivateContextInputs;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    //Storage for the contract, we have an admin that creates the group, they add members to the group, and they can add notes to the group\n    //The reason there is a credit and a debt is for note tracking.\n\n    #[storage]\n   struct Storage<Context> {\n        admin: PrivateImmutable<NewAddressNote, Context>,\n        group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        group_balances_credit: Map<Field, PrivateSet<ValueNote,Context>, Context>,\n        group_balances_debt: Map<Field, PrivateSet<ValueNote, Context>, Context>,\n   }\n\n    //The Constructor\n    // - Admin creates the group\n    // - Admin adds members to the group\n    // - Each group member is added to a private set of members so that they can see all of the members\n    // - This is very expensive, highlights some of the inefficiencies of the current system\n    // - Since the 0.57 update, this cannot compile, it uses too much memory. I have to get rid of the group member logic which doesnt allow for access gating\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 3]) {\n        //setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let mut admin_address_note = NewAddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n        // this is for adding members to the private set, so they can see the other members, going to be expensive\n        for i in 0..3 {\n            let member = group_members[i as u32];\n            if (member != ZERO_ADDRESS) {\n                let member_keys = get_public_keys(member);\n                for i in 0..3 {\n                    let member_add = group_members[i as u32];\n                    let mut memberNote = NewAddressNote::new(member_add, member_keys.npk_m.hash());\n                    storage.group_members.at(member).insert(&mut memberNote).emit(\n                        encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, member_keys.ivpk_m, member)\n                    );\n                }\n            }\n        }\n    }\n\n    //need to constrain this so that only group members can read this \n    #[private]\n    fn get_admin() -> pub AztecAddress {\n        let admin_note = storage.admin.get_note();\n        admin_note.address\n    }\n\n    //For each group member, we have a private set of members so that they can see all of the members\n    #[private]\n    fn get_group_members(member: AztecAddress) -> [AztecAddress; 3] {\n        let mut options = NoteGetterOptions::new();\n        let member_note = storage.group_members.at(member).get_notes(options);\n        let mut member_array : [AztecAddress; 3] = [ZERO_ADDRESS; 3];\n        //if you call this and u are not part of the group, it will return the zero address\n        for i in 0..3 {\n            let note = member_note.get_unchecked(i);\n            let address: AztecAddress = note.address;\n            member_array[i] = address;\n        }\n        member_array\n    }\n\n    //Setting the balance for the creditor and debtor\n    #[private]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        //TODO:: add assertions here to make sure that the creditor and debtor are part of the group\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, amount, debtor, creditor);\n    }\n\n    //can have a timestamp here for when the payment is made. \n    #[private]\n    fn make_payment(debtor: AztecAddress, creditor: AztecAddress, amount: Field) {\n        //do not do any assertions for now\n        //reason it does a increment with a negative amount is because decrement would not work.\n        //it always failed an assertion. \n        let new_amount = amount * -1;\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, new_amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, new_amount, debtor, creditor);\n    }\n\n    #[private]\n    fn setup_group_payments(creditor: AztecAddress, debtors: [AztecAddress; 2], amount: Field) {\n        //can be called by anyone\n\n        //increase the credit for the creditor with each member\n        let shared_amount : u32 = amount as u32 / (debtors.len() + 1);\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n            let loc_credit = storage.group_balances_credit.at(key);\n            increment(loc_credit, shared_amount.to_field(), creditor, debtor);\n        }\n        //increase the debt for each member with the creditor\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n            let loc_debt = storage.group_balances_debt.at(key);\n            increment(loc_debt, shared_amount.to_field(), debtor, creditor);\n        }\n    }\n\n    #[private]\n    fn read_balance_credit(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //for this function i need to also get the notes that the debtor has sent if they have sent any\n        //if they have sent new notes, i need to nullify the old ones that i have sent to the debtor\n        //make a new one with the new outstanding balance\n        //tricky part is listening for new notes that the debtor has sent, updating the balance\n\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                let note = balance_notes_credit.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_balance_debt(debtor: AztecAddress, creditor: AztecAddress) -> u64 {\n        let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_total_balance(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //going to have to hand type this, could not call the other private functions\n\n        //keys to check in storage\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n\n        //options for the notes \n        let options_1 = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options_1);\n\n        let options_2 = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options_2);\n\n        //sum the notes\n        let mut total_balance_credit = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                // let note = balance_notes_credit.get_unchecked(i);\n                let note = balance_notes_credit.get(i);\n                total_balance_credit += note.value;\n            }\n        }\n\n        //sum the notes\n        let mut total_balance_debt = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get(i);\n                total_balance_debt += note.value;\n            }\n        }\n\n        //convert the note to integer\n\n        let total_debt = U128::from_integer(total_balance_debt);\n        let total_credit = U128::from_integer(total_balance_credit);\n        let tot_debt: i64 = total_debt.to_integer();\n        let tot_credit: i64 = total_credit.to_integer();\n        let total_balance = tot_credit - tot_debt;\n        total_balance as u64\n        // let total_balance = total_credit - total_debt;\n        // total_balance\n    }\n\n    // #[private]\n    // fn read_total_balance_2(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n\n    //     let total_balance_credit = read_balance_credit(&mut context, creditor, debtor);\n    //     let total_balance_debt = read_balance_debt(&mut context, debtor, creditor);\n    //     let total_balance = total_balance_credit - total_balance_debt;\n\n    //     total_balance    \n    // }\n\n    unconstrained pub(crate) fn admin() -> pub AztecAddress {\n        let admin_note: NewAddressNote = storage.admin.view_note();\n        admin_note.address\n    }\n}\n\n//TODO:: add the token transfer, have tests for that too. \n//add block time to storage for notes being paid\n"
    },
    "82": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/address-note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "88": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "89": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "91": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"
    },
    "94": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "103": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "105": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "110": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"
    },
    "112": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext}};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"
    },
    "125": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "126": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "128": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "129": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"
    },
    "130": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "131": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "135": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"
    },
    "139": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"
    },
    "143": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr",
      "source": "// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"
    },
    "147": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"
    },
    "165": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"
    },
    "166": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "169": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "171": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"
    },
    "179": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "186": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "232": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"
    },
    "310": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "311": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "317": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    public_keys::PublicKeys, contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys : PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11]\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize(\n                [\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15]\n            ]\n            )\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"
    },
    "318": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n    partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n    salted_initialization_hash::SaltedInitializationHash\n},\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(contract_class_id, salted_initialization_hash);\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "320": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "321": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "325": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "327": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(_vk: VerificationKey<N>) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "328": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "358": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/utils.nr",
      "source": "use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(\n        encode_and_encrypt_note(\n            balance.context,\n            outgoing_viewer_ovpk_m,\n            recipient_keys.ivpk_m,\n            recipient\n        )\n    );\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n"
    },
    "359": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "decompose_hint",
    "get_public_keys_and_partial_address",
    "random",
    "notify_created_note_oracle_wrapper",
    "get_key_validation_request",
    "lt_32_hint",
    "lte_16_hint",
    "build_msg_block_iter",
    "pad_msg_block",
    "attach_len_to_msg_block",
    "build_msg_block_iter",
    "emit_encrypted_note_log_oracle_wrapper",
    "directive_invert",
    "directive_integer_quotient"
  ]
}