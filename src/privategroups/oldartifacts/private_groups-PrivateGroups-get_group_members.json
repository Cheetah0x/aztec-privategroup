{
  "noir_version": "0.35.0+df29d315d6b71131ffe0180c97130395edb2e4ba-aarch64",
  "hash": 0,
  "abi": {
    "error_types": {
      "16137133351287663689": {
        "error_kind": "fmtstring",
        "item_types": [],
        "length": 17
      }
    },
    "parameters": [
      {
        "name": "inputs",
        "type": {
          "fields": [
            {
              "name": "call_context",
              "type": {
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::function_selector::FunctionSelector"
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::call_context::CallContext"
              }
            },
            {
              "name": "historical_header",
              "type": {
                "fields": [
                  {
                    "name": "last_archive",
                    "type": {
                      "fields": [
                        {
                          "name": "root",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "next_available_leaf_index",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                    }
                  },
                  {
                    "name": "content_commitment",
                    "type": {
                      "fields": [
                        {
                          "name": "num_txs",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "txs_effects_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "in_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "out_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::content_commitment::ContentCommitment"
                    }
                  },
                  {
                    "name": "state",
                    "type": {
                      "fields": [
                        {
                          "name": "l1_to_l2_message_tree",
                          "type": {
                            "fields": [
                              {
                                "name": "root",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "next_available_leaf_index",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                          }
                        },
                        {
                          "name": "partial",
                          "type": {
                            "fields": [
                              {
                                "name": "note_hash_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "nullifier_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              },
                              {
                                "name": "public_data_tree",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::partial_state_reference::PartialStateReference"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::state_reference::StateReference"
                    }
                  },
                  {
                    "name": "global_variables",
                    "type": {
                      "fields": [
                        {
                          "name": "chain_id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "version",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "block_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "slot_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "timestamp",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        },
                        {
                          "name": "coinbase",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::eth_address::EthAddress"
                          }
                        },
                        {
                          "name": "fee_recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "gas_fees",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::global_variables::GlobalVariables"
                    }
                  },
                  {
                    "name": "total_fees",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::header::Header"
              }
            },
            {
              "name": "tx_context",
              "type": {
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "version",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "gas_settings",
                    "type": {
                      "fields": [
                        {
                          "name": "gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "teardown_gas_limits",
                          "type": {
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas"
                          }
                        },
                        {
                          "name": "max_fees_per_gas",
                          "type": {
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees"
                          }
                        },
                        {
                          "name": "inclusion_fee",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::gas_settings::GasSettings"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::transaction::tx_context::TxContext"
              }
            },
            {
              "name": "start_side_effect_counter",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
        },
        "visibility": "private"
      },
      {
        "name": "member",
        "type": {
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "fields": [
          {
            "name": "call_context",
            "type": {
              "fields": [
                {
                  "name": "msg_sender",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "storage_contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "function_selector",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::function_selector::FunctionSelector"
                  }
                },
                {
                  "name": "is_delegate_call",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "is_static_call",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::call_context::CallContext"
            }
          },
          {
            "name": "args_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "returns_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "min_revertible_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "is_fee_payer",
            "type": {
              "kind": "boolean"
            }
          },
          {
            "name": "max_block_number",
            "type": {
              "fields": [
                {
                  "name": "_opt",
                  "type": {
                    "fields": [
                      {
                        "name": "_is_some",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "_value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::option::Option"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::max_block_number::MaxBlockNumber"
            }
          },
          {
            "name": "note_hash_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "nullifier_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest"
              }
            }
          },
          {
            "name": "key_validation_requests_and_generators",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "request",
                    "type": {
                      "fields": [
                        {
                          "name": "pk_m",
                          "type": {
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                          }
                        },
                        {
                          "name": "sk_app",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                    }
                  },
                  {
                    "name": "sk_app_generator",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
              }
            }
          },
          {
            "name": "note_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::note_hash::NoteHash"
              }
            }
          },
          {
            "name": "nullifiers",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::nullifier::Nullifier"
              }
            }
          },
          {
            "name": "private_call_requests",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "returns_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "start_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::private_call_request::PrivateCallRequest"
              }
            }
          },
          {
            "name": "public_call_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext"
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::public_call_request::PublicCallRequest"
              }
            }
          },
          {
            "name": "public_teardown_call_request",
            "type": {
              "fields": [
                {
                  "name": "contract_address",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "args_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::abis::public_call_request::PublicCallRequest"
            }
          },
          {
            "name": "l2_to_l1_msgs",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
              }
            }
          },
          {
            "name": "start_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "end_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "note_encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "note_hash_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::NoteLogHash"
              }
            }
          },
          {
            "name": "encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::EncryptedLogHash"
              }
            }
          },
          {
            "name": "unencrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::LogHash"
              }
            }
          },
          {
            "name": "historical_header",
            "type": {
              "fields": [
                {
                  "name": "last_archive",
                  "type": {
                    "fields": [
                      {
                        "name": "root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "next_available_leaf_index",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                  }
                },
                {
                  "name": "content_commitment",
                  "type": {
                    "fields": [
                      {
                        "name": "num_txs",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "txs_effects_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "in_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "out_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::content_commitment::ContentCommitment"
                  }
                },
                {
                  "name": "state",
                  "type": {
                    "fields": [
                      {
                        "name": "l1_to_l2_message_tree",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "partial",
                        "type": {
                          "fields": [
                            {
                              "name": "note_hash_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "nullifier_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "public_data_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::partial_state_reference::PartialStateReference"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::state_reference::StateReference"
                  }
                },
                {
                  "name": "global_variables",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "block_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "slot_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "timestamp",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 64
                        }
                      },
                      {
                        "name": "coinbase",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "fee_recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "gas_fees",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::global_variables::GlobalVariables"
                  }
                },
                {
                  "name": "total_fees",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::header::Header"
            }
          },
          {
            "name": "tx_context",
            "type": {
              "fields": [
                {
                  "name": "chain_id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "version",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "gas_settings",
                  "type": {
                    "fields": [
                      {
                        "name": "gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "teardown_gas_limits",
                        "type": {
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas"
                        }
                      },
                      {
                        "name": "max_fees_per_gas",
                        "type": {
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees"
                        }
                      },
                      {
                        "name": "inclusion_fee",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "protocol_types::abis::gas_settings::GasSettings"
                  }
                }
              ],
              "kind": "struct",
              "path": "protocol_types::transaction::tx_context::TxContext"
            }
          }
        ],
        "kind": "struct",
        "path": "protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
      },
      "visibility": "databus"
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
    },
    "24": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "25": {
      "path": "std/field/bn254.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "26": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"
    },
    "29": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"
    },
    "34": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "35": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"
    },
    "58": {
      "path": "std/option.nr",
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "59": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "65": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "68": {
      "path": "std/uint128.nr",
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"
    },
    "70": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/NewAddressNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: u32 = 3;\n// CARD_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal ADDRESS_NOTE_BYTES_LEN: u32 = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\n#[derive(Deserialize)]\nstruct NewAddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let header = NoteHeader::empty();\n        NewAddressNote { address, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//serialize is a macro now?\n// impl Serialize<3> for NewAddressNote {\n//     fn serialize(self) -> [Field; 3] {\n//         [self.address.to_field(), self.shared_secret, self.npk_m_hash.to_field()]\n//     }\n// }\n\n"
    },
    "71": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/types/StringNote.nr",
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n//going to make the max length 10 characters just to keep it simple\n//pretty sure the only thing that this changes is the amount of compute needed\nglobal STRING_NOTE_LENGTH: Field = 3;\nglobal STRING_NOTE_BYTES_LENGTH: Field = 3 * 32 + 64;\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n"
    },
    "80": {
      "path": "/Users/niallcheetham/dev/aztec/testing/splitwisePub/privategroups/src/contracts/src/main.nr",
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PrivateGroups {\n\n    use dep::aztec::{prelude::{Map, AztecAddress, PrivateImmutable, PrivateSet}};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use value_note::{balance_utils, utils::{increment, decrement}, value_note::ValueNote};\n    use std::hash::pedersen_hash;\n    use aztec::context::inputs::private_context_inputs::PrivateContextInputs;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    //Storage for the contract, we have an admin that creates the group, they add members to the group, and they can add notes to the group\n    //The reason there is a credit and a debt is for note tracking.\n\n    #[storage]\n   struct Storage<Context> {\n        admin: PrivateImmutable<NewAddressNote, Context>,\n        group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        group_balances_credit: Map<Field, PrivateSet<ValueNote,Context>, Context>,\n        group_balances_debt: Map<Field, PrivateSet<ValueNote, Context>, Context>,\n   }\n\n    //The Constructor\n    // - Admin creates the group\n    // - Admin adds members to the group\n    // - Each group member is added to a private set of members so that they can see all of the members\n    // - This is very expensive, highlights some of the inefficiencies of the current system\n    // - Since the 0.57 update, this cannot compile, it uses too much memory. I have to get rid of the group member logic which doesnt allow for access gating\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 3]) {\n        //setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let mut admin_address_note = NewAddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n        // this is for adding members to the private set, so they can see the other members, going to be expensive\n        for i in 0..3 {\n            let member = group_members[i as u32];\n            if (member != ZERO_ADDRESS) {\n                let member_keys = get_public_keys(member);\n                for i in 0..3 {\n                    let member_add = group_members[i as u32];\n                    let mut memberNote = NewAddressNote::new(member_add, member_keys.npk_m.hash());\n                    storage.group_members.at(member).insert(&mut memberNote).emit(\n                        encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, member_keys.ivpk_m, member)\n                    );\n                }\n            }\n        }\n    }\n\n    //need to constrain this so that only group members can read this \n    #[private]\n    fn get_admin() -> pub AztecAddress {\n        let admin_note = storage.admin.get_note();\n        admin_note.address\n    }\n\n    //For each group member, we have a private set of members so that they can see all of the members\n    #[private]\n    fn get_group_members(member: AztecAddress) -> [AztecAddress; 3] {\n        let mut options = NoteGetterOptions::new();\n        let member_note = storage.group_members.at(member).get_notes(options);\n        let mut member_array : [AztecAddress; 3] = [ZERO_ADDRESS; 3];\n        //if you call this and u are not part of the group, it will return the zero address\n        for i in 0..3 {\n            let note = member_note.get_unchecked(i);\n            let address: AztecAddress = note.address;\n            member_array[i] = address;\n        }\n        member_array\n    }\n\n    //Setting the balance for the creditor and debtor\n    #[private]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n        //TODO:: add assertions here to make sure that the creditor and debtor are part of the group\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, amount, debtor, creditor);\n    }\n\n    //can have a timestamp here for when the payment is made. \n    #[private]\n    fn make_payment(debtor: AztecAddress, creditor: AztecAddress, amount: Field) {\n        //do not do any assertions for now\n        //reason it does a increment with a negative amount is because decrement would not work.\n        //it always failed an assertion. \n        let new_amount = amount * -1;\n\n        //notes for the creditor\n        let key_credit = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, new_amount, creditor, debtor);\n\n        // notes for the debtor\n        let key_debt = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, new_amount, debtor, creditor);\n    }\n\n    #[private]\n    fn setup_group_payments(creditor: AztecAddress, debtors: [AztecAddress; 2], amount: Field) {\n        //can be called by anyone\n\n        //increase the credit for the creditor with each member\n        let shared_amount : u32 = amount as u32 / (debtors.len() + 1);\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n            let loc_credit = storage.group_balances_credit.at(key);\n            increment(loc_credit, shared_amount.to_field(), creditor, debtor);\n        }\n        //increase the debt for each member with the creditor\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n            let loc_debt = storage.group_balances_debt.at(key);\n            increment(loc_debt, shared_amount.to_field(), debtor, creditor);\n        }\n    }\n\n    #[private]\n    fn read_balance_credit(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //for this function i need to also get the notes that the debtor has sent if they have sent any\n        //if they have sent new notes, i need to nullify the old ones that i have sent to the debtor\n        //make a new one with the new outstanding balance\n        //tricky part is listening for new notes that the debtor has sent, updating the balance\n\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                let note = balance_notes_credit.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_balance_debt(debtor: AztecAddress, creditor: AztecAddress) -> u64 {\n        let key = pedersen_hash([debtor.to_field(), creditor.to_field()]);\n        let options = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance as u64\n    }\n\n    #[private]\n    fn read_total_balance(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //going to have to hand type this, could not call the other private functions\n\n        //keys to check in storage\n        let key = pedersen_hash([creditor.to_field(), debtor.to_field()]);\n\n        //options for the notes \n        let options_1 = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options_1);\n\n        let options_2 = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options_2);\n\n        //sum the notes\n        let mut total_balance_credit = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                // let note = balance_notes_credit.get_unchecked(i);\n                let note = balance_notes_credit.get(i);\n                total_balance_credit += note.value;\n            }\n        }\n\n        //sum the notes\n        let mut total_balance_debt = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get(i);\n                total_balance_debt += note.value;\n            }\n        }\n\n        //convert the note to integer\n\n        let total_debt = U128::from_integer(total_balance_debt);\n        let total_credit = U128::from_integer(total_balance_credit);\n        let tot_debt: i64 = total_debt.to_integer();\n        let tot_credit: i64 = total_credit.to_integer();\n        let total_balance = tot_credit - tot_debt;\n        total_balance as u64\n        // let total_balance = total_credit - total_debt;\n        // total_balance\n    }\n\n    // #[private]\n    // fn read_total_balance_2(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n\n    //     let total_balance_credit = read_balance_credit(&mut context, creditor, debtor);\n    //     let total_balance_debt = read_balance_debt(&mut context, debtor, creditor);\n    //     let total_balance = total_balance_credit - total_balance_debt;\n\n    //     total_balance    \n    // }\n\n    unconstrained pub(crate) fn admin() -> pub AztecAddress {\n        let admin_note: NewAddressNote = storage.admin.view_note();\n        admin_note.address\n    }\n}\n\n//TODO:: add the token transfer, have tests for that too. \n//add block time to storage for notes being paid\n"
    },
    "82": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/address-note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "88": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "89": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "91": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"
    },
    "94": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "103": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "105": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "110": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"
    },
    "112": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext}};\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"
    },
    "125": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "126": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "128": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "129": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"
    },
    "130": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "131": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "135": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"
    },
    "139": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"
    },
    "143": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr",
      "source": "// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"
    },
    "147": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"
    },
    "165": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"
    },
    "166": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "169": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "171": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"
    },
    "179": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "186": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "232": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"
    },
    "310": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "311": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "317": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    public_keys::PublicKeys, contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys : PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11]\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize(\n                [\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15]\n            ]\n            )\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"
    },
    "318": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n    partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n    salted_initialization_hash::SaltedInitializationHash\n},\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(contract_class_id, salted_initialization_hash);\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "320": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "321": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "325": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "327": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(_vk: VerificationKey<N>) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "328": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "358": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/utils.nr",
      "source": "use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(\n        encode_and_encrypt_note(\n            balance.context,\n            outgoing_viewer_ovpk_m,\n            recipient_keys.ivpk_m,\n            recipient\n        )\n    );\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n"
    },
    "359": {
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.59.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "get_notes_internal",
    "get_collapse_hints",
    "decompose_hint",
    "pack_returns_oracle_wrapper",
    "directive_invert",
    "directive_integer_quotient"
  ]
}