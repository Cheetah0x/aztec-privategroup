{
  "noir_version": "0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64",
  "hash": 0,
  "abi": {
    "parameters": [
      {
        "name": "inputs",
        "type": {
          "kind": "struct",
          "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
          "fields": [
            {
              "name": "call_context",
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::call_context::CallContext",
                "fields": [
                  {
                    "name": "msg_sender",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress",
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "storage_contract_address",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress",
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "function_selector",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::abis::function_selector::FunctionSelector",
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "is_delegate_call",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "is_static_call",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              }
            },
            {
              "name": "historical_header",
              "type": {
                "kind": "struct",
                "path": "protocol_types::header::Header",
                "fields": [
                  {
                    "name": "last_archive",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                      "fields": [
                        {
                          "name": "root",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "next_available_leaf_index",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "content_commitment",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::content_commitment::ContentCommitment",
                      "fields": [
                        {
                          "name": "num_txs",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "txs_effects_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "in_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "out_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "state",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::state_reference::StateReference",
                      "fields": [
                        {
                          "name": "l1_to_l2_message_tree",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                            "fields": [
                              {
                                "name": "root",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "next_available_leaf_index",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "partial",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::partial_state_reference::PartialStateReference",
                            "fields": [
                              {
                                "name": "note_hash_tree",
                                "type": {
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ]
                                }
                              },
                              {
                                "name": "nullifier_tree",
                                "type": {
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ]
                                }
                              },
                              {
                                "name": "public_data_tree",
                                "type": {
                                  "kind": "struct",
                                  "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                  "fields": [
                                    {
                                      "name": "root",
                                      "type": {
                                        "kind": "field"
                                      }
                                    },
                                    {
                                      "name": "next_available_leaf_index",
                                      "type": {
                                        "kind": "integer",
                                        "sign": "unsigned",
                                        "width": 32
                                      }
                                    }
                                  ]
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "global_variables",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::abis::global_variables::GlobalVariables",
                      "fields": [
                        {
                          "name": "chain_id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "version",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "block_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "slot_number",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "timestamp",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 64
                          }
                        },
                        {
                          "name": "coinbase",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::address::eth_address::EthAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "fee_recipient",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "gas_fees",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees",
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "total_fees",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "tx_context",
              "type": {
                "kind": "struct",
                "path": "protocol_types::transaction::tx_context::TxContext",
                "fields": [
                  {
                    "name": "chain_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "version",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "gas_settings",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::abis::gas_settings::GasSettings",
                      "fields": [
                        {
                          "name": "gas_limits",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas",
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "teardown_gas_limits",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::abis::gas::Gas",
                            "fields": [
                              {
                                "name": "da_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              },
                              {
                                "name": "l2_gas",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "max_fees_per_gas",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::abis::gas_fees::GasFees",
                            "fields": [
                              {
                                "name": "fee_per_da_gas",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "fee_per_l2_gas",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "inclusion_fee",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            },
            {
              "name": "start_side_effect_counter",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "debtor",
        "type": {
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress",
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "creditor",
        "type": {
          "kind": "struct",
          "path": "protocol_types::address::aztec_address::AztecAddress",
          "fields": [
            {
              "name": "inner",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "amount",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "struct",
        "path": "protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
        "fields": [
          {
            "name": "call_context",
            "type": {
              "kind": "struct",
              "path": "protocol_types::abis::call_context::CallContext",
              "fields": [
                {
                  "name": "msg_sender",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "storage_contract_address",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "function_selector",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::abis::function_selector::FunctionSelector",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "is_delegate_call",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "is_static_call",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ]
            }
          },
          {
            "name": "args_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "returns_hash",
            "type": {
              "kind": "field"
            }
          },
          {
            "name": "min_revertible_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "is_fee_payer",
            "type": {
              "kind": "boolean"
            }
          },
          {
            "name": "max_block_number",
            "type": {
              "kind": "struct",
              "path": "protocol_types::abis::max_block_number::MaxBlockNumber",
              "fields": [
                {
                  "name": "_opt",
                  "type": {
                    "kind": "struct",
                    "path": "std::option::Option",
                    "fields": [
                      {
                        "name": "_is_some",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "_value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              ]
            }
          },
          {
            "name": "note_hash_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "nullifier_read_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::read_request::ReadRequest",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "key_validation_requests_and_generators",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                "fields": [
                  {
                    "name": "request",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                      "fields": [
                        {
                          "name": "pk_m",
                          "type": {
                            "kind": "struct",
                            "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                            "fields": [
                              {
                                "name": "x",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "y",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "is_infinite",
                                "type": {
                                  "kind": "boolean"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "sk_app",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "sk_app_generator",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "note_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::note_hash::NoteHash",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "nullifiers",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::nullifier::Nullifier",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "note_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "private_call_requests",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::private_call_request::PrivateCallRequest",
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress",
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext",
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "returns_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "start_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "end_side_effect_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "public_call_requests",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::public_call_request::PublicCallRequest",
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::address::aztec_address::AztecAddress",
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "call_context",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::abis::call_context::CallContext",
                      "fields": [
                        {
                          "name": "msg_sender",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "storage_contract_address",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_delegate_call",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static_call",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "args_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "public_teardown_call_request",
            "type": {
              "kind": "struct",
              "path": "protocol_types::abis::public_call_request::PublicCallRequest",
              "fields": [
                {
                  "name": "contract_address",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": {
                          "kind": "boolean"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "args_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            }
          },
          {
            "name": "l2_to_l1_msgs",
            "type": {
              "kind": "array",
              "length": 2,
              "type": {
                "kind": "struct",
                "path": "protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "kind": "struct",
                      "path": "protocol_types::address::eth_address::EthAddress",
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "name": "content",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "start_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "end_side_effect_counter",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            }
          },
          {
            "name": "note_encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 16,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::NoteLogHash",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "note_hash_counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "encrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::EncryptedLogHash",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "unencrypted_logs_hashes",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "struct",
                "path": "protocol_types::abis::log_hash::LogHash",
                "fields": [
                  {
                    "name": "value",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "counter",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "length",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            }
          },
          {
            "name": "historical_header",
            "type": {
              "kind": "struct",
              "path": "protocol_types::header::Header",
              "fields": [
                {
                  "name": "last_archive",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                    "fields": [
                      {
                        "name": "root",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "next_available_leaf_index",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "content_commitment",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::content_commitment::ContentCommitment",
                    "fields": [
                      {
                        "name": "num_txs",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "txs_effects_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "in_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "out_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "state",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::state_reference::StateReference",
                    "fields": [
                      {
                        "name": "l1_to_l2_message_tree",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "partial",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::partial_state_reference::PartialStateReference",
                          "fields": [
                            {
                              "name": "note_hash_tree",
                              "type": {
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "nullifier_tree",
                              "type": {
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "public_data_tree",
                              "type": {
                                "kind": "struct",
                                "path": "protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "global_variables",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::abis::global_variables::GlobalVariables",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "block_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "slot_number",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "timestamp",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 64
                        }
                      },
                      {
                        "name": "coinbase",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "fee_recipient",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "gas_fees",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees",
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "total_fees",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            }
          },
          {
            "name": "tx_context",
            "type": {
              "kind": "struct",
              "path": "protocol_types::transaction::tx_context::TxContext",
              "fields": [
                {
                  "name": "chain_id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "version",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "gas_settings",
                  "type": {
                    "kind": "struct",
                    "path": "protocol_types::abis::gas_settings::GasSettings",
                    "fields": [
                      {
                        "name": "gas_limits",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas",
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "teardown_gas_limits",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::abis::gas::Gas",
                          "fields": [
                            {
                              "name": "da_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "l2_gas",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "max_fees_per_gas",
                        "type": {
                          "kind": "struct",
                          "path": "protocol_types::abis::gas_fees::GasFees",
                          "fields": [
                            {
                              "name": "fee_per_da_gas",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "fee_per_l2_gas",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "inclusion_fee",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            }
          }
        ]
      },
      "visibility": "public"
    },
    "error_types": {}
  },
  "bytecode": "H4sIAAAAAAAA/+ydC5xV0/v/xzSXZqqZ3O/K/c5Z55yZc8b9fo0QhSgzc+ZEURSiUhRFd10pKkVRKYRSFKIQcg9RCFGURC6R/1rs9XU6Lbqcz2dZ6/+b9Xqt/5zW13//nufzPOvZz/vsffbeKuuv0eX8rKy72vz1eSs5awR/s+Wsn7am/6Z+zjGs5Rn+/9Y2rBUZ1uoa1rYxrO0o53Fpa/UM/119w9qehrW9DGv7BWupY6vg73HB30ioNBqtioWrRESUh8JlFfGSULSkojQu4qIkXpIIxyORqng0HiurKIuFykQ0UiWSJWWRZOivcUb238cKZTTClUw7z9xyO6PpC8q2HYLc0bYqHdYFn/fP+vvzASmfzwz+G/3/r4H891lyni1nw+y/1/WokaZBKLMhDgQeq0E2LjbnwHLIHJtzUmJzVsrns1M+N0yLzbny3+fJ2UjO8w2xyQbHZj9grl+A01Ok1hN13PpkHS4A5lVjkg6Ns/l1tQlwTzDtvHDL7QynL5j2bmr9TK2rTVL27oVpe/ci+e+L5Wwq5yWGvYvW4FJcrMImDS5N8fWi7E3ToJn8d3M5L5OzPNAgN+uvPmarrA1HuiahzIZoBq7pelRkEw1WB0cftxJY0Fh+V2b/LTDouP9adEKZjfU0DWU4ctNsZNp9AO5YoTopdiaC+FUFf5PB3xbB38uDv1cEf1sGf1sFf68M/l4V/G0d/G0T/L06O2t9skhmb0hNVxrW2gRrNitPglR5rskmGnwNofK0dbzyKL/bEiqPzWSrIiVbu2yiwe0IyXat48mm/L6WdJpD95PJYGOg2QpZEK7L9nPDtiBt2OuziQZfT9iw7R3fsMrv9p6fHS4nJdsN2USDbyAk242OJ5vy+0ZPzg5XBBsDfXZAFoQO2VwNQ5mNP7uV67LxsenouN8qxzsQ/O7kaTfQklSgb8omGnwToUB3drxAK787e94NtCIlW5dsosFdCMl2s+PJpvy+2ZNu4MpgY6C7AWRBuMXxs6I6a3cinBW7Ou63yvFbCH5387QbuIpUoG/NJhp8K6FA3+Z4gVZ+3+Z5N9CalGzds4kGdyckWw/Hk0353cOTbqBNsDHQ3QCyINzu+FlRnbW7Ec6Kdzjut8rx2wl+9wT7rQfazl4wOyNRpp29t9zORPqC6W4jpYO+qyiR8rkq5XPv7PXvNuoj/91Xzn5y9s/m38maxOWU6AOsbXeSch2tH/AqmOgL1G+AJ/oBL+yIfkD9BoKbyvTacGdKDRiQ8nlgyuf+abVhkPz3YDmHyDnUQm24AhibQcDY3OVJbgO/ExeDgfrd7Yl+wK95xRCgfsPIteGulBpwd8rnYSmfh6bVhuHy3/fIea+cIyzUhiuBsRkOjM1IT3Ib+A2ZuAeo3yhP9AN+6SPuBep3H7k2jEypAaNSPt+X8nlEWm0YLf89Rs775XzAQm1oA4zNaGBsxpJjMzYlBmNSPt+f8vmBtNiMk/9+UM6H5Byfvf7xUmOC+M6kJ+E7iQnAWGelDLSdE3F2Jk32hTIbQuXBBEJ8HibVc7Sdk7bczkj6gmlvTkzZgw+nfL465fOktL05Wf77ETkflfOxbP4vVw8A6jkZGHebP+zZH3es9X7YMyUI1uPB3yeCv08Gf6cGf6cFf58K/k4P/s4I/j4d/H0m+Dsz+DsrO2v9H+w8kb3hj3imGdZmGNZmZtv/sc8U8MlRj2eziQY/m40/7nPAjoPl93PZfwsMOq7VS7aPk5Lt+Wyiwc8Tkm2248mm/J5NSDaTrZn6/0SwMdCnZWRBeCHbzw37JGnDvphNNPhFwoad4/iGVX7P8fzsMJWUbHOziQbPJSTbS44nm/L7JU/ODtOCjYE+OyALwsvZXA1DmY0/u5UXCF9SvOK43yrHXyb4Pc/TbuApUoF+NZto8KuEAv2a4wVa+f2a593AdFKyvZ5NNPh1QrLNdzzZlN/zPekGZgQbA90NIAvCG46fFdVZex7hrPim436rHH+D4PdbnnYDT5MK9NvZRIPfJhTodxwv0MrvdzzvBp4hJdu72USD3yUk23uOJ5vy+z1PuoGZwcZAdwPIgrDA8bOiOmu/RTgrvu+43yrHFxD8/gBc6P7txylTUj4/nv3PP075UP57oZwfyflxNv9GsidwGogPgXtxETgnWfoBr9qIhUD9FnuiH/BChPgIqN8n5NqwKKUGLE75/EnK54/TasOn8t+fyblEzs8t1IZpwNh8CozNF57kNvA7XPEZUL8vPdEP+LWkWALUbym5NnyRUgO+TPm8NOXz52m14Sv576/lXCbncgu1YQYwNl8BY/ONJ7kN/EZHfA3U71tP9AN+SSGWAfVbQa4N36TUgG9TPq9I+bw8rTaslP/+Ts5Vcn5voTbMBMZmJTA2q8mxWZ0Sg+9SPq9K+fx9Wmx+kP/+Uc41cv6UzftximL8DwgM/TMw1ia/Q5kNofT9meD3L+RcSv0xxS8pn2dl//OPKX6V/14r529y/p7N/zHF/kA9fyXr+U8PB0n+i57r5L//UKLJArlVjb9fS5T6pXbq5+wawX+QnbVp39RnKhrwHXmh7BQ7awRnhJwaaQ7UIDqQ6bGU0Zt4rMqNHEvk1MBeutnUhAhlNsS6bE5C5AaBz9tYQoQyG+s5kGlC5AITIs/ThMiuwUmI/CDwNdkJkV0DlxD5wISo6WlCNCNViIIg8IXshGgGrBAFwIQorIFtYGpl/XXFPytNv0goGi6tKo2WV1VFQlVlZfFKEamMV1ZVVSbKI+WxWDwUS1RUlSdKwhWV4WSkIhmqKq+Kl4iKaEVMhCrFurTjCelvSWl5qDSeLA1FQuFIOBqqLCutiCbKS6KxaGmpPFykIh4TorIkLCpj0XhYhMtFSUVlKBKtKi9dh41vKD3hw/FwSWWsrLKytLyksqKiqioZS5SWx5OiorRchCsi0pjySCQejYbKq5JVFdFIWamIxivjMkKxylC0bAN/ZWiTCaG8q4iFSsOJ0ooSFfiqSGlFWSgWKY2UhJKlyYrykAiH45VR6XI4VFZWEipLlsRCoortb6gqUSGqwmWRykhlVZmoSEonquTH8vKSUCJcWRIVyfKyhExAaZd0NxSpSlaIymR5uLIiEimJJTfwNxIVidJYSbJcRreqsioiAy6zI1JZHolKHSIVoqyitKosVhoORUtjci0q5QtHK6NS5URVpITub1TqHJHBklstJPdcojIeroqXl5SUl5WEE9FEMhwKl5Qmq0JyryXKomVyWcakPBRKhsorkmJD+8rjSpnSUCIk/59kSSIut3G0LBGNJ+XWiSZCMj1CFWXxqkRMxMrLKkoi4fJkaUTujJJIKFYmGP7WDI715w+Qa/wNHDkpn3NTPuelfM5P+Vwz5XNByufC4HMt+be2nHVq/MUhmkfSh8snFYO5GR87kqiKxcOlZX/qvxEtXGIyVrzWZbtvI7JzzfqXeIcyG6KWJ3Y2Ju9R+LdLjYGNXhEuSOu9XF0dt37wOf0bp6dSvlmanvJ5xr9841Qsj1dXzq3l3KYG/xu8YiBdbZuqcWmotLQsGQ3JHjUpQuGQiJaVVcgzbLmoKqkUpWXxRGlVpfy/UxmJl5SVy5N0QnZw5SJeURkpkadqm7e7bgtu3PXYrgbRYHVw9HG3ByYDy+/tU07foOP+id9qo6XiLCvZimtwqzDo2OHUwrNDoPmOwd+dgr87p+QgvI3anlSxdwqMNlXsHVJa6h1TPu9U458r9i7yf9tVzt3k3L3GP1+/C2U2/kyc7Wvgdb61ATYhGXmwC8Hv2xpwNmIO2E5gwRC7AI8FzBtxGzkHQ5kNoU4MjL23B7jz0DVuj6ArZexHrQW6E80G2liPpGu9FF31QH+9DcwJUQ/Y0NUnaVr/X3I1lNkQeVmcfbsnSYs9ifs2j7Rv84A27kXSdS8L+xaYE2Iv4L7dm6Tp3sR9WzuLs2/3IWmxD3Hf1ibt29pAG/cl6bqvhX0LzAmxL3Df7kfSdD/ivi3K4uzb/Ula7E/ct0WkfVsEtPEAkq4HWNi3wJwQBwD37YEkTQ8k7tu6WZx9exBJi4OI+7Yuad/WBdp4MEnXgy3sW2BOiIOB+/YQkqaHEPftNlmcfXsoSYtDift2G9K+3QZo42EkXQ+zsG+BOSEOA+7bw0maHk7ctztmcfZtiKRF6nHRNu9I2rc7Am0UJF1Tj5tF2rfAnBACuG/DJE3D/5KrocyGqJfF2bcRkhYR4vm2Hmnf1gPaGCXpGrVwvgXmhIgC920JSdMS4vm2fhZn35aStCgl7lutBXrf1gfaGCPpGrOwb4E5IWLAfRsnaRon7ts9szj7toykRRlx32ot0Pt2T6CNR5B0PcLCvgXmhDgCuG+PJGl6JHHf7pXF2bdHkbQ4irhv9yLt272ANh5N0vVoC/sWmBPiaOC+PYak6THEfbtfFmffHkvS4ljivt2PtG/3A9p4HEnX4yzsW2BOiOOA+/Z4kqbHE/et+hUaY9+eQNLiBOK+1VrA77sA5tiJJF1PtLBvgTkhTgRqehJJ05MCTW3+IhH5U91Ue0+uQTT45Br4454CTBCW36fU+Ftg0HHXe7AOw27k8xrqB8c5Vepwmpyny3mGnGfK2UDOs+Q8W86Gcp4j57lynidnIznPl/MCORvL2UTOC+W8SM6L5Wwq5yVyXipnMzmby3mZnOVyVshZKWdCzio5k8FuTd24yp6aWeuvnWZYO92wdoZh7UzDWgPD2lmGtbMNaw0Na+cY1s41rJ1nWGtkWDvfsHaBYa2xYa2JYe1Cw9pFhrWLDWtNDWuXGNYuNaw1M6w1N6xdZlgrN6xVGNYqDWsJw1qVYS1Z4+9nvOiR/kPAUGYD+tyrUwF1tSqpRkicBqzRtzv+o0zls4rF6RD9/orrGZkfK6yfQXYmMBZ3uByL6N/PXWuQmc+h1Ge4nZXJscLrPw/ubGAseroZi1D6M/AabqHPpckNn6d3zpYdK256Nt+5wFj0ci0WcfPzCM/bfJ9j//Rsw0abe6zYPz8n8XxgLHq7E4vwvz0b8oLN8Tn278+ZbLzpx9roMyubAGPRx4VYxDZqp7hw03wObYLP4qJNOVZok/QTFwNj0fe/jUXJJtopmm7M5+gm+ywu+ddjRZOboZ+4FBiLfv9VLGKbZado9s8+xzfTZ9H8H45Vltxs/cRlwFj0tx+L0BbYKcpNPoe2yGdRseGxxBbqJyqBsbjTZiwSW2ynSKzvcyQDn0VVyrHCyYz0E0lgLAZYikUosyGA3w8IIN+KVD7LNBYDPYkFkIMEsI8XfYCxGORJLID9ngD2K6I/MBaDPYkF8LwmgHVZDATGYggpFjXAsQDuXwHMP8HSL/2mh0zjjOwxWtRA+RwJ2bwYj7N7/Yvxl9cgGqwOjj7uFcBkYPl9RY2/BQYd989kq5Nl5/HASViyJXiPBxbr36DQMtC8lb4aqv+2DJIwda2V4Uopuuojqpa+utkSmPStwMFlbPCWNfC35LWs4cfZrgoY6ythPpdGbZ7triSd7a6qQTT4KsLZrrXjZzvld2vPz3ZVsGQrqzSYSznbtQk0vzr9bNfGcLa72sLZrgp4tmsDTPqrScFFV32kz9fgqqfxZdiZ2ndFUDSywTmIRIO24G4BXbRUjNsSuiTX/da5g/a7nSfdITLHryXXiVBmQ6iYXEuoE22BGl7nwX65jrBfrgd36LpXuT7FVpYW6Hy6FphP7Um6tq+xIbmha1MCqMMNMB2iVTbJ9QZw/PS4sQbR4BsJ5NrBcXJVfnfwnFwTsGSrCBvMpZBrx0DzTunk2tFArp0skCuiamly7QhM+k6k4KKrPtLnmxzvSNsHRaMGWMP2QA2Rhbez4/FQ+dKZ0N0C/aa8jlDnIbqTReZOF8fJSGnYhaBhZ6CGN3vyrQSyft3ieM1RMbmFUHO6ksivK5GotRboPYTMp24kXbtZIGrkne63wnSIhW0S9a3g+OlxWw2iwbcRiLq740St/O7uOVFXwpItXmUwl0LUPQLNb08n6h4Gor7dAlEjqpYm6h7ApL+dFFx01Uf6fIfj3VS3oGigibobUENk4e3peDxUvvQkdLdAvylErfMQ3ckic6eX40StNOxF0LAnUMPenhA1sn71cbzmqJj0IdScviTy60skaq0Feg8h86kfSdd+Foi6AqhDf5gOVcImUfcHx0+PO2sQDb6TQNQDHCdq5fcAz4m6ApZsImkwl0LUAwPNB6UT9UADUQ+yQNSIqqWJeiAw6QeRgouu+kifBzveTfULigaaqPsBNUQW3iGOx0PlyxBCdwv0m0LUOg/RnSwyd4Y6TtRKw6EEDYcANbzLE6JG1q+7Ha85KiZ3E2rOMBL5DSMStdYCvYeQ+TScpOtwC0RdDtThHpgOEatEfQ84fnrcW4No8L0Eoh7hOFErv0d4TtTlsGSrtEbUIwPNR6UT9UgDUY+yQNSIqqWJeiQw6UeRgouu+kif73O8mxoeFA00UQ8HaogsvKMdj4fKl9GE7hboN4WodR6iO1lk7oxxnKiVhmMIGo4Gani/J0SNrF8POF5zVEweINScsSTyG0skaq0Feg8h82kcSddxFoga+az5B2E6lFt93uWD4Pjp8VANosEPEYh6vONErfwe7zlRXwZLtlJrz7ucEGg+MZ2oJxiIeqIFokZULU3UE4BJP5EUXHTVR/r8sOPd1LigaKCJehxQQ2ThneR4PFS+TCJ0t0C/KUSt8xDdySJzZ7LjRK00nEzQcBJQw0c8IWpk/XrU8ZqjYvIooeY8RiK/x4hErbVA7yFkPk0h6TrFAlE3B+rwOEyHcJlNon4cHD89nqhBNPgJAlE/6ThRK7+f9Jyom8OSLREzmEsh6qmB5tPSiXqqgainWSBqRNXSRD0VmPTTSMFFV32kz0853k1NCYoGmqinADVEFt7pjsdD5ct0QncL9JtC1DoP0Z0sMndmOE7USsMZBA2nAzV82hOiRtavZxyvOSomzxBqzkwS+c0kErXWAr2HkPk0i6TrLAtE3Qyow7MwHSriNon6WXD89HiuBtHg5whE/bzjRK38ft5zom4GS7Zo3GAuhahnB5q/kE7Usw1E/YIFokZULU3Us4FJ/wIpuOiqj/T5Rce7qVlB0UAT9SyghsjCO8fxeKh8mUPoboF+U4ha5yG6k0XmzlzHiVppOJeg4Ryghi95QtTI+vWy4zVHxeRlQs15hUR+rxCJWmuB3kPIfJpH0nWeBaK+FKjDqzAdSqze9f0qOH56vFaDaPBrBKJ+3XGiVn6/7jlRX4r72snaXd/zA83fSCfq+QaifsMCUSOqlibq+cCkf4MUXHTVR/r8puPd1LygaKCJeh5QQ2ThfcvxeKh8eYvQ3QL9phC1zkN0J4vMnbcdJ2ql4dsEDd8CaviOJ0SNrF/vOl5zVEzeJdSc90jk9x6RqLUW6D2EzKcFJF0XWCDqS4A6vI+7QlNik6jfB8dPjw9qEA3+gEDUHzpO1MrvDz0n6ktw0FVhMJdC1AsDzT9KJ+qFBqL+yAJRI6qWJuqFwKT/iBRcdNVH+vyx493UgqBooIl6AVBDZOFd5Hg8VL4sInS3QL8pRK3zEN3JInNnseNErTRcTNBwEVDDTzwhamT9+tTxmqNi8imh5nxGIr/PiESttUDvIWQ+LSHpusQCUTcF6vA5rp8stUnUn4Pjp8cXNYgGf0Eg6i8dJ2rl95eeE3VT3NdO5QZzKUS9NND8q3SiXmog6q8sEDWiammiXgpM+q9IwUVXfaTPXzveTS0JigaaqJcANUQW3mWOx0PlyzJCdwv0m0LUOg/RnSwyd5Y7TtRKw+UEDZcBNfzGE6JG1q9vHa85KibfEmrOChL5rSAStdYCvYeQ+bSSpOtKC0R9MVCH72A6xK2+Pes7cPz0WFWDaPAqAlF/7zhRK7+/95yoL4YlW8za27NWB5r/kE7Uqw1E/YMFokZULU3Uq4FJ/wMpuOiqj/T5R8e7qZVB0UAT9UqghsjCu8bxeKh8WUPoboF+U4ha5yG6k0Xmzk+OE7XS8CeChmuAGv7sCVEj69cvjtccFZNfCDXnVxL5/Uokaq0Feg8h82ktSde1Foj6IqAOv3lK1L+B46fH7zWIBv9OIOp1jhO18nud50R9kYdE/YfWPCdrfXr+w0DU6j9iEzWiammi/gOZ9Dl+EDXS561y3O6m1gZFA03Ua4EaIgtvtuPxUPmibER3t0C/KUSt8xDdySJzpwZZw1Bm48+9rGxEa5iaO5lqmAPWUA/0OQBZv3IdrzkqJrmEmpMHjHVqD5WXwyNqrQV6DyHzKZ+ka34On6gvBOpQE6ZDidVnfdcEx0+PghyiwQU5+OMWAk8sLL8Lc/4WGHRcq0R9IYyoy60967tWoHntdKKulbMhUde2QNQXAom6FjDpa+dwgouu+kif6zjeTeUHRQNN1PlADZGFt8jxeKh8KSJ0t0VgkkHbp/MQ3ckic6fYcaJWGhYTNCwCaljXE6JG1q+tHa85KiZbE2rONiTy24ZI1FoL9B5C5tO2JF23tUDUTYBEvR2OqBM2iXo7cPz02D6HaPD2BKLewXGiVn7v4DlRN8ERdcRgLoWodww03ymdqHc0EPVOFoi6CZCodwQm/U45nOCiqz7S550d76a2DYoGmqi3BWqILLy7OB4PlS+7ELpboN8UotZ5iO5kkbmzq+NErTTclaDhLkANd/OEqJH1a3fHa46Kye6EmrMHifz2IBK11gK9h5D5VI+kaz0LRN0YSNT1YTqErV6jrg+Onx575hAN3pNA1Hs5TtTK7708J+rGMKJOWLtGvXeg+T7pRL23gaj3sUDUjYFEvTcw6ffJ4QQXXfWRPu/reDdVLygaaKKuB9QQWXj3czweKl/2I3S3QL8pRK3zEN3JInNnf8eJWmm4P0HD/YAaHuAJUSPr14GO1xwVkwMJNecgEvkdRCRqrQV6DyHz6WCSrgdbIOoLgER9CEyHSMQmUR8Cjp8eh+YQDT6UQNSHOU7Uyu/DPCfqC2BEXZkwmEsh6sMDzUPpRH24gahDFoj6AiBRHw5M+lAOJ7joqo/0WTjeTR0cFA00UR8M1BBZeMOOx0PlS5jQ3QL9phC1zkN0J4vMnYjjRK00jBA0DAM1jHpC1Mj6VeJ4zVExKSHUnFIS+ZUSiVprgd5DyHyKkXSNWSDq84FEHYfpUGX1GnUcHD89ynKIBpcRiPoIx4la+X2E50R9PoyohbVr1EcGmh+VTtRHGoj6KAtEfT6QqI8EJv1ROZzgoqs+0uejHe+mYkHRQBN1DKghsvAe43g8VL4cQ+hugX5TiFrnIbqTRebOsY4TtdLwWIKGxwA1PM4TokbWr+MdrzkqJscTas4JJPI7gUjUWgv0HkLm04kkXU+0QNSNgER9EkyHqFWiPgkcPz1OziEafDKBqE9xnKiV36d4TtSNYERdYY2oTw00Py2dqE81EPVpFoi6EZCoTwUm/Wk5nOCiqz7S59Md76ZODIoGmqhPBGqILLxnOB4PlS9nELpboN8UotZ5iO5kkblzpuNErTQ8k6DhGUANG3hC1Mj6dZbjNUfF5CxCzTmbRH5nE4laa4HeQ8h8akjStaEFoj4PSNTnwHSIldkk6nPA8dPj3ByiwecSiPo8x4la+X2e50R9Hu4VczGDuRSibhRofn46UTcyEPX5Foj6PCBRNwIm/fk5nODCv0cF+nyB491Uw6BooIm6IVBDZOFt7Hg8VL40JnS3QL8pRK3zEN3JInOnieNErTRsQtCwMVDDCz0hamT9usjxmqNichGh5lxMIr+LiUSttUDvIWQ+NSXp2tQCUZ8LJOpLcFdorBL1JeD46XFpDtHgSwlE3cxxolZ+N/OcqM+FEXXUGlE3DzS/LJ2omxuI+jILRH0ukKibA5P+shxOcNFVH+lzuePdVNOgaKCJuilQQ2ThrXA8HipfKgjdLdBvClHrPER3ssjcqXScqJWGlQQNK4AaJjwhamT9qnK85qiYVBFqTpJEfkkiUWst0HsImU8tSLq2sEDU5wCJ+nLcNeqQTaK+HBw/Pa7IIRp8BYGoWzpO1Mrvlp4T9Tkwoi4LGcylEHWrQPMr04m6lYGor7RA1OcAiboVMOmvzOEEF131kT5f5Xg31SIoGmiibgHUEFl4WzseD5UvrQndLdBvClHrPER3ssjcaeM4USsN2xA0bA3U8GpPiBpZv65xvOaomFxDqDltSeTXlkjUWgv0HkLmUzuSru0sEHVDIFFfi+snhU2ivhYcPz2uyyEafB2BqK93nKiV39d7TtQNYURdmjSYSyHq9oHmN6QTdXsDUd9ggagbAom6PTDpb8jhBBdd9ZE+3+h4N9UuKBpoom4H1BBZeDs4Hg+VLx0I3S3QbwpR6zxEd7LI3OnoOFErDTsSNOwA1LCTJ0SNrF83OV5zVExuItScziTy60wkaq0Feg8h86kLSdcuFoj6bCBR34y759Hq27NuBsdPj1tyiAbfQiDqro4TtfK7q+dEfTbuyWQJg7kUou4WaH5rOlF3MxD1rRaI+mwgUXcDJv2tOZzgoqs+0ufbHO+mugRFA03UXYAaIgtvd8fjofKlO6G7BfpNIWqdh+hOFpk7PRwnaqVhD4KG3YEa3u4JUSPr1x2O1xwVkzsINacnifx6Eolaa4HeQ8h86kXStZcFoj4LSNS9YTpUWb1G3RscPz365BAN7kMg6r6OE7Xyu6/nRH0W7u1Z1q5R9ws0759O1P0MRN3fAlGfBSTqfsCk75/DCS666iN9vtPxbqpXUDTQRN0LqCGy8A5wPB4qXwYQulug3xSi1nmI7mSRuTPQcaJWGg4kaDgAqOEgT4gaWb8GO15zVEwGE2rOEBL5DSEStdYCvYeQ+TSUpOtQC0TdAEjUd8F0SJbYJOq7wPHT4+4cosF3E4h6mONErfwe5jlRN4ARdajCYC6FqIcHmt+TTtTDDUR9jwWibgAk6uHApL8nhxNcdNVH+nyv493U0KBooIl6KFBDZOEd4Xg8VL6MIHS3QL8pRK3zEN3JInNnpONErTQcSdBwBFDDUZ4QNbJ+3ed4zVExuY9Qc0aTyG80kai1Fug9hMynMSRdx1gg6jOBRH0/TIcyq3d93w+Onx4P5BANfoBA1GMdJ2rl91jPifpM3O+oEwZzKUQ9LtD8wXSiHmcg6gctEPWZQKIeB0z6B3M4wUVXfaTPDzneTY0JigaaqMcANUQW3vGOx0Ply3hCdwv0m0LUOg/RnSwydyY4TtRKwwkEDccDNZzoCVEj69fDjtccFZOHCTVnEon8JhGJWmuB3kPIfJpM0nWyBaI+A0jUj+CuUVt91vcj4Pjp8WgO0eBHCUT9mONErfx+zHOiPgN317e1Z31PCTR/PJ2opxiI+nELRH0GkKinAJP+8RxOcNFVH+nzE453U5ODooEm6slADZGF90nH46Hy5UlCdwv0m0LUOg/RnSwyd6Y6TtRKw6kEDZ8EajjNE6JG1q+nHK85KiZPEWrOdBL5TScStdYCvYeQ+TSDpOuMQFebdHl6DawvejydQzT4aQJdPuM4XSq/nyHQpclWxAZ5hrCJgRuPHm9XNUT6PdOTZmIG0OdZjjcTyteZhGbiWcebbxWXZ8k1J1MNnyM1Ds/9B43DaaTG4fkcosHPExqH2Y43Dsrv2Z40DiqRZxM2MXDj0ePtqoZIv1/wpHF4Dujzi443DsrXFwiNwxzHGwcVlznkmpOphnNJjcNcC9fwTwVew38JuIdsNksv5XCapZdziAa/TGiWXnG8WVJ+v2KpWQplNsTcwFb0pcO5wBgh4z3P8ROoKnTzCCfQVx0/gSqfXyX4/RrppPea4RYQtCbsmCH2+CuEpge53193PO+Vhq8TNJwH1HC+J6CFPOe84fh5QsXkDUK9fJNUL98kXu7VWqD3EDKf3iLtIbSWbwF9zs5af6Bz9UCc36H6wXHelv6/I+e7cr4n5wI535fzAzk/lHOhnB/J+bGci+RcLOcncn4q52dyLpHzczm/kPNLOZfK+ZWcX8u5TM7lcn4j57dyrpBzpZzfyblKzu9z/hIpdd+8HfQZqWvvGNbeNay9Z1hbYFh737D2gWHtQ8PaQsPaR4a1jw1riwxriw1rnxjWPjWsfWZYW2JY+9yw9oVh7UvD2lLD2leGta8Na8sMa8sNa98Y1r41rK0wrK00rH1nWFtlWPve0NNqjD0u+Ivcs5ke621ArdK3SL8DrHtjG3BqPSoWymd5aPEuRL8/zRTvZX6scKCfWACMxTiXYxH9n53i/cx8DqX4LD7I5Fjh9fQTHwJj8aCbsQil2SkWbqHPpckNfBYfbdmx4gb9xMfAWDzkWiziRjvFos33OfYPPovFm3us2D/qJz4BxmK8O7EI/4ud4tPN8Tn2rz6Lzzb9WJUb0U8sAcZigguxiG3UTvH5pvkc2gSfxRebcqzQJuknvgTGYuJ/G4uSTbRTLN2Yz9FN9ll89a/HiiY3Qz/xNTAWD/9XsYhtlp1i2T/7HN9Mn8XyfzhWWXKz9RPfAGMxyX4sQltgp/jW5HNoi3wWKzY8lthC/cRKYCwm24xFYovtFN+t73MkA5/FqpRjhZMZ6Se+B8biEUuxCGU2BPD7AQHkW5HKZ5nG4lFPYgHkIAHs48UEYCwe8yQWwH5PAPsVMQkYiymexAJ4XhPAuiweBcbicVIs0I8CAe5fAcw/wdIPfV8AssdYDbuOG7H6ACic3evfPPpDDtHgH3Lwx/0RmAwsv3/M+Vtg0HGtPgDqe1iyJaw9AGpNoPlPwUX4/10VXRMkYeraTzn8B0Ahqpa+urkGmPQ/gYPL2OBrcvB3m6zJ8eNstwoY659hPpdGbZ7tfiad7X7JIRr8C+Fs96vjZzvl96+en+1WwZKtrNJgLuVstzbQ/Lf0s91aw9nuNwtnu1XAs91aYNL/Rgouuuojff4dVz2N9z5nat+PQdHIBucgEg3WgbsFdNFSMV5H6JJc91vnDtrvPzzpDqH4m8utE6HMhlAxUTai68Q6oIZb5bq/X5SN6P2SDfQ7tVfJTrGVpQU6n1L3Uaa61iDpWiOX/yP/74D7KgemQ7TKJrnmgOOnR24u0eDcXPxx84CbguV3Xu7fAoOOa5Vcv4M1LRVhg7kUcs0PNK+Zm7U+pebnbkiu6j9ik+t3QHLNByZ9zVxOcNFVH+lzgeMdaY2gaKCftlEDqCGy8BY6Hg+VL4WE7hboN+XJDToP0Z0sMndqOU5GSsNaBA0LgRrWBmuoB/ocgKxfdRyvOSomdQg1p4hEfkVEotZaoPcQMp+KSboWWyBq5J3udWE6xMI2ibouOH56bJ1LNHhrAlFv4zhRK7+38ZyoV8KIOl5lMJdC1NsGmm+XTtTbGoh6OwtEvRJI1NsCk367XE5w0VUf6fP2jndTxUHRQBN1MVBDZOHdwfF4qHzZgdDdAv2mELXOQ3Qni8ydHR0naqXhjgQNdwBquJMnRI2sXzs7XnNUTHYm1JxdSOS3C5GotRboPYTMp11Juu5qgahXAIl6N5gOVVYfRL8bOH567J5LNHh3AlHv4ThRK7/38JyoV8CIWiQN5lKIul6gef10oq5nIOr6Foh6BZCo6wGTvn4uJ7joqo/0eU/Hu6ldg6KBJupdgRoiC+9ejsdD5ctehO4W6DeFqHUeojtZZO7s7ThRKw33Jmi4F1DDfTwhamT92tfxmqNisi+h5uxHIr/9iESttUDvIWQ+7U/SdX8LRP0tkKgPgOkQsUrUB4Djp8eBuUSDDyQQ9UGOE7Xy+yDPifpbGFFXWiPqgwPND0kn6oMNRH2IBaL+FkjUBwOT/pBcTnDRVR/p86GOd1P7B0UDTdT7AzVEFt7DHI+HypfDCN0t0G8KUes8RHeyyNw53HGiVhoeTtDwMKCGIU+IGlm/hOM1R8VEEGpOmER+YSJRay3QewiZTxGSrhELRI181nwUpkO51eddRsHx06Mkl2hwCYGoSx0nauV3qedE/Q3uMXnWnncZCzSPpxN1zEDUcQtE/Q2QqGPApI/ncoKLrvpIn8sc76YiQdFAE3UEqCGy8B7heDxUvhxB6G6BflOIWuchupNF5s6RjhO10vBIgoZHADU8yhOiRtavox2vOSomRxNqzjEk8juGSNRaC/QeQubTsSRdj7VA1MuBRH0cTIdwmU2iPg4cPz2OzyUafDyBqE9wnKiV3yd4TtTLcS8ZiBnMpRD1iYHmJ6UT9YkGoj7JAlEvBxL1icCkPymXE1x01Uf6fLLj3dSxQdFAE/WxQA2RhfcUx+Oh8uUUQncL9JtC1DoP0Z0sMndOdZyolYanEjQ8BajhaZ4QNbJ+ne54zVExOZ1Qc84gkd8ZRKLWWqD3EDKfziTpeqYFol4GJOoGMB0q4jaJugE4fnqclUs0+CwCUZ/tOFErv8/2nKiXwYg6GjeYSyHqhoHm56QTdUMDUZ9jgaiXAYm6ITDpz8nlBBdd9ZE+n+t4N3VmUDTQRH0mUENk4T3P8XiofDmP0N0C/aYQtc5DdCeLzJ1GjhO10rARQcPzgBqe7wlRI+vXBY7XHBWTCwg1pzGJ/BoTiVprgd5DyHxqQtK1iQWi/hpI1BfCdCixetf3heD46XFRLtHgiwhEfbHjRK38vthzov4a9/Ysa3d9Nw00vySdqJsaiPoSC0T9NZComwKT/pJcTnDRVR/p86WOd1NNgqKBJuomQA2RhbeZ4/FQ+dKM0N0C/aYQtc5DdCeLzJ3mjhO10rA5QcNmQA0v84SokfWr3PGao2JSTqg5FSTyqyAStdYCvYeQ+VRJ0rXSAlF/BSTqBO4KTYlNok6A46dHVS7R4CoCUScdJ2rld9Jzov4KR9QVBnMpRN0i0PzydKJuYSDqyy0Q9VdAom4BTPrLcznBRVd9pM9XON5NVQZFA03UlUANkYW3pePxUPnSktDdAv2mELXOQ3Qni8ydVo4TtdKwFUHDlkANr/SEqJH16yrHa46KyVWEmtOaRH6tiUSttUDvIWQ+tSHp2sYCUS8FEvXVuH6y1CZRXw2Onx7X5BINvoZA1G0dJ2rld1vPiXop7q7vcoO5FKJuF2h+bTpRtzMQ9bUWiHopkKjbAZP+2lxOcNFVH+nzdY53U22CooEm6jZADZGF93rH46Hy5XpCdwv0m0LUOg/RnSwyd9o7TtRKw/YEDa8HaniDJ0SNrF83Ol5zVExuJNScDiTy60Akaq0Feg8h86kjSdeOFoj6SyBRd4LpELf69qxO4PjpcVMu0eCbCETd2XGiVn539pyov4QRdcza27O6BJrfnE7UXQxEfbMFov4SSNRdgEl/cy4nuOiqj/T5Fse7qY5B0UATdUeghsjC29XxeKh86UroboF+U4ha5yG6k0XmTjfHiVpp2I2gYVeghrd6QtTI+nWb4zVHxeQ2Qs3pTiK/7kSi1lqg9xAyn3qQdO1hgai/ABL17Z4S9e3g+OlxRy7R4DsIRN3TcaJWfvf0nKi/8JCoewWa904n6l4Gou5tgai/ABJ1L2DS9/aEqJE+93G8m+oRFA00UfcAaogsvH0dj4fKl76E7hboN4WodR6iO1lk7vRznKiVhv0IGvYFatjfE6JG1q87Ha85KiZ3EmrOABL5DSAStdYCvYeQ+TSQpOtAC0T9OZCoB8F0KLH6rO9B4PjpMTiXaPBgAlEPcZyold9DPCfqz2FEXW7tWd9DA83vSifqoQaivssCUX8OJOqhwKS/K5cTXHTVR/p8t+Pd1MCgaKCJeiBQQ2ThHeZ4PFS+DCN0t0C/KUSt8xDdySJzZ7jjRK00HE7QcBhQw3s8IWpk/brX8ZqjYnIvoeaMIJHfCCJRay3QewiZTyNJuo60QNRLgEQ9CkfUCZtEPQocPz3uyyUafB+BqEc7TtTK79GeE/USHFFHDOZSiHpMoPn96UQ9xkDU91sg6iVAoh4DTPr7cznBRVd9pM8PON5NjQyKBpqoRwI1RBbesY7HQ+XLWEJ3C/SbQtQ6D9GdLDJ3xjlO1ErDcQQNxwI1fNATokbWr4ccrzkqJg8Ras54EvmNJxK11gK9h5D5NIGk6wQLRP0ZkKgnwnQIW71GPREcPz0eziUa/DCBqCc5TtTK70meE/VnMKJOWLtGPTnQ/JF0op5sIOpHLBD1Z0CingxM+kdyOcFFV32kz4863k1NCIoGmqgnADVEFt7HHI+HypfHCN0t0G8KUes8RHeyyNyZ4jhRKw2nEDR8DKjh454QNbJ+PeF4zVExeYJQc54kkd+TRKLWWqD3EDKfppJ0nWqBqD8FEvU0mA6RiE2ingaOnx5P5RINfopA1NMdJ2rl93TPifpTGFFXJgzmUoh6RqD50+lEPcNA1E9bIOpPgUQ9A5j0T+dygouu+kifn3G8m5oaFA00UU8FaogsvDMdj4fKl5mE7hboN4WodR6iO1lk7sxynKiVhrMIGs4EavisJ0SNrF/POV5zVEyeI9Sc50nk9zyRqLUW6D2EzKfZJF1nWyDqT4BE/QJMhyqr16hfAMdPjxdziQa/SCDqOY4TtfJ7judE/QmMqIW1a9RzA81fSifquQaifskCUX8CJOq5wKR/KZcTXHTVR/r8suPd1OygaKCJejZQQ2ThfcXxeKh8eYXQ3QL9phC1zkN0J4vMnXmOE7XScB5Bw1eAGr7qCVEj69drjtccFZPXCDXndRL5vU4kaq0Feg8h82k+Sdf5Foh6MZCo34DpELVK1G+A46fHm7lEg98kEPVbjhO18vstz4l6MYyoK6wR9duB5u+kE/XbBqJ+xwJRLwYS9dvApH8nlxNcdNVH+vyu493U/KBooIl6PlBDZOF9z/F4qHx5j9DdAv2mELXOQ3Qni8ydBY4TtdJwAUHD94Aavu8JUSPr1weO1xwVkw8INedDEvl9SCRqrQV6DyHzaSFJ14UWiHoRkKg/gukQK7NJ1B+B46fHx7lEgz8mEPUix4la+b3Ic6JeBCPqeMxgLoWoFweaf5JO1IsNRP2JBaJeBCTqxcCk/ySXE1z496hAnz91vJtaGBQNNFEvBGqILLyfOR4PlS+fEbpboN8UotZ5iO5kkbmzxHGiVhouIWj4GVDDzz0hamT9+sLxmqNi8gWh5nxJIr8viUSttUDvIWQ+LSXputQCUX8MJOqvcFdorBL1V+D46fF1LtHgrwlEvcxxolZ+L/OcqD+GEXXUGlEvDzT/Jp2olxuI+hsLRP0xkKiXA5P+m1xOcNFVH+nzt453U0uDooEm6qVADZGFd4Xj8VD5soLQ3QL9phC1zkN0J4vMnZWOE7XScCVBwxVADb/zhKiR9WuV4zVHxWQVoeZ8TyK/74lErbVA7yFkPq0m6braAlF/BCTqH3DXqEM2ifoHcPz0+DGXaPCPBKJe4zhRK7/XeE7UH8GIuixkMJdC1D8Fmv+cTtQ/GYj6ZwtE/RGQqH8CJv3PuZzgoqs+0udfHO+mVgdFA03Uq4EaIgvvr47HQ+XLr4TuFug3hah1HqI7WWTurHWcqJWGawka/grU8DdPiBpZv353vOaomPxOqDnrSOS3jkjUWgv0HkLm0x8kXf+wQNQLgUSdlQfrJ4VNosbZvT5Rb5VHNFgdHH3c7Dy3iVr5nZ33t8Cg41ol6oUwoi5NGsylEHWNQPOcvKz16blG3oZErf4jNlEvBBJ1DWDS5+Rxgouu+kifc/OAGzwLv+HUWVQVDTRR/wHsIJCFN8/xeKh8ycvDd7dAvylErfMQ3ckicyefrGEos/HnXs4naJgH1LAmWEM90OcAZP0qcLzmqJgUEGpOIZgcdA9VmMcjaq0Feg8h86kWSddaeXyi/hBI1LVhOkStvj2rNjh+etTJIxpch0DURY4TtfK7yHOi/hD3ZDJrb88qDjSvm07UxQairmuBqD8EEnUxMOnr5nGCi676SJ+3drybqhUUDTRR1wJqiCy82zgeD5Uv2xC6223AJIO2T+chupNF5s62jhO10nBbgobbADXczhOiRtav7R2vOSom2xNqzg4k8tuBSNRaC/QeQubTjiRdd7RA1B8AiXonmA5VVq9R7wSOnx475xEN3plA1Ls4TtTK7108J+oPcG/PShrMpRD1roHmu6UT9a4Got7NAlF/ACTqXYFJv1seJ7joqo/0eXfHu6kdg6KBJuodgRoiC+8ejsdD5csehO4W6DeFqHUeojtZZO7Uc5yolYb1CBruAdSwvidEjaxfezpec1RM9iTUnL1I5LcXkai1Fug9hMynvUm67m2BqN8HEvU+MB2SJTaJeh9w/PTYN49o8L4Eot7PcaJWfu/nOVG/DyPqUIXBXApR7x9ofkA6Ue9vIOoDLBD1+0Ci3h+Y9AfkcYKLrvpInw90vJvaOygaaKLeG6ghsvAe5Hg8VL4cROhugX5TiFrnIbqTRebOwY4TtdLwYIKGBwE1PMQTokbWr0MdrzkqJocSas5hJPI7jEjUWgv0HkLm0+EkXQ+3QNQLgEQdgulQZvWu7xA4fnqIPKLBgkDUYceJWvkd9pyoF+B+R23tru9IoHk0nagjBqKOWiDqBUCijgCTPprHCS666iN9LnG8mzo8KBpooj4cqCGy8JY6Hg+VL6WE7hboN4WodR6iO1lk7sQcJ2qlYYygYSlQw7gnRI2sX2WO1xwVkzJCzTmCRH5HEIlaa4HeQ8h8OpKk65EWiPo9IFEfhbtGbfVZ30eB46fH0XlEg48mEPUxjhO18vsYz4n6Pdxd39ae9X1soPlx6UR9rIGoj7NA1O8BifpYYNIfl8cJLrrqI30+3vFu6sigaKCJ+kighsjCe4Lj8VD5cgKhuwX6TSFqnYfoThaZOyc6TtRKwxMJGp4A1PAkT4gaWb9OdrzmqJicTKg5p5DI7xQiUWst0HsImU+nknQ9NdDVJl2+m4P1RY/T8ogGn0agy9Mdp0vl9+kEujTZitggpxM2MXDj0ePtqoZIv8/wpJk4FejzmY43E8rXMwjNRAPHm28VlwbkmpOphmeRGoez/oPG4R1S43B2HtHgswmNQ0PHGwfld0NPGgeVyA0Jmxi48ejxdlVDpN/neNI4nAX0+VzHGwfl6zmExuE8xxsHFZfzyDUnUw0bkRqHRhau4b8NvIZ/PnAP2WyWzs/jNEsX5BENvoDQLDV2vFlSfje21CyFMhuiUWAr+tJhI2CMkPFu4vgJVBW6JoQT6IWOn0CVzxcS/L6IdNK7yHALCFoTdswQe7wxoelB7veLHc97peHFBA2bADVs6gloIc85lzh+nlAxuYRQLy8l1ctLiZd7tRboPYTMp2akPYTWshnQ5+ys9Qfa1nXZOE3rB8dpLv2/TM5yOSvkrJQzIWeVnEk5W8h5uZxXyNlSzlZyXinnVXK2lrONnFfLeY2cbeVsJ+e1cl4n5/VytpfzBjlvlLODnB3l7CTnTXJ2zvtLpNR90zzoM1LXLjOslRvWKgxrlYa1hGGtyrCWNKy1MKxdbli7wrDW0rDWyrB2pWHtKsNaa8NaG8Pa1Ya1awxrbQ1r7Qxr1xrWrjOsXW9Ya29Yu8GwdqNhrYNhraNhrZNh7SbDWmdDT5sT/D0u+BvKbKy3ZzOtL80BtUrfIn0ZsO690IBT69NjkYnPKhblEP3+imtF5scKB/qJSmAsXnQ5FtH/2SkSmfkcSvFZVGVyrPB6+okkMBZz3IxFKM1O0WILfS5NbuCzuHzLjhU36CeuAMZirmuxiBvtFC033+fYP/gsWm3usWL/qJ+4EhiLl9yJRfhf7BRXbY7PsX/1WbTe9GNVbkQ/0QYYi5ddiEVso3aKqzfN59Am+Cyu2ZRjhTZJP9EWGItX/ttYlGyinaLdxnyObrLP4tp/PVY0uRn6ieuAsZj3X8Uitll2iuv/2ef4Zvos2v/DscqSm62fuAEYi1ftxyK0BXaKG00+h7bIZ9Fhw2OJLdRPdATG4jWbsUhssZ2i0/o+RzLwWdyUcqxwMiP9RGdgLF63FItQZkMAvx8QQL4VqXyWaSzmexILIAcJYB8vXgbG4g1PYgHs9wSwXxGvAmPxpiexAJ7XBLAui/nAWLxFigX6USDA/SuA+SdY+qHvC0D2GF1g13EjVh8AhbN7/ZtHb84jGnxzHv64twCTgeX3LXl/Cww6rtUHQHWGJVvC2gOgugaadwsuwv/vqmjXIAlT17rl8R8Ahaha+upmV2DSdwMHl7HBu+bh74zqmufH2e4mYKxvhflcGrV5truVdLa7LY9o8G2Es113x892yu/unp/tboIlW1mlwVzK2a5HoPnt6We7Hoaz3e0WznY3Ac92PYBJfzspuOiqj/T5Dlz1NN77nKl9twRFIxucg0g06AnuFtBFS8W4J6FLct1vnTtov3t50h0ic7w3uU6EMhtCxaQ3oU70BGrYx4P90oewX/qCO3Tdq/RNsZWlBTqfegPzqR9J1355/B/5dwLq0B+mQ7TKJrn2B8dPjzvziAbfSSDXAY6Tq/J7gOfk2gmWbBVhg7kUch0YaD4onVwHGsh1kAVyRVQtTa4DgUk/iBRcdNVH+jzY8Y60X1A00E/b6AfUEFl4hzgeD5UvQwjdLdBvypMbdB6iO1lk7gx1nIyUhkMJGg4BaniXJ99KIOvX3Y7XHBWTuwk1ZxiJ/IYRiVprgd5DyHwaTtJ1uAWiRt7pfg9Mh1jYJlHfA46fHvfmEQ2+l0DUIxwnauX3CM+JuiMs2eJVBnMpRD0y0HxUOlGPNBD1KAtEjahamqhHApN+FCm46KqP9Pk+x7up4UHRQBP1cKCGyMI72vF4qHwZTehugX5TiFrnIbqTRebOGMeJWmk4hqDhaKCG93tC1Mj69YDjNUfF5AFCzRlLIr+xRKLWWqD3EDKfxpF0HWeBqDsAdXgQpkOV1QfRPwiOnx4P5RENfohA1OMdJ2rl93jPiboDLNlE0mAuhagnBJpPTCfqCQainmiBqBFVSxP1BGDSTyQFF131kT4/7Hg3NS4oGmiiHgfUEFl4JzkeD5UvkwjdLdBvClHrPER3ssjcmew4USsNJxM0nATU8BFPiBpZvx51vOaomDxKqDmPkcjvMSJRay3QewiZT1NIuk6xQNQ3AnV4HKZDxCpRPw6Onx5P5BENfoJA1E86TtTK7yc9J+obYclWmTSYSyHqqYHm09KJeqqBqKdZIGpE1dJEPRWY9NNIwUVXfaTPTzneTU0JigaaqKcANUQW3umOx0Ply3RCdwv0m0LUOg/RnSwyd2Y4TtRKwxkEDacDNXzaE6JG1q9nHK85KibPEGrOTBL5zSQStdYCvYeQ+TSLpOssC0SNfNb8szAdyq0+7/JZcPz0eC6PaPBzBKJ+3nGiVn4/7zlR3wBLtlJrz7ucHWj+QjpRzzYQ9QsWiBpRtTRRzwYm/Quk4KKrPtLnFx3vpmYFRQNN1LOAGiIL7xzH46HyZQ6huwX6TSFqnYfoThaZO3MdJ2ql4VyChnOAGr7kCVEj69fLjtccFZOXCTXnFRL5vUIkaq0Feg8h82keSdd5Foi6PVCHV2E6hMtsEvWr4Pjp8Voe0eDXCET9uuNErfx+3XOibg9LtkTMYC6FqOcHmr+RTtTzDUT9hgWiRlQtTdTzgUn/Bim46KqP9PlNx7upeUHRQBP1PKCGyML7luPxUPnyFqG7BfpNIWqdh+hOFpk7bztO1ErDtwkavgXU8B1PiBpZv951vOaomLxLqDnvkcjvPSJRay3QewiZTwtIui6wQNTXA3V4H6ZDRdwmUb8Pjp8eH+QRDf6AQNQfOk7Uyu8PPSfq62HJFo0bzKUQ9cJA84/SiXqhgag/skDUiKqliXohMOk/IgUXXfWRPn/seDe1ICgaaKJeANQQWXgXOR4PlS+LCN0t0G8KUes8RHeyyNxZ7DhRKw0XEzRcBNTwE0+IGlm/PnW85qiYfEqoOZ+RyO8zIlFrLdB7CJlPS0i6LrFA1NcBdfgcpkOJ1bu+PwfHT48v8ogGf0Eg6i8dJ2rl95eeE/V1uK+drN31vTTQ/Kt0ol5qIOqvLBA1omppol4KTPqvSMFFV32kz1873k0tCYoGmqiXADVEFt5ljsdD5csyQncL9JtC1DoP0Z0sMneWO07USsPlBA2XATX8xhOiRtavbx2vOSom3xJqzgoS+a0gErXWAr2HkPm0kqTrSgtEfS1Qh+9wV2hKbBL1d+D46bEqj2jwKgJRf+84USu/v/ecqK/FQVeFwVwKUa8ONP8hnahXG4j6BwtEjahamqhXA5P+B1Jw0VUf6fOPjndTK4OigSbqlUANkYV3jePxUPmyhtDdAv2mELXOQ3Qni8ydnxwnaqXhTwQN1wA1/NkTokbWr18crzkqJr8Qas6vJPL7lUjUWgv0HkLm01qSrmstEHU7oA6/4frJUptE/Rs4fnr8nkc0+HcCUa9znKiV3+s8J+p2uK+dyg3mUoj6D615ftb69PyHgajVf8QmakTV0kT9BzLp8znBRVd9pM9b5bvdTa0NigaaqNcCNUQW3mzH46HyRdmI7m6BflOIWuchupNF5k4NsoahzMafe1nZiNYwNXcy1TAHrKEe6HMAsn7lOl5zVExyCTUnDxjr1B4qL59H1FoL9B5C5lM+Sdf8fD5RtwXqUBOmQ9zq27NqguOnR0E+0eCCfPxxC4EnFpbfhfl/Cww6rlWibgsj6ljSYC6FqGsFmtdOJ+pa+RsSdW0LRN0WSNS1gElfO58TXHTVR/pcx/FuKj8oGmiizgdqiCy8RY7HQ+VLEaG7LQKTDNo+nYfoThaZO8WOE7XSsJigYRFQw7qeEDWyfm3teM1RMdmaUHO2IZHfNkSi1lqg9xAyn7Yl6bqtBaK+BkjU23lK1NuB46fH9vlEg7cnEPUOjhO18nsHz4n6Gg+JesdA853SiXpHA1HvZIGorwES9Y7ApN/JE6JG+ryz493UtkHRQBP1tkANkYV3F8fjofJlF0J3C/SbQtQ6D9GdLDJ3dnWcqJWGuxI03AWo4W6eEDWyfu3ueM1RMdmdUHP2IJHfHkSi1lqg9xAyn+qRdK1ngaivBhJ1fZgOJVaf9V0fHD899swnGrwngaj3cpyold97eU7UV8OIutzas773DjTfJ52o9zYQ9T4WiPpqIFHvDUz6ffI5wUVXfaTP+zreTdULigaaqOsBNUQW3v0cj4fKl/0I3S3QbwpR6zxEd7LI3NnfcaJWGu5P0HA/oIYHeELUyPp1oOM1R8XkQELNOYhEfgcRiVprgd5DyHw6mKTrwRaIug2QqA/BEXXCJlEfAo6fHofmEw0+lEDUhzlO1Mrvwzwn6jY4oo4YzKUQ9eGB5qF0oj7cQNQhC0TdBkjUhwOTPpTPCS666iN9Fo53UwcHRQNN1AcDNUQW3rDj8VD5EiZ0t0C/KUSt8xDdySJzJ+I4USsNIwQNw0ANo54QNbJ+lThec1RMSgg1p5REfqVEotZaoPcQMp9iJF1jFoi6NZCo4zAdwlavUcfB8dOjLJ9ocBmBqI9wnKiV30d4TtStYUSdsHaN+shA86PSifpIA1EfZYGoWwOJ+khg0h+VzwkuuuojfT7a8W4qFhQNNFHHgBoiC+8xjsdD5csxhO4W6DeFqHUeojtZZO4c6zhRKw2PJWh4DFDD4zwhamT9Ot7xmqNicjyh5pxAIr8TiESttUDvIWQ+nUjS9UQLRH0VkKhPgukQidgk6pPA8dPj5HyiwScTiPoUx4la+X2K50R9FYyoKxMGcylEfWqg+WnpRH2qgahPs0DUVwGJ+lRg0p+WzwkuuuojfT7d8W7qxKBooIn6RKCGyMJ7huPxUPlyBqG7BfpNIWqdh+hOFpk7ZzpO1ErDMwkangHUsIEnRI2sX2c5XnNUTM4i1JyzSeR3NpGotRboPYTMp4YkXRtaIOorgUR9DkyHKqvXqM8Bx0+Pc/OJBp9LIOrzHCdq5fd5nhP1lTCiFtauUTcKND8/nagbGYj6fAtEfSWQqBsBk/78fE5w0VUf6fMFjndTDYOigSbqhkANkYW3sePxUPnSmNDdAv2mELXOQ3Qni8ydJo4TtdKwCUHDxkANL/SEqJH16yLHa46KyUWEmnMxifwuJhK11gK9h5D51JSka1MLRN0KSNSXwHSIWiXqS8Dx0+PSfKLBlxKIupnjRK38buY5UbfCvbTdGlE3DzS/LJ2omxuI+jILRN0KSNTNgUl/WT4nuOiqj/S53PFuqmlQNNBE3RSoIbLwVjgeD5UvFYTuFug3hah1HqI7WWTuVDpO1ErDSoKGFUANE54QNbJ+VTlec1RMqgg1J0kivySRqLUW6D2EzKcWJF1bWCDqlkCivhymQ6zMJlFfDo6fHlfkEw2+gkDULR0nauV3S8+JuiWMqOMxg7kUom4VaH5lOlG3MhD1lRaIuiWQqFsBk/7KfE5w4d+jAn2+yvFuqkVQNNBE3QKoIbLwtnY8HipfWhO6W6DfFKLWeYjuZJG508ZxolYatiFo2Bqo4dWeEDWyfl3jeM1RMbmGUHPaksivLZGotRboPYTMp3YkXdtZIOorgER9Le4KjVWivhYcPz2uyycafB2BqK93nKiV39d7TtRXwIg6ao2o2wea35BO1O0NRH2DBaK+AkjU7YFJf0M+J7joqo/0+UbHu6l2QdFAE3U7oIbIwtvB8XiofOlA6G6BflOIWuchupNF5k5Hx4laadiRoGEHoIadPCFqZP26yfGao2JyE6HmdCaRX2ciUWst0HsImU9dSLp2sUDUlwOJ+mbcNeqQTaK+GRw/PW7JJxp8C4GouzpO1Mrvrp4T9eUwoi4LGcylEHW3QPNb04m6m4Gob7VA1JcDibobMOlvzecEF131kT7f5ng31SUoGmii7gLUEFl4uzseD5Uv3QndLdBvClHrPER3ssjc6eE4USsNexA07A7U8HZPiBpZv+5wvOaomNxBqDk9SeTXk0jUWgv0HkLmUy+Srr0sEHULIFH3xvWTwiZR9wbHT48++USD+xCIuq/jRK387us5UbeAEXVp0mAuhaj7BZr3Tyfqfgai7m+BqFsAibofMOn753OCi676SJ/vdLyb6hUUDTRR9wJqiCy8AxyPh8qXAYTuFug3hah1HqI7WWTuDHScqJWGAwkaDgBqOMgTokbWr8GO1xwVk8GEmjOERH5DiESttUDvIWQ+DSXpOtQCUSeBRH0X7p5Hq2/PugscPz3uzicafDeBqIc5TtTK72GeE3US92Qya2/PGh5ofk86UQ83EPU9Fog6CSTq4cCkvyefE1x01Uf6fK/j3dTQoGigiXooUENk4R3heDxUvowgdLdAvylErfMQ3ckic2ek40StNBxJ0HAEUMNRnhA1sn7d53jNUTG5j1BzRpPIbzSRqLUW6D2EzKcxJF3HWCDqKiBR3w/TocrqNer7wfHT44F8osEPEIh6rONErfwe6zlRV+HenmXtGvW4QPMH04l6nIGoH7RA1FVAoh4HTPoH8znBRVd9pM8POd5NjQmKBpqoxwA1RBbe8Y7HQ+XLeEJ3C/SbQtQ6D9GdLDJ3JjhO1ErDCQQNxwM1nOgJUSPr18OO1xwVk4cJNWcSifwmEYlaa4HeQ8h8mkzSdbIFok4AifoRmA7JEptE/Qg4fno8mk80+FECUT/mOFErvx/znKgTMKIOVRjMpRD1lEDzx9OJeoqBqB+3QNQJIFFPASb94/mc4KKrPtLnJxzvpiYHRQNN1JOBGiIL75OOx0Ply5OE7hboN4WodR6iO1lk7kx1nKiVhlMJGj4J1HCaJ0SNrF9POV5zVEyeItSc6STym04kaq0Feg8h82kGSdcZFoi6EkjUT8N0KLN61/fT4Pjp8Uw+0eBnCEQ903GiVn7P9JyoK3G/o7Z21/esQPNn04l6loGon7VA1JVAop4FTPpn8znBRVd9pM/POd5NzQiKBpqoZwA1RBbe5x2Ph8qX5wndLdBvClHrPER3ssjcme04USsNZxM0fB6o4QueEDWyfr3oeM1RMXmRUHPmkMhvDpGotRboPYTMp7kkXedaIOoKIFG/hLtGbfVZ3y+B46fHy/lEg18mEPUrjhO18vsVz4m6AnfXt7Vnfc8LNH81najnGYj6VQtEXQEk6nnApH81nxNcdNVH+vya493U3KBooIl6LlBDZOF93fF4qHx5ndDdAv2mELXOQ3Qni8yd+Y4TtdJwPkHD14EavuEJUSPr15uO1xwVkzcJNectEvm9RSRqrQV6DyHz6W2Srm8Hutqky/I8rC96vJNPNPgdAl2+6zhdKr/fJdClyVbEBnmXsImBG48eb1c1RPr9nifNxNtAnxc43kwoX98jNBPvO958q7i8T645mWr4Aalx+OA/aBwuIzUOH+YTDf6Q0DgsdLxxUH4v9KRxUIm8kLCJgRuPHm9XNUT6/ZEnjcMHQJ8/drxxUL5+RGgcFjneOKi4LCLXnEw1XExqHBZbuIbfHHgN/xPgHrLZLH2Sz2mWPs0nGvwpoVn6zPFmSfn9maVmKZTZEIsDW9GXDhcDY4SM9xLHT6Cq0C0hnEA/d/wEqnz+nOD3F6ST3heGW0DQmrBjhtjjnxGaHuR+/9LxvFcafknQcAlQw6WegBbynPOV4+cJFZOvCPXya1K9/Jp4uVdrgd5DyHxaRtpDaC2XAX3Ozlp/oG3NroHTtH5wnOXS/2/k/FbOFXKulPM7OVfJ+b2cq+X8Qc4f5Vwj509y/iznL3L+KudaOX+T83c518n5h+IA2ShsJWe2nDXkzJEzV848OfPlrClngZyFNf8SKXXfLA/6jNS1bwxr3xrWVhjWVhrWvjOsrTKsfW9YW21Y+8Gw9qNhbY1h7SfD2s+GtV8Ma78a1tYa1n4zrP1uWFtnWPvDsKYW0te2MqxlG9ZqGNZyDGu5hrU8w1q+Ya2mYa3AsFZYc8OeNif4e1zwN5TZWG/PZlpflgNqlb5F+hskrzbg1Pr0WGTis4rFtxD9/orrisyPFQ70EyuRvO9yLKL/s1N8l5nPoRSfxapMjhVeTz/xPTAWn7sZi1CanWL1FvpcmtzAZ/HDlh0rbtBP/AiMxReuxSJutFOs2XyfY//gs/hpc48V+0f9xM/I7yjciUX4X+wUv2yOz7F/9Vn8uunHqtyIfmIt8rsOF2IR26id4rdN8zm0CT6L3zflWKFN0k+sQ34H89/GomQT7RR/bMzn6Cb7LFQD/s/HiiY3Qz+xVU3g90L/VSxim2WnyP5nn+Ob6bOo8Q/HKktutn4iBxiLZfZjEdoCO0WuyefQFvks8jY8lthC/UQ+MBbLbcYiscV2iprr+xzJwGdRkHKscDIj/UQhMBbfWIpFKLMhgN8PCCDfilQ+yzQW33oSCyAHCWAfL5YCY7HCk1gA+z0B7FfEMmAsVnoSC+B5TQDrsvgWGIvvSLFAPwoEuH8FMP8ESz/0fQHIHqNWTZTPEasPgMLZvf7No7VrEg1WB0cftw4wGVh+10m5Cgc6rtUHQBXCki1h7QFQRYHmxelXRYuCJExdK67JfwAUomrpq5tFwKQvBgeXscGLauLvjCqq6cfZrgAY67own0ujNs92dUlnu61rEg3emnC228bxs53yexvPz3YFsGQrqzSYSznbbRtovl362W5bw9luOwtnuwLg2W5bYNJvRwouuuojfd4eVz2N9z5nal+doGhkg3MQiQY7gLsFdNFSMd6B0CW57rfOHbTfO3rSHSJzfCdynQhlNoSKyU6EOrEDUMOdPdgvOxP2yy7gDl33Kruk2MrSAp1POwHzaVeSrrvW5P/IvyZQh91gOkSrbJLrbuD46bF7TaLBuxPIdQ/HyVX5vYfn5FoTlmwVYYO5FHKtF2heP51c6xnItb4FckVULU2u9YBJX58UXHTVR/q8p+Md6a5B0UA/bWNXoIbIwruX4/FQ+bIXobsF+k15coPOQ3Qni8ydvR0nI6Xh3gQN9wJquI8n30og69e+jtccFZN9CTVnPxL57Uckaq0Feg8h82l/kq77WyBq5J3uB8B0iIVtEvUB4PjpcWBNosEHEoj6IMeJWvl9kOdEnQ9LtniVwVwKUR8caH5IOlEfbCDqQywQNaJqaaI+GJj0h5CCi676SJ8Pdbyb2j8oGmii3h+oIbLwHuZ4PFS+HEboboF+U4ha5yG6k0XmzuGOE7XS8HCChocBNQx5QtTI+iUcrzkqJoJQc8Ik8gsTiVprgd5DyHyKkHSNWCDqPKAOUZgOVVYfRB8Fx0+PkppEg0sIRF3qOFErv0s9J+o8WLKJpMFcClHHAs3j6UQdMxB13AJRI6qWJuoYMOnjpOCiqz7S5zLHu6lIUDTQRB0BaogsvEc4Hg+VL0cQulug3xSi1nmI7mSRuXOk40StNDySoOERQA2P8oSokfXraMdrjorJ0YSacwyJ/I4hErXWAr2HkPl0LEnXYy0QdS5Qh+NgOkSsEvVx4PjpcXxNosHHE4j6BMeJWvl9gudEnQtLtkprRH1ioPlJ6UR9ooGoT7JA1IiqpYn6RGDSn0QKLrrqI30+2fFu6tigaKCJ+lighsjCe4rj8VD5cgqhuwX6TSFqnYfoThaZO6c6TtRKw1MJGp4C1PA0T4gaWb9Od7zmqJicTqg5Z5DI7wwiUWst0HsImU9nknQ90wJRI5813wCmQ7nV5102AMdPj7NqEg0+i0DUZztO1Mrvsz0n6hxYspVae95lw0Dzc9KJuqGBqM+xQNSIqqWJuiEw6c8hBRdd9ZE+n+t4N3VmUDTQRH0mUENk4T3P8XiofDmP0N0C/aYQtc5DdCeLzJ1GjhO10rARQcPzgBqe7wlRI+vXBY7XHBWTCwg1pzGJ/BoTiVprgd5DyHxqQtK1iQWirgHU4UKYDuEym0R9ITh+elxUk2jwRQSivthxolZ+X+w5UdeAJVsiZjCXQtRNA80vSSfqpgaivsQCUSOqlibqpsCkv4QUXHTVR/p8qePdVJOgaKCJuglQQ2ThbeZ4PFS+NCN0t0C/KUSt8xDdySJzp7njRK00bE7QsBlQw8s8IWpk/Sp3vOaomJQTak4FifwqiESttUDvIWQ+VZJ0rbRA1NlAHRIwHSriNok6AY6fHlU1iQZXEYg66ThRK7+TnhN1NizZonGDuRSibhFofnk6UbcwEPXlFogaUbU0UbcAJv3lpOCiqz7S5ysc76Yqg6KBJupKoIbIwtvS8XiofGlJ6G6BflOIWuchupNF5k4rx4laadiKoGFLoIZXekLUyPp1leM1R8XkKkLNaU0iv9ZEotZaoPcQMp/akHRtY4GotwLqcDVMhxKrd31fDY6fHtfUJBp8DYGo2zpO1Mrvtp4T9Va4r52s3fXdLtD82nSibmcg6mstEDWiammibgdM+mtJwUVXfaTP1zneTbUJigaaqNsANUQW3usdj4fKl+sJ3S3QbwpR6zxEd7LI3GnvOFErDdsTNLweqOENnhA1sn7d6HjNUTG5kVBzOpDIrwORqLUW6D2EzKeOJF07WiDqLKAOnXBXaEpsEnUncPz0uKkm0eCbCETd2XGiVn539pyos3DQVWEwl0LUXQLNb04n6i4Gor7ZAlEjqpYm6i7ApL+ZFFx01Uf6fIvj3VTHoGigibojUENk4e3qeDxUvnQldLdAvylErfMQ3ckic6eb40StNOxG0LArUMNbPSFqZP26zfGao2JyG6HmdCeRX3ciUWst0HsImU89SLr2sEDUf+TjjnU7rp8stUnUt4Pjp8cdNYkG30Eg6p6OE7Xyu6fnRJ264UIZjWi5wVwKUfcKNO+dTtS9DETd2wJRI6qWJupewKTvXZMTXHTVR/rcx/FuqkdQNNBE3QOoIbLw9nU8Hipf+hK6W6DfFKLWeYjuZJG5089xolYa9iNo2BeoYX9PiBpZv+50vOaomNxJqDkDSOQ3gEjUWgv0HkLm00CSrgMtEPU6IFEPgukQt/r2rEHg+OkxuCbR4MEEoh7iOFErv4d4TtTrYEQds/b2rKGB5nelE/VQA1HfZYGo1wGJeigw6e+qyQkuuuojfb7b8W5qYFA00EQ9EKghsvAOczweKl+GEbpboN8UotZ5iO5kkbkz3HGiVhoOJ2g4DKjhPZ4QNbJ+3et4zVExuZdQc0aQyG8Ekai1Fug9hMynkSRdR1og6t+BRD3KU6IeBY6fHvfVJBp8H4GoRztO1Mrv0Z4T9e8eEvWYQPP704l6jIGo77dA1L8DiXoMMOnv94SokT4/4Hg3NTIoGmiiHgnUEFl4xzoeD5UvYwndLdBvClHrPER3ssjcGec4USsNxxE0HAvU8EFPiBpZvx5yvOaomDxEqDnjSeQ3nkjUWgv0HkLm0wSSrhMsEPVvQKKeCNOhxOqzvieC46fHwzWJBj9MIOpJjhO18nuS50T9G4yoy60963tyoPkj6UQ92UDUj1gg6t+ARD0ZmPSP1OQEF131kT4/6ng3NSEoGmiingDUEFl4H3M8HipfHiN0t0C/KUSt8xDdySJzZ4rjRK00nELQ8DGgho97QtTI+vWE4zVHxeQJQs15kkR+TxKJWmuB3kPIfJpK0nWqBaJeCyTqaTiiTtgk6mng+OnxVE2iwU8RiHq640St/J7uOVGvxRF1xGAuhahnBJo/nU7UMwxE/bQFol4LJOoZwKR/uiYnuOiqj/T5Gce7qalB0UAT9VSghsjCO9PxeKh8mUnoboF+U4ha5yG6k0XmzizHiVppOIug4Uyghs96QtTI+vWc4zVHxeQ5Qs15nkR+zxOJWmuB3kPIfJpN0nW2BaL+FUjUL8B0CFu9Rv0COH56vFiTaPCLBKKe4zhRK7/neE7Uv8KIOmHtGvXcQPOX0ol6roGoX7JA1L8CiXouMOlfqskJLrrqI31+2fFuanZQNNBEPRuoIbLwvuJ4PFS+vELoboF+U4ha5yG6k0XmzjzHiVppOI+g4StADV/1hKiR9es1x2uOislrhJrzOon8XicStdYCvYeQ+TSfpOt8C0T9C5Co34DpEInYJOo3wPHT482aRIPfJBD1W44TtfL7Lc+J+hcYUVcmDOZSiPrtQPN30on6bQNRv2OBqH8BEvXbwKR/pyYnuOiqj/T5Xce7qflB0UAT9XyghsjC+57j8VD58h6huwX6TSFqnYfoThaZOwscJ2ql4QKChu8BNXzfE6JG1q8PHK85KiYfEGrOhyTy+5BI1FoL9B5C5tNCkq4LLRD1z0Ci/gimQ5XVa9QfgeOnx8c1iQZ/TCDqRY4TtfJ7kedE/TOMqIW1a9SLA80/SSfqxQai/sQCUf8MJOrFwKT/pCYnuOiqj/T5U8e7qYVB0UAT9UKghsjC+5nj8VD58hmhuwX6TSFqnYfoThaZO0scJ2ql4RKChp8BNfzcE6JG1q8vHK85KiZfEGrOlyTy+5JI1FoL9B5C5tNSkq5LLRD1T0Ci/gqmQ9QqUX8Fjp8eX9ckGvw1gaiXOU7Uyu9lnhP1TzCirrBG1MsDzb9JJ+rlBqL+xgJR/wQk6uXApP+mJie46KqP9Plbx7uppUHRQBP1UqCGyMK7wvF4qHxZQehugX5TiFrnIbqTRebOSseJWmm4kqDhCqCG33lC1Mj6tcrxmqNisopQc74nkd/3RKLWWqD3EDKfVpN0XW2BqNcAifoHmA6xMptE/QM4fnr8WJNo8I8Eol7jOFErv9d4TtRrYEQdjxnMpRD1T4HmP6cT9U8Gov7ZAlGvARL1T8Ck/7kmJ7jw71GBPv/ieDe1OigaaKJeDdQQWXh/dTweKl9+JXS3QL8pRK3zEN3JInNnreNErTRcS9DwV6CGv3lC1Mj69bvjNUfF5HdCzVlHIr91RKLWWqD3EDKf/iDp+ocFov4RSNRZBbArNFaJGmf3+kS9VQHRYHVw9HGzC9wmauV3dsHfAoOOa5Wof4QRddQaUdcINM8pyFqfnmsUbEjU6j9iE/WPQKKuAUz6nAJOcNFVH+lzbgFwg2fhN5w6i6qigSbqP4AdBLLw5jkeD5UveQX47hboN4WodR6iO1lk7uSTNQxlNv7cy/kEDfOAGtYEa6gH+hyArF8FjtccFZMCQs0pBJOD7qEKC3hErbVA7yFkPtUi6VqrgE/UPwCJujZMh1jIJlHXBsdPjzoFRIPrEIi6yHGiVn4XeU7UP8CIuixkMJdC1MWB5nXTibrYQNR1LRD1D0CiLgYmfd0CTnDRVR/p89aOd1O1gqKBJupaQA2RhXcbx+Oh8mUbQncL9JtC1DoP0Z0sMne2dZyolYbbEjTcBqjhdp4QNbJ+be94zVEx2Z5Qc3Ygkd8ORKLWWqD3EDKfdiTpuqMFol4NJOqdcP2ksEnUO4Hjp8fOBUSDdyYQ9S6OE7XyexfPiXo1jKhLkwZzKUS9a6D5bulEvauBqHezQNSrgUS9KzDpdyvgBBdd9ZE+7+54N7VjUDTQRL0jUENk4d3D8XiofNmD0N0C/aYQtc5DdCeLzJ16jhO10rAeQcM9gBrW94SokfVrT8drjorJnoSasxeJ/PYiErXWAr2HkPm0N0nXvS0Q9fdAot4Hd8+j1bdn7QOOnx77FhAN3pdA1Ps5TtTK7/08J+rvcU8ms/b2rP0DzQ9IJ+r9DUR9gAWi/h5I1PsDk/6AAk5w0VUf6fOBjndTewdFA03UewM1RBbegxyPh8qXgwjdLdBvClHrPER3ssjcOdhxolYaHkzQ8CCghod4QtTI+nWo4zVHxeRQQs05jER+hxGJWmuB3kPIfDqcpOvhFoh6FZCoQzAdqqxeow6B46eHKCAaLAhEHXacqJXfYc+JehXu7VnWrlFHAs2j6UQdMRB11AJRrwISdQSY9NECTnDRVR/pc4nj3dThQdFAE/XhQA2RhbfU8XiofCkldLdAvylErfMQ3ckicyfmOFErDWMEDUuBGsY9IWpk/SpzvOaomJQRas4RJPI7gkjUWgv0HkLm05EkXY+0QNTfAYn6KJgOyRKbRH0UOH56HF1ANPhoAlEf4zhRK7+P8Zyov4MRdajCYC6FqI8NND8unaiPNRD1cRaI+jsgUR8LTPrjCjjBRVd9pM/HO95NHRkUDTRRHwnUEFl4T3A8HipfTiB0t0C/KUSt8xDdySJz50THiVppeCJBwxOAGp7kCVEj69fJjtccFZOTCTXnFBL5nUIkaq0Feg8h8+lUkq6nWiDqlUCiPg2mQ5nVu75PA8dPj9MLiAafTiDqMxwnauX3GZ4T9Urc76it3fV9ZqB5g3SiPtNA1A0sEPVKIFGfCUz6BgWc4KKrPtLnsxzvpk4NigaaqE8FaogsvGc7Hg+VL2cTulug3xSi1nmI7mSRudPQcaJWGjYkaHg2UMNzPCFqZP061/Gao2JyLqHmnEciv/OIRK21QO8hZD41IunayAJRrwAS9fm4a9RWn/V9Pjh+elxQQDT4AgJRN3acqJXfjT0n6hW4u76tPeu7SaD5helE3cRA1BdaIOoVQKJuAkz6Cws4wUVXfaTPFzneTTUKigaaqBsBNUQW3osdj4fKl4sJ3S3QbwpR6zxEd7LI3GnqOFErDZsSNLwYqOElnhA1sn5d6njNUTG5lFBzmpHIrxmRqLUW6D2EzKfmJF2bB7rapMtv87G+6HFZAdHgywh0We44XSq/ywl0abIVsUHKCZsYuPHo8XZVQ6TfFZ40E82BPlc63kwoXysIzUTC8eZbxSVBrjmZalhFahyq/oPG4RtS45AsIBqcJDQOLRxvHJTfLTxpHFQityBsYuDGo8fbVQ2Rfl/uSeNQBfT5CscbB+Xr5YTGoaXjjYOKS0tyzclUw1akxqGVhWv4y4HX8K8E7iGbzdKVBZxm6aoCosFXEZql1o43S8rv1paapVBmQ7QKbEVfOmwFjBEy3m0cP4GqQteGcAK92vETqPL5aoLf15BOetcYbgFBa8KOGWKPtyY0Pcj93tbxvFcatiVo2AaoYTtPQAt5zrnW8fOEism1hHp5HaleXke83Ku1QO8hZD5dT9pDaC2vB/qcm7U+GKV+bq/6Y/UfZGfZoaf2wABkp9h5Q9Do31iQ5gD6htD2wMjcsOnHqtzIscSN4IpRK0U7pH7r/v144cqkiJRUxUpCpeXRkkRpJJwIx0KJaElSSCHCZVEpQ7IyGk/Ew5FkOBauXIe170/fs1OSX8VoXfD5xuBzB/m3o5ydCv7aPLbu6O5Eql7gGIdTtbgp2JCdC7LWv3tb/Q+/pxmA3qydAJv1r7u3k8mbgBu/s6VWLpTZEEifu6QcS8Qj4XAsov67eCIkoglZ3sLhREU0VBkqrwxXlUVFWTIajkYqE5UV8pjlIhlKlleWJeN/2WXz+74upO/7bi4gGnwz4fu+Wxz/vk/5fYsnF0c7B7aij9uVxA1dC/5uEVM7A/XvFtl/nyEvT/l8RfZffzd2Nu0m/94q522Wz6a3eXg27R7kd4/0s2l3C2fT24Bn0+7AYtLDk7Mp0ufbPT2b3k46m95RQDT4DsLZtKfjZ1Pld09PzqY9AlvRx+1FOpv2KtjwDIeOH7Iosm3tBrS1fnCc3vKYfeTsK2c/OfvLeaecA+QcKOcgOQfLOUTOoXLeJefdcg6Tc7ic98h5r5wj5Bwp5yg575NztJxj5LxfzgfkHCvnODkflPMhOcfLOSE4O6fGvHdwpSp1rY9hra9hrZ9hrb9h7U7D2gDD2kDD2iDD2mDD2hDD2lDD2l2GtbsNa8MMa8MNa/cY1u41rI0wrI00rI0yrN1nWBttWBtjWLvfsPaAYW2sYW2cYe1Bw9pDhrXxhrUJBRteFc0J/h4X/A1lNtbbs5nW2d6wxjIk+iDPq2dxGsv0WGTis4pFX4h+f8W1X+bHCuvvpPsDY7GVy7GI/v09/J2Z+RxK/U5/QCbHCq9/fWAgMBbZbsYilH5NZNAW+lya3PD6yuAtO1bcdK1mCDAWNVyLRdx8fWro5vsc+6drXXdt7rFi/3zd7G5gLHLciUX4364VDtscn2P/ft1x+KYfa6PXMO8BxiLXhVjENmqnuHfTfA5tgs9ixKYcK7RJ+omRwFjk/bexKNlEO8Wojfkc3WSfxX3/eqxocjP0E6OBscj/r2IR2yw7xZh/9jm+mT6L+//hWGXJzdZPPACMRU37sQhtgZ1irMnn0Bb5LMZteCyxhfqJB4GxKLAZi8QW2ykeWt/nSAY+i/EpxwonM9JPTADGotBSLEKZDQH8fkAA+Vak8lmmsajlSSyAHCSAfbzIBcaitiexAPZ7AtiviJrAWNTxJBbA85oA1mVRCxiLIlIs0DdQAPevAOafQOqn8ncXOesHx5sQXBN7KLhGNi64ZvZAcA1tTHBN7b7gGtvI4JrbvcE1uOHBNbm7g2t0Q4NrdoODa3gDg2t6dwbX+PoF1/zUdQB1XSF9pN/UkWnuIfueiQWoOESsPtYcZ/f6N3U8XEA0WB0cfdxJyItPJL8npWwK0HGtPtZ8AizZEtYeaz450PyR4MaA/12pnRwkYeraIwX8x5ojqpa+4joZmPSPgIPL2OCTC/B3Gk0u4HQw6LPdeGCsH4X5XBq1ebZ7lHS2e6yAaPBjhLPdFMfPdsrvKZ6f7cbDkq2s0mAu5Wz3eKD5E+lnu8cNZ7snLJztxgPPdo8Dk/4JUnDRVR/p85O46mn8RX+m9k0KikY2OAeRaDAV3C2gi5aK8VRCl+S63zp30H5P86Q7ROb4U+Q6EcpsCBWTpwh1YipQw+ke7JfphP0yA9yh615lRoqtLC3Q+fQUMJ+eJun6dMGG5IauTQ8BdXgGpkO0yia5PgOOnx4zC4gGzySQ6yzHyVX5Pctzcn0IlmwVYYO5FHJ9NtD8uXRyfdZArs9ZIFdE1dLk+iww6Z8jBRdd9ZE+P+94R/p0UDTQz5B9GqghsvDOdjweKl9mE7pboN+UX2PrPER3ssjcecFxMlIavkDQcDZQwxc9+VYCWb/mOF5zVEzmEGrOXBL5zSUStdYCvYeQ+fQSSdeXLBA18u77l2E6xMI2ifplcPz0eKWAaPArBKKe5zhRK7/neU7UD8KSLV5lMJdC1K8Gmr+WTtSvGoj6NQtEjahamqhfBSb9a6Tgoqs+0ufXHe+mXgqKBpqoXwJqiCy88x2Ph8qX+YTuFug3hah1HqI7WWTuvOE4USsN3yBoOB+o4ZueEDWyfr3leM1RMXmLUHPeJpHf20Si1lqg9xAyn94h6fqOBaIeB9ThXZgOVVYfEPsuOH56vFdANPg9AlEvcJyold8LPCfqcbBkE0mDuRSifj/Q/IN0on7fQNQfWCBqRNXSRP0+MOk/IAUXXfWRPn/oeDf1TlA00ET9DlBDZOFd6Hg8VL4sJHS3QL8pRK3zEN3JInPnI8eJWmn4EUHDhUANP/aEqJH1a5HjNUfFZBGh5iwmkd9iIlFrLdB7CJlPn5B0/cQCUY8F6vApTIeIVaL+FBw/PT4rIBr8GYGolzhO1MrvJZ4T9VhYslVaI+rPA82/SCfqzw1E/YUFokZULU3UnwOT/gtScNFVH+nzl453U58ERQNN1J8ANUQW3qWOx0Ply1JCdwv0m0LUOg/RnSwyd75ynKiVhl8RNFwK1PBrT4gaWb+WOV5zVEyWEWrOchL5LScStdYCvYeQ+fQNSddvLBA18vn338J0KLf6vMtvwfHTY0UB0eAVBKJe6ThRK79Xek7UD8CSrdTa8y6/CzRflU7U3xmIepUFokZULU3U3wGTfhUpuOiqj/T5e8e7qW+CooEm6m+AGiIL72rH46HyZTWhuwX6TSFqnYfoThaZOz84TtRKwx8IGq4GavijJ0SNrF9rHK85KiZrCDXnJxL5/UQkaq0Feg8h8+lnkq4/WyDq+4E6/ALTIVxmk6h/AcdPj18LiAb/SiDqtY4TtfJ7redEfT8s2RIxg7kUov4t0Pz3dKL+zUDUv1sgakTV0kT9GzDpfycFF131kT6vc7yb+jkoGmii/hmoIbLw/uF4PFS+/EHoboF+U4ha5yG6k4WetAvdJmqlobIRreEfQA23AmuoB/ocgKxf2YVu1xwVE2Ujek/XAMY6tYeqUcgjaq0Feg8h8ymHpGtOIZ+oxwB1yIXpUBG3SdS54PjpkVdINDivEH/c/EK3iVr5nV/4t8Cg41ol6jGwxi8aN5hLIeqageYFhVnr03PNwg2JWv1HbKIeAyTqmsCkLyjkBBdd9ZE+FzreTeUERQNN1DlADZGFt5bj8VD5UovQ3dYCkwzaPp2H6E4WmTu1HSdqpWFtgoa1gBrW8YSokfWryPGao2JSRKg5xSTyKyYStdYCvYeQ+VSXpGtdC0Q9GkjUW8N0KLF61/fW4PjpsU0h0eBtCES9reNErfze1nOiHg0j6gprd31vF2i+fTpRb2cg6u0tEPVoIFFvB0z67Qs5wUVXfaTPOzjeTdUNigaaqOsCNUQW3h0dj4fKlx0J3S3QbwpR6zxEd7LI3NnJcaJWGu5E0HBHoIY7e0LUyPq1i+M1R8VkF0LN2ZVEfrsSiVprgd5DyHzajaTrbhaI+j4gUe+Ou0JTYpOodwfHT489CokG70Eg6nqOE7Xyu57nRH0fjqgrDOZSiLp+oPme6URd30DUe1og6vuARF0fmPR7FnKCi676SJ/3cryb2i0oGmii3g2oIbLw7u14PFS+7E3oboF+U4ha5yG6k0Xmzj6OE7XScB+ChnsDNdzXE6JG1q/9HK85Kib7EWrO/iTy259I1FoL9B5C5tMBJF0PsEDUo4BEfSCunyy1SdQHguOnx0GFRIMPIhD1wY4TtfL7YM+JehTuru9yg7kUoj4k0PzQdKI+xEDUh1og6lFAoj4EmPSHFnKCi676SJ8Pc7ybOiAoGmiiPgCoIbLwHu54PFS+HE7oboF+U4ha5yG6k0XmTshxolYahggaHg7UUHhC1Mj6FXa85qiYhAk1J0IivwiRqLUW6D2EzKcoSdeoBaIeCSTqEpgOcatvzyoBx0+P0kKiwaUEoo45TtTK75jnRD0SRtQxa2/Pigeal6UTddxA1GUWiHokkKjjwKQvK+QEF131kT4f4Xg3FQ2KBpqoo0ANkYX3SMfjofLlSEJ3C/SbQtQ6D9GdLDJ3jnKcqJWGRxE0PBKo4dGeEDWyfh3jeM1RMTmGUHOOJZHfsUSi1lqg9xAyn44j6XqcBaIeASTq4z0l6uPB8dPjhEKiwScQiPpEx4la+X2i50Q9wkOiPinQ/OR0oj7JQNQnWyDqEUCiPgmY9Cd7QtRIn09xvJs6LigaaKI+DqghsvCe6ng8VL6cSuhugX5TiFrnIbqTRebOaY4TtdLwNIKGpwI1PN0TokbWrzMcrzkqJmcQas6ZJPI7k0jUWgv0HkLmUwOSrg0sEPW9QKI+C6ZDidVnfZ8Fjp8eZxcSDT6bQNQNHSdq5XdDz4n6XtxL26096/ucQPNz04n6HANRn2uBqO8FEvU5wKQ/t5ATXHTVR/p8nuPdVIOgaKCJugFQQ2ThbeR4PFS+NCJ0t0C/KUSt8xDdySJz53zHiVppeD5Bw0ZADS/whKiR9aux4zVHxaQxoeY0IZFfEyJRay3QewiZTxeSdL3QAlHfAyTqi3BEnbBJ1BeB46fHxYVEgy8mEHVTx4la+d3Uc6K+B0fUEYO5FKK+JND80nSivsRA1JdaIOp7gER9CTDpLy3kBBdd9ZE+N3O8m7owKBpoor4QqCGy8DZ3PB4qX5oTulug3xSi1nmI7mSRuXOZ40StNLyMoGFzoIblnhA1sn5VOF5zVEwqCDWnkkR+lUSi1lqg9xAynxIkXRMWiHo4kKirYDqErV6jrgLHT49kIdHgJIGoWzhO1MrvFp4T9XAYUSesXaO+PND8inSivtxA1FdYIOrhQKK+HJj0VxRygouu+kifWzreTSWCooEm6gRQQ2ThbeV4PFS+tCJ0t0C/KUSt8xDdySJz50rHiVppeCVBw1ZADa/yhKiR9au14zVHxaQ1oea0IZFfGyJRay3QewiZT1eTdL3aAlEPAxL1NTAdIhGbRH0NOH56tC0kGtyWQNTtHCdq5Xc7z4l6GIyoKxMGcylEfW2g+XXpRH2tgaivs0DUw4BEfS0w6a8r5AQXXfWRPl/veDd1dVA00ER9NVBDZOFt73g8VL60J3S3QL8pRK3zEN3JInPnBseJWml4A0HD9kANb/SEqJH1q4PjNUfFpAOh5nQkkV9HIlFrLdB7CJlPnUi6drJA1HcDifommA5VVq9R3wSOnx6dC4kGdyYQdRfHiVr53cVzor4bRtTC2jXqmwPNb0kn6psNRH2LBaK+G0jUNwOT/pZCTnDRVR/pc1fHu6lOQdFAE3UnoIbIwtvN8XiofOlG6G6BflOIWuchupNF5s6tjhO10vBWgobdgBre5glRI+tXd8drjopJd0LN6UEivx5EotZaoPcQMp9uJ+l6uwWivgtI1HfAdIhaJeo7wPHTo2ch0eCeBKLu5ThRK797eU7Ud8GIusIaUfcONO+TTtS9DUTdxwJR3wUk6t7ApO9TyAkuuuojfe7reDd1e1A00ER9O1BDZOHt53g8VL70I3S3QL8pRK3zEN3JInOnv+NErTTsT9CwH1DDOz0hamT9GuB4zVExGUCoOQNJ5DeQSNRaC/QeQubTIJKugywQ9VAgUQ+G6RArs0nUg8Hx02NIIdHgIQSiHuo4USu/h3pO1ENhRB2PGcylEPVdgeZ3pxP1XQaivtsCUQ8FEvVdwKS/u5ATXPj3qECfhzneTQ0KigaaqAcBNUQW3uGOx0Ply3BCdwv0m0LUOg/RnSwyd+5xnKiVhvcQNBwO1PBeT4gaWb9GOF5zVExGEGrOSBL5jSQStdYCvYeQ+TSKpOsoC0Q9BEjU9+Gu0Fgl6vvA8dNjdCHR4NEEoh7jOFErv8d4TtRDYEQdtUbU9weaP5BO1PcbiPoBC0Q9BEjU9wOT/oFCTnDRVR/p81jHu6lRQdFAE/UooIbIwjvO8XiofBlH6G6BflOIWuchupNF5s6DjhO10vBBgobjgBo+5AlRI+vXeMdrjorJeELNmUAivwlEotZaoPcQMp8mknSdaIGoBwOJ+mHcNeqQTaJ+GBw/PSYVEg2eRCDqyY4TtfJ7sudEPRhG1GUhg7kUon4k0PzRdKJ+xEDUj1og6sFAon4EmPSPFnKCi676SJ8fc7ybmhgUDTRRTwRqiCy8UxyPh8qXKYTuFug3hah1HqI7WWTuPO44USsNHydoOAWo4ROeEDWyfj3peM1RMXmSUHOmkshvKpGotRboPYTMp2kkXadZIOpBQKJ+CtdPCptE/RQ4fnpMLyQaPJ1A1DMcJ2rl9wzPiXoQjKhLkwZzKUT9dKD5M+lE/bSBqJ+xQNSDgET9NDDpnynkBBdd9ZE+z3S8m5oWFA00UU8DaogsvLMcj4fKl1mE7hboN4WodR6iO1lk7jzrOFErDZ8laDgLqOFznhA1sn4973jNUTF5nlBzZpPIbzaRqLUW6D2EzKcXSLq+YIGoBwKJ+kXcPY9W3571Ijh+eswpJBo8h0DUcx0nauX3XM+JeiDuyWTW3p71UqD5y+lE/ZKBqF+2QNQDgUT9EjDpXy7kBBdd9ZE+v+J4N/VCUDTQRP0CUENk4Z3neDxUvswjdLdAvylErfMQ3ckic+dVx4laafgqQcN5QA1f84SokfXrdcdrjorJ64SaM59EfvOJRK21QO8hZD69QdL1DQtEPQBI1G/CdKiyeo36TXD89HirkGjwWwSifttxolZ+v+05UQ/AvT3L2jXqdwLN300n6ncMRP2uBaIeACTqd4BJ/24hJ7joqo/0+T3Hu6k3gqKBJuo3gBoiC+8Cx+Oh8mUBobsF+k0hap2H6E4WmTvvO07USsP3CRouAGr4gSdEjaxfHzpec1RMPiTUnIUk8ltIJGqtBXoPIfPpI5KuH1kg6juBRP0xTIdkiU2i/hgcPz0WFRINXkQg6sWOE7Xye7HnRH0njKhDFQZzKUT9SaD5p+lE/YmBqD+1QNR3Aon6E2DSf1rICS666iN9/szxbuqjoGigifojoIbIwrvE8XiofFlC6G6BflOIWuchupNF5s7njhO10vBzgoZLgBp+4QlRI+vXl47XHBWTLwk1ZymJ/JYSiVprgd5DyHz6iqTrVxaIuj+QqL+G6VBm9a7vr8Hx02NZIdHgZQSiXu44USu/l3tO1P1xv6O2dtf3N4Hm36YT9TcGov7WAlH3BxL1N8Ck/7aQE1x01Uf6vMLxbuqroGigiforoIbIwrvS8XiofFlJ6G6BflOIWuchupNF5s53jhO10vA7goYrgRqu8oSokfXre8drjorJ94Sas5pEfquJRK21QO8hZD79QNL1BwtE3Q9I1D/irlFbfdb3j+D46bGmkGjwGgJR/+Q4USu/f/KcqPvh7vq29qzvnwPNf0kn6p8NRP2LBaLuByTqn4FJ/0shJ7joqo/0+VfHu6kfgqKBJuofgBoiC+9ax+Oh8mUtobsF+k0hap2H6E4WmTu/OU7USsPfCBquBWr4uydEjaxf6xyvOSom6wg15w8S+f1BJGqtBXoPIfMpqxZHV3Vc9dcmXfYtwPryPztrEQ3eqhb+uNm13KZL5Xd2rb8FBh2X0kyoRFa2ojcxcOPR4+2qhki/a9Tyo5nIAvqcA8xBU96EMht/7pEatfD5mFuLW3NCmQ2h4pJLrjmZaphHahzy/oPGoQ+pccivRTQ4n9A41HS8cVB+1/SkcVCJXJOwiYEbjx5vVzVE+l3gSeOQB/S50PHGQflaQGgcajneOKi41CLXnEw1rE1qHGrX4l/D7w28hl8HuIdsNkt1anGapaJaRIOLCM1SsePNkvK72FKzFMpsiNqBrehLh7WBMULGu67jJ1BV6OoSTqBbO34CVT5vTfB7G9JJTx03/RYQtCbsmCH2eDGh6UHu920dz3ul4bYEDesCNdzOE9BCnnO2d/w8oWKyPaFe7kCqlzvU4l3u1Vqg9xAyn3Yk7SG0ljuCe2s90Hv9ViAQ7pTis4hHwuFYRP138URIRBOV4Xg4nKiIhipD5ZXhqrKoKEtGw9FIZaKyQh6zXCRDyfLKsmT8r2PZBMKdSEC4cy2iwTsTgHAXx4FQ+b0LAQhVsqmZncVPtlsLOAUsXZNMN2BqIu+a+s0U+ky5C7BDSD1T7vovZ8qN2Fy5EXH+3Ci7bsGZcmOi7wrcgLuROhB13Ju3MBeE1K5ShJKhsnCoPBSrLI1VlCXCFfHyZCRZEklEtlTXjSU7UtfdSbruvuW6/n+Rr3uQdN3j/3i+1iPpWi/QVZ84bXRqyJNn6sm+ftBU7KnOGYwT3K6Ebm1Xx7/W2tLNEdoMvzO1cS/Hv9ZSibkX4euJvUlFYe9/KbahzIbYk6TFPiQt9iFqoQohQ4s9znK7prD2Q73/1u/KjdhHy/36YL/1QP+KF5iXAhhrgdRPNVJ5WeZvIbI2U8+N5VPqMRnnLJQmqU3lvv/2LUQosyH2Ip0E9t3y7+vFxv7vKJv3ZZwQSUUhZzNjtjnNW6Y+71fLzQKDjEVqXu6X0pxsaXw2pjkyPvunXluIROTeSMREMpGMlMTKwhWiNFJamowmY6XxaCJZEi1PxKpEtDwSLquKhZIiXlUVK4lUxkqTZYnK0mRq0RaJSCSaKKuoFCXh0vKKUDwRKQ8lo7GIBP5EJJZIROKlpeWRSKI0noyXSUiX6B8PlcRiZaHScKQszIrP/il0jTopbOzbnNRj+nJSOMDHk8IB5JPCAYSTwn6OnBT+MYljfz6kJYksOgc6elLYj1R0DgScFDb21SYyPgc5elJgxeeg/4++cj04+Mr1ENNXrqHMxj9e70Beq8z0WMCvbyl3RmkN0Xc0szTM9FiHOh4PtWEOJZzYDyM1OYcRv/48hKTF4SQtDid/FczQ4gDHvwpm7YcDHf8qmJX7B3nyVTAwLwUw1uKg6q+C08ef5yyUJqnNbohJ/YeSTgIhIvUrm0OM5sCTr4IPBTaCopabBeYwElUKC18FI+MTBlL/QUDqZ8UnbIjP5t5Ts7GvfpHxiZDqZwSgw8a+nULqECXpEPUsH0pIOpR4lg+lJB1KN+FSkcuNncFcWB6nNo0xH5vGGLlpjBGaxpClpjHDu+KhRS6OvOwEbBpDpKYkvglNY6Z31yPjU1YL1+ghm0ZWfMoAJ8eNDDEB+NvRI2D1M065EXuX4Fs39BUlZI4f6fgVDBXjIwnnm6NI51513JrBv3fJ2nCg/m/q46H1bpLtvo1HoxtJX5I27PjlFeXz0QS/I458o7iRsV5iZurzMcDCDMwbgYwFuUj+7zLF/8Uiecz/1SJ5rOM/z1M+H0vw+zhSR3Ncrb+ftsb4uaepQw5lNgSyQz7e8XxSRHU8IZ9O8GAfnUDw+0TSPjrxX/ZRKLNBqymlZ/3fzIGYpftaMrXzJGCTCIy1iJG+oTqpmq7pNp7MbhwRlHkyYdMf4QllnuzBps84xp4U4FOAsQDmnziymtK9KLan1OLkObw4ngpMdF/P3qfWct/G05A2+hqoSz3Y+af7svPPwBka8TWhzvBg55/pS0I1wBka9TWhGniQUGf5klBn4wwt8TWhzvYgoRr6klDn4Awt9TWhzvEgoc71JaHOwxka8zWhzvMgoRr5klDn4wyN+5pQ53uQUBf4klCNcYaW+ZpQjT1IqCa+JNSFOEPLfU2oCz1IqIt8SaiLcYZW+JpQF3uQUE19SahLcIZW+ppQl3iQUJf6klDNcIYmfE2oZh4kVHNfEuoynKFVvibUZR4kVHn1RdeQmOjBRdcKX3Z+JcxQEfI1oSo92PkJXxKqCpdQ3t6/U+VBQiV9SagWuIQK+5pQLTxIqMt9SagrcAnl7X1GV3iQUC19SahWuITy9j6jVh4k1JW+JNRVuITy9j6jqzxIqNa+JFQbXEJ5e59RGw8S6mpfEuoaXEJ5e5/RNR4kVFtfEqodLqG8vc+onQcJda0vCXUdLqG8vc/oOg8S6npfEqo9LqG8vc+ovQcJdYMvCXUjLqG8vc/oRg8SqoMvCdURl1De3mfU0YOE6uRLQt2ESyhv7zO6yYOE6uxLQnXBJZS39xl18SChbvYloW7BJVTS14S6xYOE6oq0Ub1LJj/r72csKWP3TAtaNtgB4MNexQkeBOw0D2w83QMbz/TAxrM8sLGhBzae64GNjTyw8QIPbGzigY0XeWBjUw9svNQDG5t7YGO5BzZWeGBjwgMbkx7YeLkHNrb0wMYrPbCxtQc2Xu2BjW09sPFaD2y83gMbb/DAxg4e2NjJAxs7e2DjzR7Y2JVgYxbUxkgsyzAwxw4L3rFDoeyUmOljdpN63yrnbXJ2l7OHnLfLeYecPeXsJWdvOfvI2VfOfnL2l/NOOQfIOVDOQXIOlnOInEPlvEvOu+UcJudwOe+R8145R8g5Us5Rct4n52g5x8h5v5wPyDlWznFyPijnQ3KOl3OCnBPlfFjOSXJOlvMROR+V8zE5p8j5uJxPyPmknFPlnCbnU3JOl3OGnE/L+YycM+WcJeezcj4n5/O1/tJgdq1AFP32EiVKzbS1Ww1rtxnWuhvWehjWbjes3WFY62lY62VY621Y62NY62tY62dY629Yu9OwNsCwNtCwNsiwNtiwNsSwNtSwdpdh7W7D2jDD2nDD2j2GtXsNayMMayMNa6MMa/cZ1kYb1u43rD1gWBtrWBtnWHvQsPaQYW28YW2CYW2iYe1hw9okw9pkw9ojhrVHDWuPGdamGNYeN6w9YVh70rA21bA2zbD2lGFtumFthmHtacPaM4a1mYa1WYa1Zw1rzxnWnjesqeJXP2v9gX75SurFP4fedie61eI0G9lg/YAXE8WtnvgMvDgpbvPEZ+DFTtHdE5+BF09FD098Bl6MFbd74jPw4q64wxOfgReLRU9PfAZefBa9PPEZeDFb9PbEZ+DFcdHHE5+BF9tFX098Bl68F/088Rl4M4Do74nPwJsLxJ2e+Ay8WUEM8MRn4M0PYqAnPgNvphCDPPEZeHOGGOyJz8CbPcQQT3wG3jwihnriM/BmFHGXJz4Db24Rd3viM/BmGTHME5+BN9+I4Z74DLyZR9zjic/Am4PEvZ74DLzZSIzwxGfgzUtipCc+A2+GEqM88Rl4c5W4zxOfgTdridEkn7dK8zmU2RBjANeyq5JqVJarH+LWTInLVil2suxnXPNG21j941mMjdU/nsXYWP3jWYyN1T+exdhY/eNZjI3VP57F2Fj941mMjdU/nsXYWP3jWYyN1T+exdhY/eNZjI3VP57F2Fj941mMjdU/nsXYWP3jWYyNPv54FnPcOE3TBzyI+1gPbBzngY0PemDjQx7YON4DGyd4YONED2x82AMbJ3lg42QPbHzEAxsf9cDGxzywcYoHNj7ugY1PeGDjkx7YONUDG6d5YONTHtg43QMbZ3hg49Me2PiMBzbO9MDGWR7Y+KwHNj7ngY3PE7/nw9kZDpvua3xB2v6inHPknCvnS3K+LOcrcs6T81U5X5PzdTnny/mGnG/K+Zacb8v5jpzvyvmenAvkfF/OD+T8UM6Fcn4k58dyLpJzsZyfyPmpnJ/JuUTOz+X8Qs4v5Vwq51dyfi3nMjmXy/mNnN/KuULOlXJ+J+cqOb+Xc7WcP8j5o5xr5PxJzp/l/EXOX+VcK+dvcv4u5zo5/5Azq7b0X85sOWvU/kuDnNpZ6z+ESYmS/mCmFw1rcwxrcw1rLxnWXjasvWJYm2dYe9Ww9pph7XXD2nzD2huGtTcNa28Z1t42rL1jWHvXsPaeYW2BYe19w9oHhrUPDWsLDWsfGdY+NqwtMqwtNqx9Ylj71LD2mWFtiWHtS8PaUsPaV4a1rw1rywxryw1r3xjWvjWsrTCsrTSsfWdYW2VY+96wttqw9oNh7UfD2hrD2k+GtZ8Na78Y1n41rK01rP1mWPvdsLbOsPaHYU0Vq/S1rQxr2Ya1GoY1VejqZ60/9EnhuOBvpj9CAN7QLl4gnVjRPiMfCPeiJz4jHwg3xxOfkQ+Em+uJz8gHwr3kic/IB8K97InPyAfCveKJz8gHws3zxGfkA+Fe9cRn5APhXvPEZ+QD4V73xGfkA+Hme+Iz8oFwb3jiM/KBcG964jPygXBveeIz8oFwb3viM/KBcO944jPygXDveuIz8oFw73niM/KBcAs88Rn5QLj3PfEZ+UC4DzzxGflAuA898Rn5QLiFnviMfCDcR574jHwg3Mee+Ix8INwiT3xGPhBusSc+Ix8I94knPiMfCPepJz4jHwj3mSc+Ix8It4Tk81ZpPocyG+LzWpnrpx8Ix7TzC5idccHMIeAPLsWXnuwb4A84xVJPfAb+IFR85YnPwB+Yiq898Rn4g1WxzBOfgT+AFcs98Rn4g1rxjSc+A3+gK771xGfgD37FCk98Bv6AWKz0xGfgD5LFd574DPyBs1jlic/AH0yL7z3xGfgDbLHaE5+BP+gWP3jiM/AH4uJHT3wG/uBcrPHEZ+AP2MVPnvgM/EG8+NkTn4E/sBe/eOIz8Af74ldPfAY+AECs9cRn4AMFxG+e+Ax8QIH43ROfgQ88EOs88Rn4AAXxhyc+Ax/IINTvMn3wGfiAB7GVJz4DHxghsj3xGfgAClED6LN6oVZB1l+/P1ZjqxSfs1LWUrUIZTaqX6gFsrH6hVoYG6tfqIWxsfqFWhgbq1+ohbGx+oVaGBurX6iFsbH6hVoYG6tfqIWxsfqFWhgbq1+ohbGx+oVaGBurX6iFsbH6hVoYG6tfqIWxsfqFWojjVr9Qi2Fj9Qu1MDZWv1ALY2P1C7UwNla/UAtjY/ULtTA2Vr9QC2Nj9Qu1MDZWv1ALY2P1C7UwNla/UAtjY/ULtTA2Vr9QC2Nj9Qu1MDZWv1ALY6MvL9QiHltslaKtPmZu7aysPDnz1btd5CyQs1DOWnLWlrOOnEVyFstZV86t5dxGzm3l3E7O7eXcQc4d5dxJzp3l3EXOXeXcTc7d5dxDznrqPTFy7innXnLuLec+cu4r535y7i/nAXIeKOdBch4s5yFyHirnYXIeLmdITiFnWM6InFE5S+QslTMmZ1zOMjmPkPNIOY+S82g5j5HzWHUPqpzHy3mCnCfKeVL6S7pyDS+4yTOs5RvWahrWCgxrhYa1Woa12oa1Ooa1IsNasWGtrmFta8PaNoa1bQ1r2xnWtjes7WBY29GwtpNhbWfD2i6GtV0Na7sZ1nY3rO1hWKtnWKtvWNvTsLaXYW1vw9o+hrWjDWvHGNaONawdZ1g73rB2gmHtRMPaScFa6sgO/h4X/HXpxU65ntxYj3yxU54nPiNf7JTvic/IFzvV9MRn5IudCjzxGflip0JPfEa+2KmWJz4jX+xU2xOfkS92quOJz8gXOxV54jPyxU7FnviMfLFTXU98Rr7YaWtPfEa+2GkbT3xGvthpW098Rr7YaTtPfEa+2Gl7T3xGvthpB098Rr7YaUdPfEa+2GknT3xGvthpZ098Rr7YaRdPfEa+2GlXT3xGvthpN098Rr7YaXdPfEa+2GkPT3xGvtipnic+I1/sVN8Tn5EvdtrTE5+RL3bayxOfkS922tsTn5EvdtqH5DP6pqB9a2eun40XO+0Hs3P9Fzuh7dzfk7gf4ImdB3pi50Ge2HmwJ3Ye4omdh3pi52Ge2Hm4J3aGPLFTeGJn2BM7I57YGfXEzhJP7Cz1xM6YJ3bGPbGzzBM7j/DEziM9sfMokp05mdop1v/n0ZnZud7RjsnU55SjHQvgdf29zDFnORqL0PpeH4fImeBox2Py78+jnQCMxbFuxyKkvT4Rt3/FScBjAXNZpMYio+/EqpJl6qUCdbL+/k6VEhtybocyGe7mDOPHlv+rWanxPrn2X39PSf9RoPofFqWtqf+oflZ1omRaUE/woaCmJfQW+hwOfBYnA/U7BbhpWbHIBscCqd+phmNVhCoTJaKiNBETVeUl8crKsogQ4fLS8tKKcDxZVVEi4iVxeczK8nBc/p8Ll1eKqlB5aZU6iejakT7QDfqpwAKbau9ptYkGq4Ojj3s6MBlYfp9e+2+BQcc12oooJspW1Ib9368/gTE6A5z4+oSujrun/GuzEzwaeII/BniCPxZ4UjmuNuekAtpPxk7wzGC/NkjvBM80dIINmJ1gYORxwO7jTOBmbJByrHCipCpUFq+IhyvKI7GKaKSirKxcHrdUiHgyEQ4louFkiSgtrSyrKkuKSLKipKq8tKS8rDTx59kzcYwn3QdSv7M87T7OInUfZ9cmGnw2ofto6Hj3ofxu6En30SCwFd19IGN0Dqn7OOc/6D5A97L+eTTYPaICe+8l8+H+gFgYu49zg/16Xnr3ca6h+zjPwvdQPiRKphv7JE++h+paC9cJngssjOchvzz2pBNE6tfI006wEakTPL820eDzCZ3gBY53gsrvCzzpBM8LbEV3gsgYNSZ1go3/g07wWuAJ/nrgCR75q7oOHnaCTYL9emF6J9jE0AleaKET9CFRMv4S3JNOsAOwE2wCLIwXAjvBUzzpBJH6XeRpJ3gRqRO8uDbR4IsJnWBTxztB5XdTTzrBCwNb0Z0gMkaXkDrBS/6DTvBK4Am+NfAEj3xeSlsPO8FLg/3aLL0TvNTQCTaz0An6kCgZP6jbk06wLbATvBRYGJsBO8HTPOkEkfo197QTbE7qBC+rTTT4MkInWO54J6j8LvekE2wW2IruBJExqiB1ghX/QSeYAJ7gk8ATPPJJmC097AQrg/2aSO8EKw2dYMJCJ+hDomR806knnWBLYCdYCSyMCWAneIYnnSBSvypPO8EqUieYrE00OEnoBFs43gkqv1t40gkmAlvRnSAyRpeTOsHL/4NO8FLgCb458ASPfMdBhYed4BXBfm2Z3gleYegEW1roBH1IlIxvUvakE6wAdoJXAAtjS2An2MCTThCpXytPO8FWpE7wytpEg68kdIJXOd4JKr+v8qQTbBnYiu4EkTFqTeoEW/8HneAFwBN8E+AJHvn2uqYedoJtgv16dXon2MbQCV5toRP0IVEy3dhne9IJNgV2gm2AhfFqYCd4tiedIFK/azztBK8hdYJtaxMNbkvoBNs53gkqv9t50gleHdiK7gSRMbqW1Ale+x90gmcBT/ANgSd45HvJG3nYCV4X7Nfr0zvB6wyd4PUWOkEfEiXjhwJ40gk2AnaC1wEL4/XATvAcTzpBpH7tPe0E25M6wRtqEw2+gdAJ3uh4J6j8vtGTTvD6wFZ0J4iMUQdSJ9jBZicYnJRPA56UTwd2b2fWwjUx3TzsBDsG+7VTeifY0dAJdmJ2gh4lSsYPLnC9EzQkdKadYEdgYewE7ATP86QTROp3k6ed4E2kTrBzbaLBnQmdYBfHO0HldxdPOsFOga3oThAZo5tJneDNQSeYOtD63gKwPRKL//mXaWdXgJ2l5aGyqtLSGNPObgA7KypKY+VV8RKmnbci4l5ZWpWMxMJMO28D2FleEk0mSyLlTDu7A+wsEaGqknAsybSzB8DOsopQSWk8Xsm083aAnSIZjyTKyiuYdt6BiHtFlWzvRJmybces9WEu9Sv+1Bs/Um8HTv2RWOqjA1IfKKU+n5fy+ZaUz02yt/xzg5TjnJLyuWvK524pn29N+XxbyufuKZ97pHy+PeXzHcHnnvJvLzl7y9lHzr5y9pOzv5x31t7wGxN0/3Qn8HyvoXCAPOZAOQfJOTjo2FN7AfW/18xaf22gYW2QYW1wsJY60Jcl7gT2UwMAx/rznWDJkBgItOt8EozWSItFJj6rWAyC6PdXXAcDYR6pH3uP9yfs8SHymEPlvEvOuw17fIhh7w41rN1lWLvbwh7vD9xLQ4B7fCjQrsae7PG7gHv8buAeb+zRHu9H2OPD5DGHy3mPnPca9vgww94dbli7x7B2r4U93g+4l4YB9/hwoF0XerLH7wHu8XuBe/xCj/Z4X8IeHyGPOVLOUXLeZ9jjIwx7d6RhbZRh7T4Le7wvcC+NAO7xkUC7LvZkj48C7vH7gHv8Yo/2eB/CHh8tjzlGzvvlfMCwx0cb9u4Yw9r9hrUHLOzxPsC9NBq4x8cA7brEkz1+P3CPPwDc45d4tMd7E/b4WHnMcXI+KOdDhj0+1rB3xxnWHjSsPWRhj/cG7qWxwD0+DmhXM0/2+IPAPf4QcI8382iP9yLs8fHymBPknCjnw4Y9Pt6wdycY1iYa1h62sMd7AffSeOAenwC06zJP9vhE4B5/GLjHL/Noj/ck7PFJ8piT5XxEzkcNe3ySYe9ONqw9Ylh71MIe7wncS5OAe3wy0K4KT/b4I8A9/ihwj1d4tMe3wh0rVD84zmNSyylyPi7nE3I+KedUOafJ+ZSc0+WcIefTcj4j50w5Z8n5rJzPyfm8nLPlfEHOF+WcI+dcOV+S82U5X5FznpyvyvmanK/LOV/ON+R801BTHjPUiimGtccNa08Y1p40rE01rE0zrD1lWJtuWJthWHvasPaMYW2mYW2WYe1Zw9pzhrXnDWuzDWsvGNZeNKzNMazNNay9ZFh72bD2imFtnmHtVcPaa4a11w1r8w1rbxjW3rRwDkrds5nW+seA56ApwHNQwtIPOzI9Bz0OPAc9kfmx/vcjkSeBsahyORbR/9kppmbmcyjFZzEtk2OF19NPPAWMRdLNWITS7BTTt9Dn0uQGPosZW3asuEE/8TQwFi1ci0XcaKd4ZvN9jv2Dz2Lm5h4r9o/6iVnAWFzuTizC/2KneHZzfI79q8/iuU0/VuVG9BPPA2NxhQuxiG3UTjF703wObYLP4oVNOVZok/QTLwJj0fK/jUXJJtop5mzM5+gm+yzm/uuxosnN0E+8BIxFq/8qFrHNslO8/M8+xzfTZ/HKPxyrLLnZ+ol5wFhcaT8WoS2wU7xq8jm0RT6L1zY8lthC/cTrwFhcZTMWiS22U8xf3+dIBj6LN1KOFU5mpJ94ExiL1p48Wgv4/YAA8q1I5bNMY9HGk1gAOUgA+3hxBTAWV/vyQjKgfsB+RVwJjMU1nsQCeF4TwLos2gBj0dbStcJQZkMA968A5p9g6Zedpl+mcUb2GG/BrrVGQjYfmoOze/2H5rxdm2iwOjj6uO8Ak4Hl9zu1/xYYdNzQvz3mD+3Dm7BkSzAegRdYuf4NCu8Gmr+nd6S+KvpukISpa+8ZrpSiqz6iaumrm+8Ck/49cHAZG/xdQ+HI1O93a/txtnsDGOsFMJ9LozbPdgtIZ7v3axMNfp9wtvvA8bOd8vsDz892b8CSrazSYC7lbPdhoPnC9LPdh4az3UILZ7s3gGe7D4FJv5AUXHTVR/r8Ea56iqws/Jn4naBoZINzEIkGH4O7BXTRUjH+mNAlue63zh2034s86Q6ROb6YXCdCmQ2hYrKYUCc+Bmr4iQf75RPCfvkU3KHrXuXTFFtZWqDzaTEwnz4j6fpZ7Q3JDV2b5gN1WALTIWr14eZLwPHT4/PaRIM/J5DrF46Tq/L7C8/JdT4s2SrCBnMp5PploPnSdHL90kCuSy2QK6JqaXL9Epj0S0nBRVd9pM9fOd6RfhYUDdSvSU1n/UyPhSy8XzseD5UvXxO6W6DflLdd6DxEd7LI3FnmOBkpDZcRNPwaqOFyT76VQNavbxyvOSom3xBqzrck8vuWSNRaC/QeQubTCpKuKywQNfJO95UwHWJhm0S9Ehw/Pb6rTTT4OwJRr3KcqJXfqzwn6tdhyRavMphLIervA81XpxP19waiXm2BqBFVSxP198CkX00KLrrqI33+wfFuakVQNNBEvQKoIbLw/uh4PFS+/EjoboF+U4ha5yG6k0XmzhrHiVppuIag4Y9ADX/yhKiR9etnx2uOisnPhJrzC4n8fiEStdYCvYeQ+fQrSddfLRD1a0Ad1sJ0qBI2iXotOH56/FabaPBvBKL+3XGiVn7/7jlRvwZLNpE0mEsh6nWB5n+kE/U6A1H/YYGoEVVLE/U6YNL/QQouuuojfVY7BxXXrCz8hvs1KBpoov4VqCGy8G7leDxUvigb0d0t0G8KUes8RHeyyNzJJmsYymz8uZeVjWgNU3MnUw1rgDXUA30OQNavHMdrjopJDqHm5AJjndpD5dbhEbXWAr2HkPmUR9I1rw6fqF8F6pAP0yFilajzwfHTo2YdosE16+CPWwA8sbD8Lqjzt8Cg41ol6ldh0FVpjagLA81r1clan54L62xI1Oo/YhP1q0CiLgQmfa06nOCiqz7S59qOd1N5QdFAE3UeUENk4a3jeDxUvtQhdLdAvylErfMQ3ckic6fIcaJWGhYRNKwD1LDYE6JG1q+6jtccFZO6hJqzNYn8tiYStdYCvYeQ+bQNSddtLBA18lnz28J0KLf6vMttwfHTY7s6RIO3IxD19o4TtfJ7e8+Jeh6MqEutPe9yh0DzHdOJegcDUe9ogajnAYl6B2DS71iHE1x01Uf6vJPj3dQ2QdFAE/U2QA2RhXdnx+Oh8mVnQncL9JtC1DoP0Z0sMnd2cZyolYa7EDTcGajhrp4QNbJ+7eZ4zVEx2Y1Qc3Ynkd/uRKLWWqD3EDKf9iDpuocFon4FSNT1YDqEy2wSdT1w/PSoX4docH0CUe/pOFErv/f0nKhfgRF1ImYwl0LUewWa751O1HsZiHpvC0T9CpCo9wIm/d51OMFFV32kz/s43k3tERQNNFHvAdQQWXj3dTweKl/2JXS3QL8pRK3zEN3JInNnP8eJWmm4H0HDfYEa7u8JUSPr1wGO1xwVkwMINedAEvkdSCRqrQV6DyHz6SCSrgdZIOqXgUR9MEyHirhNoj4YHD89DqlDNPgQAlEf6jhRK78P9ZyoX4YRdTRuMJdC1IcFmh+eTtSHGYj6cAtE/TKQqA8DJv3hdTjBRVd9pM8hx7upg4KigSbqg4AaIguvcDweKl8EobsF+k0hap2H6E4WmTthx4laaRgmaCiAGkY8IWpk/Yo6XnNUTKKEmlNCIr8SIlFrLdB7CJlPpSRdSy0Q9UtAoo7BdCixetd3DBw/PeJ1iAbHCURd5jhRK7/LPCfql3AvWLJ21/cRgeZHphP1EQaiPtICUb8EJOojgEl/ZB1OcNFVH+nzUY53U6VB0UATdSlQQ2ThPdrxeKh8OZrQ3QL9phC1zkN0J4vMnWMcJ2ql4TEEDY8GanisJ0SNrF/HOV5z/owJoeYcTyK/44lErbVA7yFkPp1A0vUEC0Q9F0jUJ+Ku0JTYJOoTwfHT46Q6RINPIhD1yY4TtfL7ZM+Jei6OqCsM5lKI+pRA81PTifoUA1GfaoGo5wKJ+hRg0p9ahxNcdNVH+nya493UCUHRQBP1CUANkYX3dMfjofLldEJ3C/SbQtQ6D9GdLDJ3znCcqJWGZxA0PB2o4ZmeEDWyfjVwvOaomDQg1JyzSOR3FpGotRboPYTMp7NJup5tgajnAIm6Ia6fLLVJ1A3B8dPjnDpEg88hEPW5jhO18vtcz4l6Du6u73KDuRSiPi/QvFE6UZ9nIOpGFoh6DpCozwMmfaM6nOCiqz7S5/Md76bODooGmqjPBmqILLwXOB4PlS8XELpboN8UotZ5iO5kkbnT2HGiVho2Jmh4AVDDJp4QNbJ+Xeh4zVExuZBQcy4ikd9FRKLWWqD3EDKfLibperEFon4RSNRNYTrErb49qyk4fnpcUodo8CUEor7UcaJWfl/qOVG/CCPqmLW3ZzULNG+eTtTNDETd3AJRvwgk6mbApG9ehxNcdNVH+nyZ493UxUHRQBP1xUANkYW33PF4qHwpJ3S3QL8pRK3zEN3JInOnwnGiVhpWEDQsB2pY6QlRI+tXwvGao2KSINScKhL5VRGJWmuB3kPIfEqSdE1aIOoXgETdwlOibgGOnx6X1yEafDmBqK9wnKiV31d4TtQveEjULQPNW6UTdUsDUbeyQNQvAIm6JTDpW3lC1Eifr3S8m0oGRQNN1EmghsjCe5Xj8VD5chWhuwX6TSFqnYfoThaZO60dJ2qlYWuChlcBNWzjCVEj69fVjtccFZOrCTXnGhL5XUMkaq0Feg8h86ktSde2Foh6NpCo28F0KLH6rO924PjpcW0dosHXEoj6OseJWvl9nedEPRtG1OXWnvV9faB5+3Sivt5A1O0tEPVsIFFfD0z69nU4wUVXfaTPNzjeTbUNigaaqNsCNUQW3hsdj4fKlxsJ3S3QbwpR6zxEd7LI3OngOFErDTsQNLwRqGFHT4gaWb86OV5zVEw6EWrOTSTyu4lI1FoL9B5C5lNnkq6dLRD180Ci7oIj6oRNou4Cjp8eN9chGnwzgahvcZyold+3eE7Uz+OIOmIwl0LUXQPNu6UTdVcDUXezQNTPA4m6KzDpu9XhBBdd9ZE+3+p4N9U5KBpoou4M1BBZeG9zPB4qX24jdLdAvylErfMQ3ckic6e740StNOxO0PA2oIY9PCFqZP263fGao2JyO6Hm3EEivzuIRK21QO8hZD71JOna0wJRPwck6l4wHcJWr1H3AsdPj951iAb3JhB1H8eJWvndx3Oifg5G1Alr16j7Bpr3Syfqvgai7meBqJ8DEnVfYNL3q8MJLrrqI33u73g31TMoGmii7gnUEFl473Q8Hipf7iR0t0C/KUSt8xDdySJzZ4DjRK00HEDQ8E6ghgM9IWpk/RrkeM1RMRlEqDmDSeQ3mEjUWgv0HkLm0xCSrkMsEPWzQKIeCtMhErFJ1EPB8dPjrjpEg+8iEPXdjhO18vtuz4n6WRhRVyYM5lKIelig+fB0oh5mIOrhFoj6WSBRDwMm/fA6nOCiqz7S53sc76aGBEUDTdRDgBoiC++9jsdD5cu9hO4W6DeFqHUeojtZZO6McJyolYYjCBreC9RwpCdEjaxfoxyvOSomowg15z4S+d1HJGqtBXoPIfNpNEnX0RaIehaQqMfAdKiyeo16DDh+etxfh2jw/QSifsBxolZ+P+A5Uc+CEbWwdo16bKD5uHSiHmsg6nEWiHoWkKjHApN+XB1OcNFVH+nzg453U6ODooEm6tFADZGF9yHH46Hy5SFCdwv0m0LUOg/RnSwyd8Y7TtRKw/EEDR8CajjBE6JG1q+JjtccFZOJhJrzMIn8HiYStdYCvYeQ+TSJpOskC0Q9E0jUk2E6RK0S9WRw/PR4pA7R4EcIRP2o40St/H7Uc6KeCSPqCmtE/Vig+ZR0on7MQNRTLBD1TCBRPwZM+il1OMFFV32kz4873k1NCooGmqgnATVEFt4nHI+HypcnCN0t0G8KUes8RHeyyNx50nGiVho+SdDwCaCGUz0hamT9muZ4zVExmUaoOU+RyO8pIlFrLdB7CJlP00m6TrdA1M8AiXoGTIdYmU2ingGOnx5P1yEa/DSBqJ9xnKiV3894TtTPwIg6HjOYSyHqmYHms9KJeqaBqGdZIOpngEQ9E5j0s+pwggv/HhXo87OOd1PTg6KBJurpQA2Rhfc5x+Oh8uU5QncL9JtC1DoP0Z0sMneed5yolYbPEzR8DqjhbE+IGlm/XnC85qiYvECoOS+SyO9FIlFrLdB7CJlPc0i6zrFA1E8DiXou7gqNVaKeC46fHi/VIRr8EoGoX3acqJXfL3tO1E/DiDpqjahfCTSfl07UrxiIep4Fon4aSNSvAJN+Xh1OcNFVH+nzq453U3OCooEm6jlADZGF9zXH46Hy5TVCdwv0m0LUOg/RnSwyd153nKiVhq8TNHwNqOF8T4gaWb/ecLzmqJi8Qag5b5LI700iUWst0HsImU9vkXR9ywJRzwAS9du4a9Qhm0T9Njh+erxTh2jwOwSiftdxolZ+v+s5Uc+AEXVZyGAuhajfCzRfkE7U7xmIeoEFop4BJOr3gEm/oA4nuOiqj/T5fce7qbeCooEm6reAGiIL7weOx0PlyweE7hboN4WodR6iO1lk7nzoOFErDT8kaPgBUMOFnhA1sn595HjNUTH5iFBzPiaR38dEotZaoPcQMp8WkXRdZIGopwOJejGunxQ2iXoxOH56fFKHaPAnBKL+1HGiVn5/6jlRT4cRdWnSYC6FqD8LNF+STtSfGYh6iQWing4k6s+ASb+kDie46KqP9Plzx7upRUHRQBP1IqCGyML7hePxUPnyBaG7BfpNIWqdh+hOFpk7XzpO1ErDLwkafgHUcKknRI2sX185XnNUTL4i1JyvSeT3NZGotRboPYTMp2UkXZdZIOqngES9HHfPo9W3Zy0Hx0+Pb+oQDf6GQNTfOk7Uyu9vPSfqp3BPJrP29qwVgeYr04l6hYGoV1og6qeARL0CmPQr63CCi676SJ+/c7ybWhYUDTRRLwNqiCy8qxyPh8qXVYTuFug3hah1HqI7WWTufO84USsNvydouAqo4WpPiBpZv35wvOaomPxAqDk/ksjvRyJRay3QewiZT2tIuq6xQNTTgET9E0yHKqvXqH8Cx0+Pn+sQDf6ZQNS/OE7Uyu9fPCfqabi3Z1m7Rv1roPnadKL+1UDUay0Q9TQgUf8KTPq1dTjBRVd9pM+/Od5NrQmKBpqo1wA1RBbe3x2Ph8qX3wndLdBvClHrPER3ssjcWec4USsN1xE0/B2o4R+eEDWyfmUVuV1zVEyUjeg9vRXO7/XIb6siHlFrLdB7CJlP2SRds4v4RD0VSNQ1YDokS2wSdQ1w/PTIKSIanFOEP25ukdtErfzOLfpbYNBxrRL1VBhRhyoM5lKIOi/QPL8oa316zivakKjVf8Qm6qlAos4DJn1+ESe46KqP9Lmm491UdlA00ESdDdQQWXgLHI+HypcCQncL9JtC1DoP0Z0sMncKyRqGMht/7uVCgoYFQA1rgTXUA30OQNav2o7XHBWT2oSaU4dEfnWIRK21QO8hZD4VkXQtskDUTwKJuhimQ5nVu76LwfHTo24R0eC6BKLe2nGiVn5v7TlRP4n7HbW1u763CTTfNp2otzEQ9bYWiPpJIFFvA0z6bYs4wUVXfaTP2zneTRUFRQNN1EVADZGFd3vH46HyZXtCdwv0m0LUOg/RnSwyd3ZwnKiVhjsQNNweqOGOnhA1sn7t5HjNUTHZiVBzdiaR385EotZaoPcQMp92Iem6iwWifgJI1LvirlFbfdb3ruD46bFbEdHg3QhEvbvjRK383t1zon4Cd9e3tWd97xFoXi+dqPcwEHU9C0T9BJCo9wAmfb0iTnDRVR/pc33Hu6ldgqKBJupdgBoiC++ejsdD5cuehO4W6DeFqHUeojtZZO7s5ThRKw33Imi4J1DDvT0hamT92sfxmqNisg+h5uxLIr99iUSttUDvIWQ+7UfSdb9AV5t0+XhtrC967F9ENHh/Al0e4DhdKr8PINClyVbEBjmAsImBG48eb1c1RPp9oCfNxH5Anw9yvJlQvh5IaCYOdrz5VnE5mFxzMtXwEFLjcMh/0DhMITUOhxYRDT6U0Dgc5njjoPw+zJPGQSXyYYRNDNx49Hi7qiHS78M9aRwOAfoccrxxUL4eTmgchOONg4qLINecTDUMkxqHsIVr+I8Br+FHgHvIZrMUKeI0S9EiosFRQrNU4nizpPwusdQshTIbIhzYir50GAbGCBnvUsdPoKrQlRJOoDHHT6DK5xjB7zjppBc33AKC1oQdM8QeLyE0Pcj9XuZ43isNywgalgI1PMIT0EKec450/DyhYnIkoV4eRaqXRxEv92ot0HsImU9Hk/YQWsujgT5r2+qn2Ppm7b/Om+rzGymf56d8fj3l82spn19N+Twv5fMrKZ9fTvn8UsrnuSmf56R8fjHl8wspn2enfH4+5fNzKZ+fTfk8K+XzzJTPz6R8fjrl84yUz9NTPj+V8nlayuepKZ+fTPn8RMrnx1M+T0n5/FjK5/tSPo9K+Twy5fOIlM/3pny+J+Xz8JTPw1I+353y+a6Uz0NTPg9J+Tw45fOglM8DUz4PSPn8aMrnR1I+T075PCnl88MpnyemfJ6Q8nl8yueHUj4/mPJ5XMrnsSmfH0j5fH/K5zEpn0cHn/XGPUbusWPVPpPzeDlPkPNEOU+S82Q5T5HzVDlPk/N0Oc+Q80w5G8h5lpxny9lQznPkPFfO8+RsJOf5cl4gZ2M5m8h5oZwXyXmxnE3lvETOS+VsJmdzOS+Ts1zOCjkr5UzIWSVnUs4Wcl4u5xVytpSzlZxXynlVUMdrZf3NjH/mrSy+63Q+p3yekf3X3+yU//aGgr//9xuDz63lcdvIeXXRX1egbN2rfjWpLmdh7QynanFN8N1C26JAEH2SVf/D72kGoO9LvxpwgvjrvvRk8hrgyaatpSY1lNkQSJ/bpRxLxCPhcCyi/rt4IiSiicpwPBxOVERDlaHyynBVWVSUJaPhaKQyUVkhj1kukqFkeWVZMv6XXTa/yWxH+ibz2iKiwdcSvsm8zvFvMpXf1xX9LTDouJRvI9oGtqKPez2JiK4v2vAMh44fsiiybW0NtLV+cJz28pg3yHmjnB3k7ChnJzlvkrOznF3kvFnOW+TsKmc3OW+V8zY5u8vZQ87b5bxDzp5y9pKzt5x95OwrZz85+8t5p5wD5Bwo5yA5B8s5JDg7p8a8fdHfXaFeu8GwdqNhrYNhraNhrZNh7SbDWmfDWhfD2s2GtVsMa10Na90Ma7ca1m4zrHU3rPUwrN1uWLvDsNbTsNbLsNbbsNbHsNbXsNbPsNbfsHanYW2AYW2gYW2QYW2wYW1I0YbfUOcEf48L/oYyG+vt2UzrbHtYYxkSNwDt6noWp7FMj0UmPqtY3AjR76+4dsj8WOFAP9ERGItuLsci+j87RafMfA6l+CxuyuRY4fX0E52BsbjVzViE0uwUXbbQ59LkBj6Lm7fsWHGDfuIWYCxucy0WcaOdouvm+xz7B59Ft809Vuwf9RO3AmPR3Z1YhP/FTnHb5vgc+1efRfdNP1blRvQTPYCx6OFCLGIbtVPcvmk+hzbBZ3HHphwrtEn6iZ7AWNz+38aiZBPtFL025nN0k30Wvf/1WNHkZugn+gBjccd/FYvYZtkp+v6zz/HN9Fn0+4djlSU3Wz/RHxiLnvZjEdoCO8WdJp9DW+SzGLDhscQW6icGAmPRy2YsEltspxi0vs+RDHwWg1OOFU5mpJ8YAoxFb0uxCGU2BPD7AQHkW5HKZ5nGoo8nsQBykAD28aIHMBZ9PYkFsN8TwH5F9ATGop8nsQCe1wSwLos+wFj0J8UCfQMFcP8KYP4JpH4qfw+Ss35wvCHBNbFBwTWyAcE1s/7BNbS+wTW13sE1tp7BNbfbg2tw3YNrcrcG1+i6Btfsbg6u4XUOrul1Cq7xdQiu+anrAOq6QvpA33mM7HuGFqHiELH6iFmc3evf1HFXEdFgdXD0ce8GJgPL77tTNgXouFYfMTsElmwJa4+YHRZoPjy4MeB/V2qHBUmYuja8iP+IWUTV0ldchwGTfjg4uIwNPqwIf6fRsCJOB4M+2w0GxvoemM+lUZtnu3tIZ7t7i4gG30s4241w/Gyn/B7h+dluMCzZyioN5lLOdiMDzUeln+1GGs52oyyc7QYDz3YjgUk/ihRcdNVH+nwfrnoaf12ZqX13B0UjG5yDSDQYDe4W0EVLxXg0oUty3W+dO2i/x3jSHSJz/H5ynQhlNoSKyf2EOjEaqOEDHuyXBwj7ZSy4Q9e9ytgUW1laoPPpfmA+jSPpOq5oQ3JD16ZBQB0ehOkQrbJJrg+C46fHQ0VEgx8ikOt4x8lV+T3ec3IdBEu2irDBXAq5Tgg0n5hOrhMM5DrRArkiqpYm1wnApJ9ICi666iN9ftjxjnRcUDTQz/MbB9QQWXgnOR4PlS+TCN0t0G/Kr7F1HqI7WWTuTHacjJSGkwkaTgJq+Ign30og69ejjtccFZNHCTXnMRL5PUYkaq0Feg8h82kKSdcpFogaeff94zAdYmGrrz8jEfUTRUSDnyAQ9ZOOE7Xy+0nPiXogLNniVQZzKUQ9NdB8WjpRTzUQ9TQLRI2oWpqopwKTfhopuOiqj/T5Kce7qSlB0UAT9RSghsjCO93xeKh8mU7oboF+U4ha5yG6k0XmzgzHiVppOIOg4XSghk97QtTI+vWM4zVHxeQZQs2ZSSK/mUSi1lqg9xAyn2aRdJ1lgagHAHV4FqZDldUHxD4Ljp8ezxURDX6OQNTPO07Uyu/nPSfqAbBkE0mDuRSinh1o/kI6Uc82EPULFogaUbU0Uc8GJv0LpOCiqz7S5xcd76ZmBUUDTdSzgBoiC+8cx+Oh8mUOobsF+k0hap2H6E4WmTtzHSdqpeFcgoZzgBq+5AlRI+vXy47XHBWTlwk15xUS+b1CJGqtBXoPIfNpHknXeRaI+k6gDq/CdIhYJepXwfHT47UiosGvEYj69SK3iVr5rWzMwh7XKlGnbrhQRqPSGlHPDzR/oyhrfXpW/0M6Uav/iE3UiKqliXo+MOnfIAUXXfWRPr9Z5HY3NS8oGmiingfUEFl433I8Hipf3irCd7dAvylErfMQ3ckic+dtsoahzMafe/ltgoZvATV8B6yhHuhzALJ+vet4zVExeZdQc94Dxjq1h3qviEfUWgv0HkLm0wKSrguK+ESNfP79+zAdyq0+7/J9cPz0+KCIaPAHRfjjfug4USu/P/ScqPvDkq3U2vMuFwaaf5RO1AsNRP2RBaJGVC1N1AuBSf8RKbjoqo/0+WPHu6kFQdFAE/UCoIbIwrvI8XiofFlE6G6BflOIWuchupNF5s5ix4laabiYoOEioIafeELUyPr1qeM1R8XkU0LN+YxEfp8RiVprgd5DyHxaQtJ1iQWi7gfU4XOYDuEym0T9OTh+enxRRDT4CwJRf+k4USu/v/ScqPvBki0RM5hLIeqlgeZfpRP1UgNRf2WBqBFVSxP1UmDSf0UKLrrqI33+2vFuaklQNNBEvQSoIbLwLnM8HipflhG6W6DfFKLWeYjuZJG5s9xxolYaLidouAyo4TeeEDWyfn3reM1RMfmWUHNWkMhvBZGotRboPYTMp5UkXVdaIOq+QB2+g+lQEbdJ1N+B46fHqiKiwasIRP2940St/P7ec6LuC0u2aNxgLoWoVwea/5BO1KsNRP2DBaJGVC1N1KuBSf8DKbjoqo/0+UfHu6mVQdFAE/VKoIbIwrvG8XiofFlD6G6BflOIWuchupNF5s5PjhO10vAngoZrgBr+7AlRI+vXL47XHBWTXwg151cS+f1KJGqtBXoPIfNpLUnXtRaIug9Qh99gOpRYvev7N3D89Pi9iGjw7wSiXuc4USu/13lO1H1wXztZu+v7D615cdb69PyHgajVf8QmakTV0kT9BzLpiznBRVd9pM9bFbvdTa0NigaaqNcCNUQW3mzH46HyRdmI7m6BflOIWuchupNF5k4NsoahzMafe1nZiNYwNXcy1TAHrKEe6HMAsn7lOl5zVExyCTUnDxjr1B4qr5hH1FoL9B5C5lM+Sdf8Yj5R9wbqUBOmQ7TEJlHXBMdPj4JiosEFxfjjFgJPLCy/C4v/Fhh0XKtE3RtH1BUGcylEXSvQvHY6Udcq3pCoa1sg6t5Aoq4FTPraxZzgoqs+0uc6jndT+UHRQBN1PlBDZOEtcjweKl+KCN1tEZhk0PbpPER3ssjcKXacqJWGxQQNi4Aa1vWEqJH1a2vHa46KydaEmrMNify2IRK11gK9h5D5tC1J120tEHUvIFFvh+snS20S9Xbg+OmxfTHR4O0JRL2D40St/N7Bc6LuhbsxuNxgLoWodww03ymdqHc0EPVOFoi6F5CodwQm/U7FnOCiqz7S550d76a2DYoGmqi3BWqILLy7OB4PlS+7ELpboN8UotZ5iO5kkbmzq+NErTTclaDhLkANd/OEqJH1a3fHa46Kye6EmrMHifz2IBK11gK9h5D5VI+kaz0LRN0TSNT1YTrErb49qz44fnrsWUw0eE8CUe/lOFErv/fynKh7wog6Zu3tWXsHmu+TTtR7G4h6HwtE3RNI1HsDk36fYk5w0VUf6fO+jndT9YKigSbqekANkYV3P8fjofJlP0J3C/SbQtQ6D9GdLDJ39necqJWG+xM03A+o4QGeEDWyfh3oeM1RMTmQUHMOIpHfQUSi1lqg9xAynw4m6XqwBaK+A0jUh3hK1IeA46fHocVEgw8lEPVhjhO18vswz4n6Dg+J+vBA81A6UR9uIOqQBaK+A0jUhwOTPuQJUSN9Fo53UwcHRQNN1AcDNUQW3rDj8VD5EiZ0t0C/KUSt8xDdySJzJ+I4USsNIwQNw0ANo54QNbJ+lThec1RMSgg1p5REfqVEotZaoPcQMp9iJF1jFoj6diBRx2E6lFh91nccHD89yoqJBpcRiPoIx4la+X2E50R9O4yoy6096/vIQPOj0on6SANRH2WBqG8HEvWRwKQ/qpgTXHTVR/p8tOPdVCwoGmiijgE1RBbeYxyPh8qXYwjdLdBvClHrPER3ssjcOdZxolYaHkvQ8Bighsd5QtTI+nW84zVHxeR4Qs05gUR+JxCJWmuB3kPIfDqRpOuJFoi6B5CoT8IRdcImUZ8Ejp8eJxcTDT6ZQNSnOE7Uyu9TPCfqHjiijhjMpRD1qYHmp6UT9akGoj7NAlH3ABL1qcCkP62YE1x01Uf6fLrj3dSJQdFAE/WJQA2RhfcMx+Oh8uUMQncL9JtC1DoP0Z0sMnfOdJyolYZnEjQ8A6hhA0+IGlm/znK85qiYnEWoOWeTyO9sIlFrLdB7CJlPDUm6NrRA1N2BRH0OTIew1WvU54Djp8e5xUSDzyUQ9XmOE7Xy+zzPibo7jKgT1q5RNwo0Pz+dqBsZiPp8C0TdHUjUjYBJf34xJ7joqo/0+QLHu6mGQdFAE3VDoIbIwtvY8XiofGlM6G6BflOIWuchupNF5k4Tx4laadiEoGFjoIYXekLUyPp1keM1R8XkIkLNuZhEfhcTiVprgd5DyHxqStK1qQWivg1I1JfAdIhEbBL1JeD46XFpMdHgSwlE3cxxolZ+N/OcqG+DEXVlwmAuhaibB5pflk7UzQ1EfZkFor4NSNTNgUl/WTEnuOiqj/S53PFuqmlQNNBE3RSoIbLwVjgeD5UvFYTuFug3hah1HqI7WWTuVDpO1ErDSoKGFUANE54QNbJ+VTlec1RMqgg1J0kivySRqLUW6D2EzKcWJF1bWCDqW4FEfTlMhyqr16gvB8dPjyuKiQZfQSDqlo4TtfK7pedEfSuMqIW1a9StAs2vTCfqVgaivtICUd8KJOpWwKS/spgTXHTVR/p8lePdVIugaKCJugVQQ2Thbe14PFS+tCZ0t0C/KUSt8xDdySJzp43jRK00bEPQsDVQw6s9IWpk/brG8ZqjYnINoea0JZFfWyJRay3QewiZT+1IurazQNTdgER9LUyHqFWivhYcPz2uKyYafB2BqK93nKiV39d7TtTdYERdYY2o2wea35BO1O0NRH2DBaLuBiTq9sCkv6GYE1x01Uf6fKPj3VS7oGigibodUENk4e3geDxUvnQgdLdAvylErfMQ3ckic6ej40StNOxI0LADUMNOnhA1sn7d5HjNUTG5iVBzOpPIrzORqLUW6D2EzKcuJF27WCDqrkCivhmmQ6zMJlHfDI6fHrcUEw2+hUDUXR0nauV3V8+JuiuMqOMxg7kUou4WaH5rOlF3MxD1rRaIuiuQqLsBk/7WYk5w4d+jAn2+zfFuqktQNNBE3QWoIbLwdnc8HipfuhO6W6DfFKLWeYjuZJG508NxolYa9iBo2B2o4e2eEDWyft3heM1RMbmDUHN6ksivJ5GotRboPYTMp14kXXtZIOpbgETdG3eFxipR9wbHT48+xUSD+xCIuq/jRK387us5Ud8CI+qoNaLuF2jeP52o+xmIur8For4FSNT9gEnfv5gTXHTVR/p8p+PdVK+gaKCJuhdQQ2ThHeB4PFS+DCB0t0C/KUSt8xDdySJzZ6DjRK00HEjQcABQw0GeEDWyfg12vOaomAwm1JwhJPIbQiRqrQV6DyHzaShJ16EWiPpmIFHfhbtGHbJJ1HeB46fH3cVEg+8mEPUwx4la+T3Mc6K+GUbUZSGDuRSiHh5ofk86UQ83EPU9Foj6ZiBRDwcm/T3FnOCiqz7S53sd76aGBkUDTdRDgRoiC+8Ix+Oh8mUEobsF+k0hap2H6E4WmTsjHSdqpeFIgoYjgBqO8oSokfXrPsdrjorJfYSaM5pEfqOJRK21QO8hZD6NIek6xgJRdwES9f24flLYJOr7wfHT44FiosEPEIh6rONErfwe6zlRd4ERdWnSYC6FqMcFmj+YTtTjDET9oAWi7gIk6nHApH+wmBNcdNVH+vyQ493UmKBooIl6DFBDZOEd73g8VL6MJ3S3QL8pRK3zEN3JInNnguNErTScQNBwPFDDiZ4QNbJ+Pex4zVExeZhQcyaRyG8Skai1Fug9hMynySRdJ1sg6s5Aon4Ed8+j1bdnPQKOnx6PFhMNfpRA1I85TtTK78c8J+rOuCeTWXt71pRA88fTiXqKgagft0DUnYFEPQWY9I8Xc4KLrvpIn59wvJuaHBQNNFFPBmqILLxPOh4PlS9PErpboN8UotZ5iO5kkbkz1XGiVhpOJWj4JFDDaZ4QNbJ+PeV4zVExeYpQc6aTyG86kai1Fug9hMynGSRdZ1gg6puARP00TIcqq9eonwbHT49niokGP0Mg6pmOE7Xye6bnRH0T7u1Z1q5Rzwo0fzadqGcZiPpZC0R9E5CoZwGT/tliTnDRVR/p83OOd1MzgqKBJuoZQA2Rhfd5x+Oh8uV5QncL9JtC1DoP0Z0sMndmO07USsPZBA2fB2r4gidEjaxfLzpec1RMXiTUnDkk8ptDJGqtBXoPIfNpLknXuRaIuhOQqF+C6ZAssUnUL4Hjp8fLxUSDXyYQ9SuOE7Xy+xXPiboTjKhDFQZzKUQ9L9D81XSinmcg6lctEHUnIFHPAyb9q8Wc4KKrPtLn1xzvpuYGRQNN1HOBGiIL7+uOx0Ply+uE7hboN4WodR6iO1lk7sx3nKiVhvMJGr4O1PANT4gaWb/edLzmqJi8Sag5b5HI7y0iUWst0HsImU9vk3R92wJRdwQS9TswHcqs3vX9Djh+erxbTDT4XQJRv+c4USu/3/OcqDvifkdt7a7vBYHm76cT9QIDUb9vgag7Aol6ATDp3y/mBBdd9ZE+f+B4N/V2UDTQRP02UENk4f3Q8XiofPmQ0N0C/aYQtc5DdCeLzJ2FjhO10nAhQcMPgRp+5AlRI+vXx47XHBWTjwk1ZxGJ/BYRiVprgd5DyHxaTNJ1sQWi7gAk6k9w16itPuv7E3D89Pi0mGjwpwSi/sxxolZ+f+Y5UXfA3fVt7VnfSwLNP08n6iUGov7cAlF3ABL1EmDSf17MCS666iN9/sLxbmpxUDTQRL0YqCGy8H7peDxUvnxJ6G6BflOIWuchupNF5s5Sx4laabiUoOGXQA2/8oSokfXra8drjorJ14Sas4xEfsuIRK21QO8hZD4tJ+m6PNDVJl3eWIT1RY9viokGf0Ogy28dp0vl97cEujTZitgg3xI2MXDj0ePtqoZIv1d40kwsB/q80vFmQvm6gtBMfOd4863i8h255mSq4SpS47DqP2gcbiA1Dt8XEw3+ntA4rHa8cVB+r/akcVCJvJqwiYEbjx5vVzVE+v2DJ43DKqDPPzreOChffyA0DmscbxxUXNaQa06mGv5Eahx+snANvz3wGv7PwD1ks1n6uZjTLP1STDT4F0Kz9KvjzZLy+1dLzVIosyF+CmxFXzr8CRgjZLzXOn4CVYVuLeEE+pvjJ1Dl828Ev38nnfR+N9wCgtaEHTPEHv+V0PQg9/s6x/NeabiOoOFaoIZ/eAJayHNOVl23zxMqJspG9J7eqi6nXm5Vl3e5V2uB3kPIfMquy9lDaC1T7UT01nqg93obIBDWSPFZxCPhcCyi/rt4IiSiicpwPBxOVERDlaHyynBVWVSUJaPhaKQyUVkhj1kukqFkeWVZMv7XsWwCYQ3wXtUjpy7R4Jy6+OPmgpOW4Xdu3b8FBh33z2RTMzuLn2xtijgFLF2TTDdgaiLnpeQa/EyZC+wQUs+Uef9yptyIzZUbEefPjZK3BWfKjYmeB9yA+aQORB335i3MBSG1qxShZKgsHCoPxSpLYxVliXBFvDwZSZZEEpEt1XVjyY7UtSZJ15pbruv/F/laQNK14P94vhaSdC0MdNUnThudGvLkmXqyrxU0FbXVOYNxgssjdGt5YBRi+Z1N9DtTG+uQNQxlNoRKzDqEryeKSEWh6F+KbSizIWqTtCgmaVFM1EIVQoYWo85yu6aw9sN9/63flRuxj5b7o8F+64H+FS8wLwUw1gKpn2qk8rLM30JkbaaeG8un1GMyzlkoTVKbyrr/9i1EKLMh6pBOAnW3/Pt6sbH/O8rmuoSiMJZUFHI2M2ab07xl6vPWdd0sMMhYpObl1inNyZbGZ2OaI+OzTeq1hUhE7o1ETCQTyUhJrCxcIUojpaXJaDJWGo8mkiXR8kSsSkTLI+GyqlgoKeJVVbGSSGWsNFmWqCxNphZtkYhEoomyikpREi4trwjFE5HyUDIai0jgT0RiiUQkXlpaHokkSuPJeJmEdIn+8VBJLFYWKg1HysKs+GyTQteok8LGvs1JPaYvJ4VtfTwpbEs+KWxLOCk86MhJ4R+TOPbnQ1qSyKKznaMnhQdJRWc7wElhY19tIuOzvaMnBVZ8tv//6CvXHYKvXHc0feUaymz84/UO5LXKTI8F/PqWcmeU1hB9RzNLw0yPtZPj8VAbZifCiX1nUpOzM/Hrzx1JWuxC0mIX8lfBDC3GO/5VMGs/THD8q2BW7k/05KtgYF4KYKzFxOqvgtPHn+cslCapze6uTOrfiXQS2JVI/crmXQlF4RFPvgreCdgI7lbXzQLzCIkqd7PwVTAyPrsDqX8ikPpZ8dndEJ/NvadmY1/9IuOzB6l+7gHQYWPfTiF1qEfSoZ5n+VCfpEN9z/JhT5IOe27CpSKXGzuDubA8Tm0a9/KxadyL3DTuRWgaH7PUNGZ4Vzy0yO0NPBayaXyM1JTsvQlNY6Z31yPjs09dXKOHbBpZ8dkHcHLcyBBDgL8d3RdWP+OUG7Fzg2/d0FeUkDm+n+NXMFSM9yOcb/YnnXvVcWsG/z4oa8OB+r+pj4fWu0m2+zYegG4kfUnaxx2/vKJ8PoDg9xOOfKO4kbFeYmbq84HAwgzMG4GMBblI/u8yxf/FInng/9UieVBdbpEMZTaE8vkggt8Hkzqag+v+/bQ1xs89TR1yKLMhkB3yIY7nkyKqQwj5dKgH++hQgt+HkfbRYf+yj0KZDVpNmXbW/80ceMrSfS2Z2nk4sEkExlo8RfqG6vBquqbbGGI3jgjKDBE2/dOeUGbIg02faSye8aQAC2AsgPknnqmmdC+KrUAWW1/PiqfWct/GcHWgQuJSD3ZUpDpQIXGGBzsqWh2okGjgQaBKqgMVEmd7EKjS6kCFxDkeBCpWHaiQOM+DQMWrAxUS53sQqLLqQIVEYw8CdUR1oELiQg8CdWR1oELiYg8CdVR1oELiEg8CdXR1oEKimQeBOqY6UCFxmQeBOrY6UCEx0YMvZY+rDlRIVHqwo46vDlRIVHkQqBOqAxUSLTwI1InVgQqJKzwI1EnVgQqJVh4E6uTqQIXEVR4E6pTqQIVEGw8CdWp1oELiGg8CdVp1oEKinQeBOr06UCFxnQeBOqM6UCHR3oNAnVkdqJC40YNANagOVEh09CBQZ1UHKiRu8iBQZ1cHKiS6eBCohtWBColbPAjUOchAqWdo5mf9/duyP5+vmRa0bLADwIdcCPQP/RkBC3tgY8QDG6Me2FjigY2lHtgY88DGuAc2lnlg4xEe2HikBzYe5YGNR3tg4zEe2HisBzYe54GNx3tg4wke2HiiBzae5IGNJ3tg4yke2HiqBzae5oGNp3tg4xke2HimBzY28MDGszyw8WwPbGzogY3nEGzMgtoYiWUZBubYYcE79t9vJt8q5ZjnSr3Pk7ORnOfLeYGcjeVsIueFcl4k58VyNpXzEjkvlbOZnM3lvEzOcjkr5KyUMyFnlZxJOVvIebmcV8jZUs5Wcl4p51VytpazjZxXy3mNnG3lbCfntXJeJ+f1craX8wY5b5Szg5wd5ewk501ydpazi5w3y3mLnF3l7CbnrXLeJmd3OXvIebucd8jZU85ecvaWs4+cfeXsJ2f/un9pcGfdQBT91EYlSs20tfMMa40Ma+cb1i4wrDU2rDUxrF1oWLvIsHaxYa2pYe0Sw9qlhrVmhrXmhrXLDGvlhrUKw1qlYS1hWKsyrCUNay0Ma5cb1q4wrLU0rLUyrF1pWLvKsNbasNbGsHa1Ya2tYa2dYe1aw9p1hrXrDWvtDWs3GNZuNKx1MKx1NKx1MqzdZFjrbFjrYli72bB2i2Gtq2Gtm2HtVsPabYa17oa1Hoa12w1rdxjWehrWehnWehvW+hjW+hrW+hnW+hvWVPGrn7X+QD90MvXin0NP+Rbn1uU0G9lg/YAXE8V5nvgMvDgpGnniM/BipzjfE5+BF0/FBZ74DLwYKxp74jPw4q5o4onPwIvF4kJPfAZefBYXeeIz8GK2uNgTn4EXx0VTT3wGXmwXl3jiM/DivbjUE5+BNwOIZp74DLy5QDT3xGfgzQriMk98Bt78IMo98Rl4M4Wo8MRn4M0ZotITn4E3e4iEJz4Dbx4RVZ74DLwZRSQ98Rl4c4to4YnPwJtlxOWe+Ay8+UZc4YnPwJt5REtPfAbeHCRaeeIz8GYjcaUnPgNvXhJXeeIz8GYo0doTn4E3V4k2nvgMvFlLXE3yeas0n0OZDXEN4Fp2VVKNynL1Q9yaKXHZKsVOlv2Ma95oG6t/PIuxsfrHsxgbq388i7Gx+sezGBurfzyLsbH6x7MYG6t/PIuxsfrHsxgbq388i7Gx+sezGBurfzyLsbH6x7MYG6t/PIuxsfrHsxgbq388i7HRxx/PYo4bp2nazoO4X+uBjdd5YOP1HtjY3gMbb/DAxhs9sLGDBzZ29MDGTh7YeJMHNnb2wMYuHth4swc23uKBjV09sLGbBzbe6oGNt3lgY3cPbOzhgY23e2DjHR7Y2NMDG3t5YGNvD2zs44GNfT2wsZ8HNvYnfs+HszMcNt3XOEDaPlDOQXIOlnOInEPlvEvOu+UcJudwOe+R8145R8g5Us5Rct4n52g5x8h5v5wPyDlWznFyPijnQ3KOl3OCnBPlfFjOSXJOlvMROR+V8zE5p8j5uJxPyPmknFPlnCbnU3JOl3OGnE/L+YycM+WcJeezcj4n5/NyzpbzBTlflHOOnHPlfEnOl+V8Rc55cr4q52tyvi7nfDnfkPPNun9p8FbdrPUfwqRESX8w00DD2iDD2mDD2hDD2lDD2l2GtbsNa8MMa8MNa/cY1u41rI0wrI00rI0yrN1nWBttWBtjWLvfsPaAYW2sYW2cYe1Bw9pDhrXxhrUJhrWJhrWHDWuTDGuTDWuPGNYeNaw9blh7wrD2pGFtqmFtmmHtKcPadMPaDMPa04a1ZwxrMw1rswxrzxrWnjOsPW9Ym21Ye8Gw9qJhbY5hba5h7SXD2suGtVcMa/MMa68a1l4zrL1uWJtvWHvDsPamYU0VuvpZ6w99Ujgu+JvpjxCAN7SLAXU5J1a0z8gHwg30xGfkA+EGeeIz8oFwgz3xGflAuCGe+Ix8INxQT3xGPhDuLk98Rj4Q7m5PfEY+EG6YJz4jHwg33BOfkQ+Eu8cTn5EPhLvXE5+RD4Qb4YnPyAfCjfTEZ+QD4UZ54jPygXD3eeIz8oFwoz3xGflAuDGe+Ix8INz9nviMfCDcA574jHwg3FhPfEY+EG6cJz4jHwj3oCc+Ix8I95AnPiMfCDfeE5+RD4Sb4InPyAfCTfTEZ+QD4R72xGfkA+EmeeIz8oFwkz3xGflAuEc88Rn5QLhHST5vleZzKLMhHqubuX76gXBMO6fA7IwLZg4Bf3ApHvdk3wB/wCme8MRn4A9CxZOe+Az8gamY6onPwB+simme+Az8Aax4yhOfgT+oFdM98Rn4A10xwxOfgT/4FU974jPwB8TiGU98Bv4gWcz0xGfgD5zFLE98Bv5gWjzric/AH2CL5zzxGfiDbvG8Jz4DfyAuZnviM/AH5+IFT3wG/oBdvOiJz8AfxIs5nvgM/IG9mOuJz8Af7IuXPPEZ+AAA8bInPgMfKCBe8cRn4AMKxDxPfAY+8EC86onPwAcoiNc88Rn4QAbxuic+Ax/wIOZ74jPwgRHiDU98Bj6AQrwJ9Fm9UKsg66/fH6uxVYrPWSlrqVqEMhvVL9QC2Vj9Qi2MjdUv1MLYWP1CLYyN1S/UwthY/UItjI3VL9TC2Fj9Qi2MjdUv1MLYWP1CLYyN1S/UwthY/UItjI3VL9TC2Fj9Qi2MjdUv1MLYWP1CLcRxq1+oxbCx+oVaGBurX6iFsbH6hVoYG6tfqIWxsfqFWhgbq1+ohbGx+oVaGBurX6iFsbH6hVoYG6tfqIWxsfqFWhgbq1+ohbGx+oVaGBurX6iFsdGXF2oRjy22StFWH/Ntqcs7cr4r53tyLpDzfTk/kPNDORfK+ZGcH8u5SM7Fcn4i56dyfibnEjk/l/MLOb+Uc6mcX8n5tZzL5Fwu5zdyfivnCjlXyvmdnKvk/F7O1XL+IOePcq6R8yc5f5bzFzl/lXOtnL/J+buc6+T8Q86sraUPcmbLWUPOHDlz5cyTM1/OmnIWyFkoZy05a8tZR84iOYvlrCvn1nJus3XW+i+zUWKkv+DmHcPau4a19wxrCwxr7xvWPjCsfWhYW2hY+8iw9rFhbZFhbbFh7RPD2qeGtc8Ma0sMa58b1r4wrH1pWFtqWPvKsPa1YW2ZYW25Ye0bw9q3hrUVhrWVhrXvDGurDGvfG9ZUsqav1Tas1TGsFRnWig1rdQ1rWxvWtgnWUkd28Pe44K9LL3Z6m1Tg0T4jX+z0jic+I1/s9K4nPiNf7PSeJz4jX+y0wBOfkS92et8Tn5EvdvrAE5+RL3b60BOfkS92WuiJz8gXO33kic/IFzt97InPyBc7LfLEZ+SLnRZ74jPyxU6feOIz8sVOn3riM/LFTp954jPyxU5LPPEZ+WKnzz3xGflipy888Rn5YqcvPfEZ+WKnpZ74jHyx01ee+Ix8sdPXnviMfLHTMk98Rr7YabknPiNf7PSNJz4jX+z0rSc+I1/stMITn5Evdlrpic/IFzt954nPyBc7rfLEZ+SLnb4n+Yy+Kej/sXceYFIUXdteMkheFthll2URzKjTs1nFCAoICAoqKMpGRUVFRUVyzjlIBhUkZzDnnHPAnMAICgKS8a/SrpdmLCXM8xRV/7d9Xeey39Kvv3Oec+r0uadne7ZUiV4/Ez/stBXm54E/7IT2c5sjef/DET+3O+LnDkf83OmIn7sc8XO3I37uccTPvY74uc8RP/90xE/5hVYX/CzmiJ/FHfGzhCN+lnTEz1KO+FnaET/LOOJnWUf8LOeIn8eQ/CwZrZ/egf+zfHR+HnC1CtHGHLhaxaq4z2WeaWFpLkIHRl0JUTP+1Spj6u+vq1UB5uJZu3MRUlFXxe1fLxZ4LWAte8FcRPWZWEFhtvxRgYox+z9TpeSGXNuhaA57ayakSQmsZwXzXa3q3/+Mi/yjQPkvvoxYk/9RSkxRoUTbUF9woaFGFPQRxhz2Y/aqAfWLA25aVi6Kg3OB1K+65lq5obz8dC83Iz/TK8hJz8rLy071vHBORk5GbjirsCA33ctKzxLXzMsJZ4n/d+GcPK8glJNRIG8iFWL2D+PBAz2gVwc22KC/NaoSHZYXR1+3JrAYWHHXrLpfYNB1tb4imon0FbVh1XWROYoHF766ocvr1hX/NDkJlgfe4CsAb/AVgTeVSlU5NxXQftJOggn+fq0VOQkmaCbBWsxJ0HeyEnD6SABuxlqBa4Xz0wtC2Vm5WeHcnNTM3LTU3OzsHHHdDM/LKswPh/LTwoXpXkZGXnZBdqGXWpibXpCTkZ6TnZH/190z/xlHpg+kfomOTh+JpOkjqSrR4STC9FHb8ulDxl3bkemjlu8revpA5iiZNH0kH4XpA/Rd1r+uBvuOqIf97iXz5f6AXGinjzr+fk2JnD7qaKaPFAOfQ7lQKNFu7Jcc+RyqVRXcJFgH2BhTgMjwkiOTIFK/uo5OgnVJk+CxVYkOH0uYBOtZPgnKuOs5Mgmm+L6iJ0FkjuqTJsH6R2ESbAq8wTcD3uCRf1XX3MFJ8Dh/vx4fOQkep5kEjzcwCbpQKNFu7FccmQSbAyfB44CN8XjgJPiKI5MgUr8THJ0ETyBNgidWJTp8ImESPMnySVDGfZIjk+Dxvq/oSRCZo5NJk+DJR2ESbAy8wV8IvMEj35fSxMFJ8BR/vzaInARP0UyCDQxMgi4USrQb+zVHJsEmwEnwFGBjbACcBF9zZBJE6neqo5PgqaRJ8LSqRIdPI0yCp1s+Ccq4T3dkEmzg+4qeBJE5CpEmwdBRmATPA97gzwfe4JFvwmzk4CTo+fs1HDkJeppJMGxgEnShUKLd2G84Mgk2Ak6CHrAxhoGT4BuOTIJI/VIdnQRTSZNgWlWiw2mESTDd8klQxp3uyCQY9n1FT4LIHGWQJsGMozAJNgTe4M8G3uCRv3FwroOTYKa/X7MiJ8FMzSSYZWASdKFQot3YbzkyCZ4LnAQzgY0xCzgJvuXIJIjUL9vRSTCbNAmeUZXo8BmESfBMyydBGfeZjkyCWb6v6EkQmaOzSJPgWUdhEswG3uDPAN7gkb9ed5aDk2BDf7+eHTkJNtRMgmcbmARdKJRoN/Y7jkyCZwEnwYbAxng2cBJ8x5FJEKnfOY5OgueQJsFzqzIdJkyC51k+Ccq4z3NkEjzb9xU9CSJzdD5pEjz/KEyC6cAbfAbwBo/8XfIsByfBC/z92ihyErxAMwk2MjAJulAo0W7s9xyZBLOAk+AFwMbYCDgJvufIJIjUr7Gjk2Bj0iR4YVWiwxcSJsGLLJ8EZdwXOTIJNvJ9RU+CyBw1IU2CTUxOgv5NOQy8KacCp7e0KrghprWDk2BTf782i5wEm2omwWbMSdChQol2Y39g+ySoKehoJ8GmwMbYDDgJfuDIJIjU72JHJ8GLSZNg86pEh5sTJsEWlk+CMu4WjkyCzXxf0ZMgMkctSZNgS38SlOc1Yw68yQc/+gk+EAx+TSz4xwPBPykNvmhEnqcEzvtW2H9+RfEjP68VuGZc4Lxf4Pr9A+cDAucDA+eDAueDA+dDAudD/fNLxP+fVsJaC7tU2GXC2ghrK+zyqv+cpNH76nJgHahh4QpxzSuFtRPW3p8CgzUi/33ZmAPXrtSstdOstffXggf646rLgfvsCsC1/v795JB3JdCvj0hDSomIXEQTs8xFO4h+f+e1PXDIQ+rH3uNtCXv8KnHNq4V1EHaNZo9fpdm7V2vWOmjWrjGwx9sC99JVwD1+NdCvtY7s8Q7APX4NcI+vdWiPtyHs8WvFNTsKyxGWq9nj12r2bkfNWo5mLdfAHm8D3EvXAvd4R6Bfnzqyx3OAezwXuMc/dWiPX0bY43nimvnCCoQVavZ4nmbv5mvWCjRrhQb2+GXAvZQH3OP5QL8+d2SPFwD3eCFwj3/u0B6/lLDHrxPXvF5YJ2E3aPb4dZq9e71mrZNm7QYDe/xS4F66DrjHrwf69aUje7wTcI/fANzjXzq0x1sT9viN4po3Cess7GbNHr9Rs3dv0qx11qzdbGCPtwbupRuBe/wmoF9fO7LHOwP3+M3APf61Q3u8FWGP3yKueauwLsJu0+zxWzR791bNWhfN2m0G9ngr4F66BbjHbwX69a0je7wLcI/fBtzj3zq0xy8h7PHbxTXvENZV2J2aPX67Zu/eoVnrqlm708AevwS4l24H7vE7gH6tc2SPdwXu8TuBe3ydQ3u8GO5aoRT/OncJLe8W1k3YPcK6C+shrKewXsJ6C+sjrK+wfsL6CxsgbKCwQcIGCxsibKiwYcKGCxshbKSwUcJGCxsjbKywccLGC5sgbKKwSZqecpemV9ytWeumWbtHs9Zds9ZDs9ZTs9ZLs9Zbs9ZHs9ZXs9ZPs9ZfszZAszZQszZIszZYszZEszZUszZMszZcszZCszZSszZKszZaszZGszZWszZOszZeszZBszZRszbJwD0ouGej7fV3Ae9BdwPvQd8b+sJvtPegbsB70D3RX+t/Xx7uDszFDzbnIu1/fno9oos5FIjZ6xnNtcIH6Of1AubiRztzEYrw0+t9hDFnFP4jZq/PkV0rS6Of1xeYi59sy0WW1k+v3+HHnPkvMXv9D/damf+qnzcAmIuf7clF+D/89AYeTsyZ/xmzN+jQr5V3EP28wcBc/GJDLjIP6qc35NBiDh1CzN7QQ7lW6JD084YBc7Hh6OYi/RD99IYfLOa0Q47ZG/Gf10orPAz9vJHAXGw8WrnIPCw/vVH/HnPWYcbsjf6Xa2UXHrZ+3hhgLn41n4vQEfjpjdXFHDqimL1x/7yWd4T6eeOBufjNZC7yj9hPb8KBMadGEbM3MXCtcGFU+nmTgLnY5MgrV4CfD3hAvvWCfBZtLjY7kgsgB3nAOd77BZiL3x3JBXDe84DzivcrMBdbHMkF8L7mAfuytxmYi62GnhWGojs84P71gPXnsfQrHqFftHlGzhj3wp61poZMvkwB5/eBL1OYXJXosLw4+rpTgMXAintK1f0Cg64b+q/XP6FjmAQrtnzGq5F8Lw/8gsJUX/Np/kP4/z0VneoXYXBtmuZJKbrrI7qWero5FVj008DJZWzwqZrGEW3cU6u6cbebCMz1dFjMGWkm73bTSXe7GVWJDs8g3O1mWn63k3HPdPxuNxFWbNl5Gncpd7tZvuazI+92szR3u9kG7nYTgXe7WcCin01KLrrrI2O+D9c9vZgY/J14it80ioNrEIkG94OnBXTTkjm+nzAl2R63qh103A84Mh0ia3wOuU+Eojs8mZM5hD5xP1DDuQ7sl7mE/fIgeEJXs8qDAV9ZWqDraQ6wnuaRdJ1X9Z/khu5NE4A6zIfpkGb0pbfzwflTx4KqRIcXEMh1oeXkKuNe6Di5ToAVW25Y4y6FXBf5mi+OJNdFGnJdbIBcEV1LkesiYNEvJiUX3fWRMS+xfCKd5zcN1F+T6u760V4L2XiXWp4PWS9LCdMtMG7KW9BVHaInWWTtLLOcjKSGywgaLgVquNyRTyWQ/WuF5T1H5mQFoeesJJHfSiJRKy3QewhZT6tIuq4yQNTIb7qvhumQGTZJ1KvB+VPHmqpEh9cQiPohy4laxv2Q40Q9HlZsWQUadylE/bCv+SORRP2whqgfMUDUiK6liPphYNE/QkouuusjY37U8mlqld800ES9CqghsvE+Znk+ZL08RphugXFTiFrVIXqSRdbO45YTtdTwcYKGjwE1fMIRokb2ryct7zkyJ08Ses5TJPJ7ikjUSgv0HkLW09MkXZ82QNTjgDo8A9OhwDNJ1M+A86eOZ6sSHX6WQNTPWU7UMu7nHCfqcbBi8wo17lKI+nlf8xciifp5DVG/YICoEV1LEfXzwKJ/gZRcdNdHxvyi5dPU037TQBP100ANkY33JcvzIevlJcJ0C4ybQtSqDtGTLLJ2XracqKWGLxM0fAmo4SuOEDWyf71qec+ROXmV0HNeI5Hfa0SiVlqg9xCynl4n6fq6AaIeC9ThDZgOqUaJ+g1w/tTxZlWiw28SiPoty4laxv2W40Q9FlZsecaI+m1f83ciifptDVG/Y4CoEV1LEfXbwKJ/h5RcdNdHxvyu5dPU637TQBP160ANkY33PcvzIevlPcJ0C4ybQtSqDtGTLLJ23recqKWG7xM0fA+o4QeOEDWyf31oec+ROfmQ0HM+IpHfR0SiVlqg9xCynj4m6fqxAaJGvmt+LUyHHKPvu1wLzp86PqlKdPgTAlF/ajlRy7g/dZyox8CKLcPY+y4/8zX/PJKoP9MQ9ecGiBrRtRRRfwYs+s9JyUV3fWTMX1g+TX3sNw00UX8M1BDZeL+0PB+yXr4kTLfAuClEreoQPckia+cry4laavgVQcMvgRp+7QhRI/vXN5b3HJmTbwg951sS+X1LJGqlBXoPIevpO5Ku3xkg6tFAHdbBdAhnmyTqdeD8qWN9VaLD6wlE/b3lRC3j/t5xoh4NK7b8TI27FKL+wdf8x0ii/kFD1D8aIGpE11JE/QOw6H8kJRfd9ZEx/2T5NPWd3zTQRP0dUENk4/3Z8nzIevmZMN0C46YQtapD9CSLrJ1fLCdqqeEvBA1/Bmq4wRGiRvavjZb3HJmTjYSe8yuJ/H4lErXSAr2HkPX0G0nX3wwQ9SigDptgOuRmmSTqTeD8qWNzVaLDmwlE/bvlRC3j/t1xoh4FK7a0LI27FKLe4mu+NZKot2iIeqsBokZ0LUXUW4BFv5WUXHTXR8a8zfJp6je/aaCJ+jeghsjG+4fl+ZD18gdhugXGTSFqVYfoSRZZO9stJ2qp4XaChn8ANdzhCFEj+9dOy3uOzMlOQs/ZRSK/XUSiVlqg9xCynnaTdN1tgKhHAnXYA9Mh3ei3vveA86eOvVWJDu8lEPU+y4laxr3PcaIeifvYydi3vv9UmsfGHEjPf2qIWv5HbKJGdC1F1H8iiz6Wk1x010fGXCzW7mlqt9800ES9G6ghsvEWtzwfsl6kj+jpFhg3hahVHaInWWTtlCBrGIru+GsvSx/RGgZrJ1oNS4I1VAf6HoDsX6Us7zkyJ6UIPac0MNfBGap0LI+olRboPYSspzIkXcvE8ol6BFCHsjAd0tJNEnVZcP7UUS6W6HC5WPx1jwHeWFhxHxO7X2DQdY0S9QgcUedq3KUQdXlf8wqRRF0+9p9EXcEAUY8AEnV5YNFXiOUkF931kTFXtHyaKuM3DTRRlwFqiGy8lSzPh6yXSoTpthKYZND+qTpET7LI2qlsOVFLDSsTNKwE1LCKI0SN7F9VLe85MidVCT0nlkR+sUSiVlqg9xCynqqRdK1mgKiHA4k6DjdPZpgk6jhw/tRRPZbocHUCUdewnKhl3DUcJ+rhuC8G52jcpRB1TV/z+Eiirqkh6ngDRD0cSNQ1gUUfH8tJLrrrI2NOsHyaquY3DTRRVwNqiGy8tSzPh6yXWoTpFhg3hahVHaInWWTtJFpO1FLDRIKGtYAaJjlC1Mj+VdvyniNzUpvQc5JJ5JdMJGqlBXoPIeupDknXOgaIehiQqFNgOmQZ/fWsFHD+1FE3luhwXQJRH2s5Ucu4j3WcqIfBiDrT2K9n1fM1rx9J1PU0RF3fAFEPAxJ1PWDR14/lJBfd9ZExH2f5NFXHbxpooq4D1BDZeI+3PB+yXo4nTLfAuClEreoQPckia+cEy4laangCQcPjgRqe6AhRI/vXSZb3HJmTkwg952QS+Z1MJGqlBXoPIevpFJKupxgg6qFAom7gKFE3AOdPHafGEh0+lUDUp1lO1DLu0xwn6qEOEvXpvuahSKI+XUPUIQNEPRRI1KcDiz7kCFEjY/Ysn6ZO8ZsGmqhPAWqIbLxhy/Mh6yVMmG6BcVOIWtUhepJF1k6q5UQtNUwlaBgGapjmCFEj+1e65T1H5iSd0HMySOSXQSRqpQV6DyHrKZOka6YBoh4CJOosmA7pRt/1nQXOnzqyY4kOZxOI+gzLiVrGfYbjRD0ERtQ5xt71faav+VmRRH2mhqjPMkDUQ4BEfSaw6M+K5SQX3fWRMTe0fJrK9JsGmqgzgRoiG+/ZludD1svZhOkWGDeFqFUdoidZZO2cYzlRSw3PIWh4NlDDcx0hamT/Os/yniNzch6h55xPIr/ziUSttEDvIWQ9XUDS9QIDRD0YSNSNcESdb5KoG4Hzp47GsUSHGxOI+kLLiVrGfaHjRD0YR9SpGncpRH2Rr3mTSKK+SEPUTQwQ9WAgUV8ELPomsZzkors+Muamlk9TF/hNA03UFwA1RDbeZpbnQ9ZLM8J0C4ybQtSqDtGTLLJ2LracqKWGFxM0bAbUsLkjRI3sXy0s7zkyJy0IPaclifxaEolaaYHeQ8h6uoSk6yUGiHoQkKhbwXQIG31G3QqcP3W0jiU63JpA1JdaTtQy7ksdJ+pBMKLON/aM+jJf8zaRRH2ZhqjbGCDqQUCivgxY9G1iOclFd31kzG0tn6Yu8ZsGmqgvAWqIbLyXW54PWS+XE6ZbYNwUolZ1iJ5kkbVzheVELTW8gqDh5UANr3SEqJH9q53lPUfmpB2h57QnkV97IlErLdB7CFlPV5F0vcoAUQ8EEvXVMB1SU00S9dXg/KmjQyzR4Q4Eor7GcqKWcV/jOFEPhBF1Xr7GXQpRX+tr3jGSqK/VEHVHA0Q9EEjU1wKLvmMsJ7noro+MOcfyaeoqv2mgifoqoIbIxptreT5kveQSpltg3BSiVnWInmSRtZNnOVFLDfMIGuYCNcx3hKiR/avA8p4jc1JA6DmFJPIrJBK10gK9h5D1dB1J1+sMEPUAIFFfD9OhwOgz6uvB+VNHp1iiw50IRH2D5UQt477BcaIeACNqz9gz6ht9zW+KJOobNUR9kwGiHgAk6huBRX9TLCe56K6PjLmz5dPUdX7TQBP1dUANkY33ZsvzIevlZsJ0C4ybQtSqDtGTLLJ2brGcqKWGtxA0vBmo4a2OEDWyf3WxvOfInHQh9JzbSOR3G5GolRboPYSsp9tJut5ugKj7A4n6DpgOaUaJ+g5w/tTRNZbocFcCUd9pOVHLuO90nKj7w4g61xhR3+VrfnckUd+lIeq7DRB1fyBR3wUs+rtjOclFd31kzN0sn6Zu95sGmqhvB2qIbLz3WJ4PWS/3EKZbYNwUolZ1iJ5kkbXT3XKilhp2J2h4D1DDHo4QNbJ/9bS858ic9CT0nF4k8utFJGqlBXoPIeupN0nX3gaIuh+QqPvAdMjMNknUfcD5U0ffWKLDfQlE3c9yopZx93OcqPvBiDorU+Muhaj7+5oPiCTq/hqiHmCAqPsBibo/sOgHxHKSC/8cFRjzQMunqd5+00ATdW+ghsjGO8jyfMh6GUSYboFxU4ha1SF6kkXWzmDLiVpqOJig4SCghkMcIWpk/xpqec+RORlK6DnDSOQ3jEjUSgv0HkLW03CSrsMNEHVfIFGPwD2hMUrUI8D5U8fIWKLDIwlEPcpyopZxj3KcqPvCiDrNGFGP9jUfE0nUozVEPcYAUfcFEvVoYNGPieUkF931kTGPtXyaGu43DTRRDwdqiGy84yzPh6yXcYTpFhg3hahVHaInWWTtjLecqKWG4wkajgNqOMERokb2r4mW9xyZk4mEnjOJRH6TiESttEDvIWQ93UvS9V4DRN0HSNSTcc+oQyaJejI4f+qYEkt0eAqBqKdaTtQy7qmOE3UfGFFnhzTuUoh6mq/59EiinqYh6ukGiLoPkKinAYt+eiwnueiuj4x5huXT1L1+00AT9b1ADZGNd6bl+ZD1MpMw3QLjphC1qkP0JIusnVmWE7XUcBZBw5lADWc7QtTI/nWf5T1H5uQ+Qs+5n0R+9xOJWmmB3kPIenqApOsDBoi6N5Co5+DmSc8kUc8B508dc2OJDs8lEPWDlhO1jPtBx4m6N4yoMwo17lKIep6v+fxIop6nIer5Boi6N5Co5wGLfn4sJ7noro+MeYHl09QDftNAE/UDQA2RjXeh5fmQ9bKQMN0C46YQtapD9CSLrJ1FlhO11HARQcOFQA0XO0LUyP61xPKeI3OyhNBzlpLIbymRqJUW6D2ErKdlJF2XGSDqXkCiXo77zqPRX89aDs6fOlbEEh1eQSDqlZYTtYx7peNE3Qv3ZjJjv561ytd8dSRRr9IQ9WoDRN0LSNSrgEW/OpaTXHTXR8a8xvJpapnfNNBEvQyoIbLxPmR5PmS9PESYboFxU4ha1SF6kkXWzsOWE7XU8GGChg8BNXzEEaJG9q9HLe85MiePEnrOYyTye4xI1EoL9B5C1tPjJF0fN0DUPYFE/QRMhwKjz6ifAOdPHU/GEh1+kkDUT1lO1DLupxwn6p64X88y9oz6aV/zZyKJ+mkNUT9jgKh7Aon6aWDRPxPLSS666yNjftbyaepxv2mgifpxoIbIxvuc5fmQ9fIcYboFxk0halWH6EkWWTvPW07UUsPnCRo+B9TwBUeIGtm/XrS858icvEjoOS+RyO8lIlErLdB7CFlPL5N0fdkAUfcAEvUrMB0K000S9Svg/Knj1Viiw68SiPo1y4laxv2a40TdA0bUoVyNuxSift3X/I1Ion5dQ9RvGCDqHkCifh1Y9G/EcpKL7vrImN+0fJp62W8aaKJ+GaghsvG+ZXk+ZL28RZhugXFTiFrVIXqSRdbO25YTtdTwbYKGbwE1fMcRokb2r3ct7zkyJ+8Ses57JPJ7j0jUSgv0HkLW0/skXd83QNTdgUT9AUyHbKPf+v4AnD91fBhLdPhDAlF/ZDlRy7g/cpyou+P+jtrYt74/9jVfG0nUH2uIeq0Bou4OJOqPgUW/NpaTXHTXR8b8ieXT1Pt+00AT9ftADZGN91PL8yHr5VPCdAuMm0LUqg7Rkyyydj6znKilhp8RNPwUqOHnjhA1sn99YXnPkTn5gtBzviSR35dEolZaoPcQsp6+Iun6lQGivgdI1F/jnlEbfdf31+D8qeObWKLD3xCI+lvLiVrG/a3jRH0P7lvfxt71/Z2v+bpIov5OQ9TrDBD1PUCi/g5Y9OtiOclFd31kzOstn6a+8psGmqi/AmqIbLzfW54PWS/fE6ZbYNwUolZ1iJ5kkbXzg+VELTX8gaDh90ANf3SEqJH96yfLe47MyU+EnvMzifx+JhK10gK9h5D19AtJ1198XU3SZbeq2FjUsSGW6PAGAl1utJwuZdwbCXSp8xWxQTYSNjFw49HzbauGyLh/dWSY+AUY82+WDxMy1l8Jw8Qmy4dvmZdN5J4TrYabSYPD5qMwONxNGhx+jyU6/DthcNhi+eAg497iyOAgC3kLYRMDNx4937ZqiIx7qyODw2ZgzNssHxxkrFsJg8Mflg8OMi9/kHtOtBpuJw0O2w08w78L+Ax/B3APmRyWdsRyhqWdsUSHdxKGpV2WD0sy7l2GhqVQdIe33fcV/ehwOzBHyHzvtvwGKhvdbsINdI/lN1AZ8x5C3HtJN729mq+AoDVh5wyxx3cRhh7kft9ned1LDfcRNNwN1PBPR0ALec+JqWb3fULmRPqI3tPFqnH6ZbFqvMe9Sgv0HkLWU/FqnD2E1jLoZ9S15F8nJeDrpKp/3zfl+cTA+YTA+fjA+bjA+djA+ZjA+ejA+ajA+cjA+YjA+fDA+bDA+dDA+ZDA+eDA+aDA+cDA+YDAef/Aeb/Aed/AeZ/Aee/Aea/Aec/AeY/AeffA+T2B826B87sD53cFzgsD5wWB8/zAeV7gPDdwnhM47xg4vzZwfk3gvEPg/OrA+VWB8/aB83aB8ysD51cEzu8MnHcNnN8ROL89cH5b4LxL4PzWwPktgfObA+edA+c3Bc5vDJzfEDjvFDi/PnB+nX+uNm4JscdKCislrLSwMsLKCisn7Bhh5YVVEFZRWCVhlYVVEVZVWKywasLihFUXVkNYTWHxwhKE1RKWKCxJWG1hycLqCEsRVlfYscLqCasv7Dhhxws7QdiJwk4SdrKwU4Q1EHaqsNOEnS4sJMwTFvb7ePmY/cz4V4yi+e5TsQfOOxX/+5/FA//t3eX2//tu/nmquG6asPRqfz+BMvVd9XRSX47B+hkOapFR7e9/ZlbzBVE3Wfkv9kY4gP5eejrgBvH399ILCzOAN5vMamaG1FB0h4eMOStwLS8rNRzOTJX/XVZ+yEvLzwtnhcP5uWmhvFBOXrggO83LLkwLp6Xm5eflimvmeIWhwpy87MKsv/0y+UlmFnjIVEd2NaLD2dXw1z0DWAysuM+otl9g0HUpn0Zk+r6ir3smiYjOrPbPOxw6f8imyPY1Fehrin+ds8Q1Gwo7W9g58vrCzhN2vrALhDUS1ljYhcIuEtZEWFNhzYRdLKy5sBbCWgq7RFgrYa2FXSrsMmFthLUVdrmwK4RdKaydsPbCrvLvzsGcS3/UVKjWGmrWztasnaNZO1ezdp5m7XzN2gWatUaatcaatQs1axdp1ppo1ppq1ppp1i7WrDXXrLXQrLXUrF2iWWulWWutWbtUs3aZZq2NZq2tZu1yzdoVmrUrNWvtNGvtNWtXVfvnJ9Ql/X+e6/8zFN1xwJ6Nts+eBRssQ15DoF8lW3IGy8hcRBOzzMXZEP3+zus50V8r7OvnnQvMRSmbc5H2Pz+986KLORSI2Ts/mmuFD9DPuwCYi9J25iIU4afX6Ahjzij8R8xe4yO7VpZGP+9CYC7K2JaLLK2f3kWHH3Pmv8TsNTnca2X+q35eU2AuytqTi/B/+Ok1O5yYM/8zZu/iQ79W3kH085oDc1HOhlxkHtRPr8WhxRw6hJi9lodyrdAh6eddAszFMUc3F+mH6KfX6mAxpx1yzF7r/7xWWuFh6OddCsxF+aOVi8zD8tO77N9jzjrMmL02/3Kt7MLD1s9rC8xFBfO5CB2Bn97luphDRxSzd8U/r+UdoX7elcBcVDSZi/wj9tNrd2DMqVHE7LUPXCtcGJV+3lXAXFQylItQdIcH/HzAA/KtF+SzaHNR2ZFcADnIA87xXjlgLqo4kgvgvOcB5xWvAjAXVR3JBfC+5gH7slcZmItYUi7QX6AA7l8PWH8eUj9Zv2cIS/Gvd5X/TKyd/4zsCv+ZWVv/Gdpl/jO11v4ztkv8Z24t/GdwF/vP5Jr6z+gu8p/ZNfaf4V3gP9P763NX/1nf2f6zP/lcIfJAf/MYOfdcXQ2Vh1Sjr5jF+X3glzo6VCM6LC+Ovu41wGJgxX1NYFOArmv0FbNXwYot39grZq/1Ne/ofzHgf09qr/WLMLjWsRr/FbOIrqWeuF4LLPqO4OQyNvi11fDfNLq2GmeCQd/t2gNznQOLOSPN5N0uh3S3y61GdDiXcLfLs/xuJ+POc/xu1x5WbNl5Gncpd7t8X/OCyLtdvuZuV2DgbtceeLfLBxZ9ASm56K6PjLkQ1z29mBj8nfgav2kUB9cgEg2uA08L6KYlc3wdYUqyPW5VO+i4r3dkOkTWeCdynwhFd3gyJ50IfeI6oIY3OLBfbiDslxvBE7qaVW4M+MrSAl1PnYD1dBNJ15uq/ZPc0L2pHVCHzjAd0gpMkmtncP7UcXM1osM3E8j1FsvJVcZ9i+Pk2g5WbLlhjbsUcr3V17xLJLneqiHXLgbIFdG1FLneCiz6LqTkors+MubbLJ9Ib/KbBvp9fjcBNUQ23tstz4esl9sJ0y0wbspfY6s6RE+yyNq5w3IykhreQdDwdqCGXR35VALZv+60vOfInNxJ6Dl3kcjvLiJRKy3QewhZT3eTdL3bAFEjv33fDaZDZtjoz5+RiPqeakSH7yEQdXfLiVrG3d1xor4SVmxZBRp3KUTdw9e8ZyRR99AQdU8DRI3oWoqoewCLvicpueiuj4y5l+XT1N1+00AT9d1ADZGNt7fl+ZD10psw3QLjphC1qkP0JIusnT6WE7XUsA9Bw95ADfs6QtTI/tXP8p4jc9KP0HP6k8ivP5GolRboPYSspwEkXQcYIOorgDoMhOlQYPQFsQPB+VPHoGpEhwcRiHqw5UQt4x7sOFFfASs2r1DjLoWoh/iaD40k6iEaoh5qgKgRXUsR9RBg0Q8lJRfd9ZExD7N8mhrgNw00UQ8AaohsvMMtz4esl+GE6RYYN4WoVR2iJ1lk7YywnKilhiMIGg4HajjSEaJG9q9RlvccmZNRhJ4zmkR+o4lErbRA7yFkPY0h6TrGAFFfDtRhLEyHVKNEPRacP3WMq0Z0eByBqMdbTtQy7vGOE/XlsGLLM0bUE3zNJ0YS9QQNUU80QNSIrqWIegKw6CeSkovu+siYJ1k+TY3xmwaaqMcANUQ23nstz4esl3sJ0y0wbgpRqzpET7LI2plsOVFLDScTNLwXqOEUR4ga2b+mWt5zZE6mEnrONBL5TSMStdICvYeQ9TSdpOt0A0SNfP/9DJgOOUbfdzkDnD91zKxGdHgmgahnWU7UMu5ZjhN1W1ixZRh73+VsX/P7Iol6toao7zNA1IiupYh6NrDo7yMlF931kTHfb/k0Nd1vGmiing7UENl4H7A8H7JeHiBMt8C4KUSt6hA9ySJrZ47lRC01nEPQ8AGghnMdIWpk/3rQ8p4jc/IgoefMI5HfPCJRKy3QewhZT/NJus43QNRtgDosgOkQzjZJ1AvA+VPHwmpEhxcSiHqR5UQt417kOFG3gRVbfqbGXQpRL/Y1XxJJ1Is1RL3EAFEjupYi6sXAol9CSi666yNjXmr5NDXfbxpoop4P1BDZeJdZng9ZL8sI0y0wbgpRqzpET7LI2lluOVFLDZcTNFwG1HCFI0SN7F8rLe85MicrCT1nFYn8VhGJWmmB3kPIelpN0nW1AaK+DKjDGpgOuVkmiXoNOH/qeKga0eGHCET9sOVELeN+2HGivgxWbGlZGncpRP2Ir/mjkUT9iIaoHzVA1IiupYj6EWDRP0pKLrrrI2N+zPJparXfNNBEvRqoIbLxPm55PmS9PE6YboFxU4ha1SF6kkXWzhOWE7XU8AmCho8DNXzSEaJG9q+nLO85MidPEXrO0yTye5pI1EoL9B5C1tMzJF2fMUDUlwJ1eBamQ7rRb30/C86fOp6rRnT4OQJRP285Ucu4n3ecqC/Ffexk7FvfL/iavxhJ1C9oiPpFA0SN6FqKqF8AFv2LpOSiuz4y5pcsn6ae8ZsGmqifAWqIbLwvW54PWS8vE6ZbYNwUolZ1iJ5kkbXziuVELTV8haDhy0ANX3WEqJH96zXLe47MyWuEnvM6ifxeJxK10gK9h5D19AZJ1zcMEHVroA5v4p7QpJsk6jfB+VPHW9WIDr9FIOq3LSdqGffbjhN1axx05WrcpRD1O77m70YS9Tsaon7XAFEjupYi6neARf8uKbnoro+M+T3Lp6k3/KaBJuo3gBoiG+/7ludD1sv7hOkWGDeFqFUdoidZZO18YDlRSw0/IGj4PlDDDx0hamT/+sjyniNz8hGh53xMIr+PiUSttEDvIWQ9rSXputYAUbcC6vAJbp7MMEnUn4Dzp45PqxEd/pRA1J9ZTtQy7s8cJ+pWuI+dcjTuUoj6c1/zLyKJ+nMNUX9hgKgRXUsR9efAov+ClFx010fG/KXl09Rav2mgiXotUENk4/3K8nzIevmKMN0C46YQtapD9CSLrJ2vLSdqqeHXBA2/Amr4jSNEjexf31rec2ROviX0nO9I5PcdkaiVFug9hKyndSRd1xkg6kuAOqyH6ZBl9Nez1oPzp47vqxEd/p5A1D9YTtQy7h8cJ+pLYMWWaezXs370Nf8pkqh/1BD1TwaIGtG1FFH/CCz6n0jJRXd9ZMw/Wz5NrfObBpqo1wE1RDbeXyzPh6yXXwjTLTBuClGrOkRPssja2WA5UUsNNxA0/AWo4UZHiBrZv361vOfInPxK6Dm/kcjvNyJRKy3QewhZT5tIum4yQNQtgTpsdpSoN4Pzp47fqxEd/p1A1FssJ2oZ9xbHibqlg0S91dd8WyRRb9UQ9TYDRI3oWoqotwKLfpsjRI2M+Q/Lp6lNftNAE/UmoIbIxrvd8nzIetlOmG6BcVOIWtUhepJF1s4Oy4laariDoOF2oIY7HSFqZP/aZXnPkTnZReg5u0nkt5tI1EoL9B5C1tMekq57DBB1C6AOe2E6pBt91/decP7Usa8a0eF9BKL+03KilnH/6ThRt4AVW46xd33HxPlaxMUcSM/yX0QStfyP2ESN6FqKqGUM0V5LFX2xOE5y0V0fGXPxOLunqT1+00AT9R5gs0Q23hKW50PWS4k4/HQLjJtC1KoO0ZMssnZKkjUMRXf8tZelj2gNSwD7YSmwhupA3wOQ/au05T1H5qQ0oeeUAeY6OEOVieMRtdICvYeQ9VSWpGvZOD5RNwfqUA6mQ3q+SaIuB86fOo6JIzp8TBz+uuWBNxZW3OXj9gsMuq5Rom6OI+pUjbsUoq7ga14xkqgraIi6ogGibg4k6grAoq8Yx0kuuusjY65k+TRV1m8aaKIuC9QQ2XgrW54PWS+VCdNtZTDJoP1TdYieZJG1U8VyopYaViFoWBmoYVVHiBrZv2It7zkyJ7GEnlONRH7ViESttEDvIWQ9xZF0jTNA1BcDibo6TIew0WfU1cH5U0eNOKLDNQhEXdNyopZx13ScqC+GEXW+sWfU8b7mCZFEHa8h6gQDRH0xkKjjgUWfEMdJLrrrI2OuZfk0Fec3DTRRxwE1RDbeRMvzIeslkTDdAuOmELWqQ/Qki6ydJMuJWmqYRNAwEahhbUeIGtm/ki3vOTInyYSeU4dEfnWIRK20QO8hZD2lkHRNMUDUzYBEXRemQ2qqSaKuC86fOo6NIzp8LIGo61lO1DLueo4TdTMYUefla9ylEHV9X/PjIom6voaojzNA1M2ARF0fWPTHxXGSi+76yJiPt3yaSvGbBpqoU4AaIhvvCZbnQ9bLCYTpFhg3hahVHaInWWTtnGg5UUsNTyRoeAJQw5McIWpk/zrZ8p4jc3IyoeecQiK/U4hErbRA7yFkPTUg6drAAFE3BRL1qTAdCow+oz4VnD91nBZHdPg0AlGfbjlRy7hPd5yom8KI2jP2jDrka+5FEnVIQ9SeAaJuCiTqELDovThOctFdHxlz2PJpqoHfNNBE3QCoIbLxplqeD1kvqYTpFhg3hahVHaInWWTtpFlO1FLDNIKGqUAN0x0hamT/yrC858icZBB6TiaJ/DKJRK20QO8hZD1lkXTNMkDUTYBEnQ3TIc0oUWeD86eOM+KIDp9BIOozLSdqGfeZjhN1ExhR5xoj6rN8zRtGEvVZGqJuaIComwCJ+ixg0TeM4yQX3fWRMZ9t+TSV5TcNNFFnATVENt5zLM+HrJdzCNMtMG4KUas6RE+yyNo513Ki/mvPETQ8B6jheY4QNbJ/nW95z5E5OZ/Qcy4gkd8FRKJWWqD3ELKeGpF0bWSAqC8CEnVjmA6Z2SaJujE4f+q4MI7o8IUEor7IcqKWcV/kOFFfhPuJuUyNuxSibuJr3jSSqJtoiLqpAaK+CEjUTYBF3zSOk1z456jAmJtZPk018psGmqgbATVENt6LLc+HrJeLCdMtMG4KUas6RE+yyNppbjlRSw2bEzS8GKhhC0eIGtm/Wlrec2ROWhJ6ziUk8ruESNRKC/QeQtZTK5KurQwQ9YVAom6Ne0JjlKhbg/OnjkvjiA5fSiDqyywnahn3ZY4T9YUwok4zRtRtfM3bRhJ1Gw1RtzVA1BcCiboNsOjbxnGSi+76yJgvt3yaauU3DTRRtwJqiGy8V1ieD1kvVxCmW2DcFKJWdYieZJG1c6XlRC01vJKg4RVADds5QtTI/tXe8p4jc9Ke0HOuIpHfVUSiVlqg9xCynq4m6Xq1AaJuDCTqDrhn1CGTRN0BnD91XBNHdPgaAlFfazlRy7ivdZyoG8OIOjsUozkg144g6o6+5jmRRN1RQ9Q5Boi6MZCoOwKLPieOk1x010fGnGv5NHW13zTQRH01UENk482zPB+yXvII0y0wbgpRqzpET7LI2sm3nKilhvkEDfOAGhY4QtTI/lVoec+ROSkk9JzrSOR3HZGolRboPYSsp+tJul5vgKgbAYm6E26e9EwSdSdw/tRxQxzR4RsIRH2j5UQt477RcaJuBCPqjEKNuxSivsnXvHMkUd+kIerOBoi6EZCobwIWfec4TnLRXR8Z882WT1PX+00DTdTXAzVENt5bLM+HrJdbCNMtMG4KUas6RE+yyNq51XKilhreStDwFqCGXRwhamT/us3yniNzchuh59xOIr/biUSttEDvIWQ93UHS9Q4DRH0BkKi74r7zaPTXs7qC86eOO+OIDt9JIOq7LCdqGfddjhP1Bbg3kxn79ay7fc27RRL13Rqi7maAqC8AEvXdwKLvFsdJLrrrI2O+x/Jp6g6/aaCJ+g6ghsjG293yfMh66U6YboFxU4ha1SF6kkXWTg/LiVpq2IOgYXeghj0dIWpk/+plec+ROelF6Dm9SeTXm0jUSgv0HkLWUx+Srn0MEPX5QKLuC9OhwOgz6r7g/KmjXxzR4X4Eou5vOVHLuPs7TtTn4349y9gz6gG+5gMjiXqAhqgHGiDq84FEPQBY9APjOMlFd31kzIMsn6b6+E0DTdR9gBoiG+9gy/Mh62UwYboFxk0halWH6EkWWTtDLCdqqeEQgoaDgRoOdYSokf1rmOU9R+ZkGKHnDCeR33AiUSst0HsIWU8jSLqOMEDU5wGJeiRMh8J0k0Q9Epw/dYyKIzo8ikDUoy0nahn3aMeJ+jwYUYdyNe5SiHqMr/nYSKIeoyHqsQaI+jwgUY8BFv3YOE5y0V0fGfM4y6epEX7TQBP1CKCGyMY73vJ8yHoZT5hugXFTiFrVIXqSRdbOBMuJWmo4gaDheKCGEx0hamT/mmR5z5E5mUToOfeSyO9eIlErLdB7CFlPk0m6TjZA1OcCiXoKTIdso9/6ngLOnzqmxhEdnkog6mmWE7WMe5rjRH0u7u+ojX3re7qv+YxIop6uIeoZBoj6XCBRTwcW/Yw4TnLRXR8Z80zLp6nJftNAE/VkoIbIxjvL8nzIeplFmG6BcVOIWtUhepJF1s5sy4laajiboOEsoIb3OULUyP51v+U9R+bkfkLPeYBEfg8QiVppgd5DyHqaQ9J1jgGiPgdI1HNxz6iNvut7Ljh/6ngwjujwgwSinmc5Ucu45zlO1OfgvvVt7F3f833NF0QS9XwNUS8wQNTnAIl6PrDoF8Rxkovu+siYF1o+Tc3xmwaaqOcANUQ23kWW50PWyyLCdAuMm0LUqg7RkyyydhZbTtRSw8UEDRcBNVziCFEj+9dSy3uOzMlSQs9ZRiK/ZUSiVlqg9xCynpaTdF3u62qSLs+uho1FHSviiA6vINDlSsvpUsa9kkCXOl8RG2QlYRMDNx4937ZqiIx7lSPDxHJgzKstHyZkrKsIw8Qay4dvmZc15J4TrYYPkQaHh47C4NCQNDg8HEd0+GHC4PCI5YODjPsRRwYHWciPEDYxcOPR822rhsi4H3VkcHgIGPNjlg8OMtZHCYPD45YPDjIvj5N7TrQaPkEaHJ4w8Az/LOAz/CeBe8jksPRkHGdYeiqO6PBThGHpacuHJRn304aGpVB0h/eE7yv60eETwBwh8/2M5TdQ2eieIdxAn7X8BipjfpYQ93Okm95zmq+AoDVh5wyxx58mDD3I/f685XUvNXyeoOEzQA1fcAS0kPecFy2/T8icvEjoly+R+uVLxMe9Sgv0HkLW08ukPYTW8mXwbK0O9F5PAwLhK4GYvazUcDgzVf53WfkhLy0/L5wVDufnpoXyQjl54YLsNC+7MC2clpqXn5crrpnjFYYKc/KyC7P+vpZJIHyFBISvxhEdfpUAhK9ZDoQy7tcIQCiLTVrxGH6xpVXjNLBITaLdgMFCfj34yRT6TvkacEII3ilf/4875UF8zjuIOH9tlNeP4E55MNFfB27AN0gTiLxunyOsBU9ol+eFCkPZ4VBOKDMvIzM3Oz+cm5VTmFqYnpqfeqS6HqzYkbq+SdL1zSPX9f+Len2LpOtb/8fr9W2Srm/7uqobp4lJDXnzDN7s3/GHinflPYNxg3udMK29bvnHWke6OUKHEXe0Pr5n+cdasjDfI3w88T6pKbz/H802FN3hvUvS4gOSFh8QtZCNkKHFsS3t7ims/VDv6MaddxD/aLVfHxy3OtB/xQusSw+Yaw+pnxykSsfoP4WIOUw9D1ZPwWsy7lkoTYJD5Yf/9SlEKLrDe490E/jwyD+v9w72/0f6/CGhKZxIagolDzNnhzO8RRvzR3F2NhhkLoJ1+VFgODnS/BxMc2R+Pg4+W0hNFXsjP9MrzC9MTc/MDud6GakZGYVphZkZWWn5helpOfmZBV5aTmo4uyAzVOhlFRRkpqfmZWYUZufnZRQGm7aXn5qalp+dm+elhzNyckNZ+ak5ocK0zFQB/Pmpmfn5qVkZGTmpqfkZWYVZ2QLSBfpnhdIzM7NDGeHU7DArPx8H6Bp1UzjYpznBa7pyU1jr4k1hLfmmsJZwUzjZkpvCvxZx5l8vaSlENp1PLL0pnExqOp8AbgoH+2gTmZ9PLb0psPLz6f9HH7l+5n/k+rnuI9dQdMe/Pu9APquM9lrAj28p34xSGqK/0czSMNprfWF5PuSG+YJwY/+SNOR8Sfz483OSFl+RtPiK/FEwQ4sGln8UzNoPp1r+UTCr9k9z5KNgYF16wFx7pxV9FBx5/HXPQmkSHHa/ZlL/F6SbwNdE6pc+f01oCmFHPgr+AjgIfhNnZ4MJk6jyGwMfBSPz8y2Q+k8DUj8rP99q8nO436k52Ee/yPx8R+qf3wF0ONinU0gd1pF0WOdYPawn6bDesXr4nqTD94fwqMjmwU7jLqyOg0PjDy4OjT+Qh8YfCENjmqGhMcpvxUOb3I/AayGHxjTSUPLjIQyN0X67Hpmfn+Jwgx5yaGTl5yfAzfEgh3cV8G9Hf4b1zyzKF7Ff8z91Qz9RQtb4L5Y/wZA5/oVwv9lAuvfK65b1//cZMf88UP8/1fXQel9R3H4fN6IHSVeKNsPyxysy5o2EuDMt+UTxIMcBhRltzL8CGzOwbjxkLshN8n+PKf4vNslf/682yd8s//M8GfNvhLg3kSaaTXH737bG+HNP3YQciu7wkBPyZsvrSRLVZkI9/e7APvqdEPcW0j7a8h/7KBTdQespZ7T8v1kDZxr6Xku0fm4FDonAXHtnkj6h2lpE13Qft7EHRwRlbiNs+rMdocxtDmz6qH833pEG/AcwF8D6884ponQnmu0fyGbr6l3xovL2+7i9KFEhr4MDO2pHUaJCXjMHdtTOokSFvOYOJGpXUaJCXksHErW7KFEhr5UDidpTlKiQd6kDidpblKiQ18aBRO0rSlTIu9yBRP1ZlKiQd6UDiYqpXpQor70DiSpWlKiQd7UDiSpelKiQd40DiSpRlKiQ19GBRJUsSlTIW+zAh7KlihIV8vIc2FGlixIV8gocSFSZokSFvOscSFTZokSFvE4OJKpcUaJC3o0OJOqYokSFvM4OJKp8UaJC3i0OJKpCUaJCXhcHElWxKFEh73YHElWpKFEhr6sDiapclKiQd5cDiapSlKiQ182BRFUtSlTI6+5AomKLEhXyejqQqGpFiQp5vR1IVFxRokJeXwcSVR2ZKPkOzTIx+/+2TDpbNyJpxcEBAF9y4aH/0J+RsO0O+LjDAR93OuDjLgd83O2Aj3sc8HGvAz7uc8DHPx3wEfqNUpKPxRzwsbgDPpZwwMeSDvhYygEfSzvgYxkHfCzrgI/lHPDxGAd8LO+AjxUc8LGiAz5WcsDHyg74WMUBH6s64GOsAz5Wc8DHOAd8rE7wMQbqY2pmjObAXDvs8a69/5fJiwWuWUPoXVNYvLAEYbWEJQpLElZbWLKwOsJShNUVdqywesLqCztO2PHCThB2orCThJ0s7BRhDYSdKuw0YacLCwnzhIWFpQpLE5YuLENYprAsYdnCzhB2prCzhDUUdrawc2RNCDtP2PnCLhDWSFhjYRcKu0hYE2FNhTUTdrGw5sJaCGsp7BJhrYS1FnapsMuEtRHWtvrfGlxe3RdFvbVRilI2Yq2mZi1es5agWaulWUvUrCVp1mpr1pI1a3U0aymatbqatWM1a/U0a/U1a8dp1o7XrJ2gWTtRs3aSZu1kzdopmrUGmrVTNWunadZO16yFNGueZi2sWUvVrKVp1tI1a5matSzNWrZm7QzN2pmatbM0aw01a2dr1s7RrJ2rWTtPs3a+Zu0CzVojzVpjzdqFmrWLNGtNNGtNNWvNNGsXa9aaa9ZaaNZaatYu0ay10qy11qxdqlm7TLPWRrPWVrMmm19KzIEH+qWTvwHfbg58+OfJPg+61gHDRnGwfsCHiV5NR2IGPpz04h2JGfiw00twJGbgw1OvliMxAx/GeomOxAx8uOslORIz8GGxV9uRmIEPn71kR2IGPsz26jgSM/DhuJfiSMzAh+1eXUdiBj689451JGbglwG8eo7EDPxygVffkZiBX1bwjnMkZuCXH7zjHYkZ+GUK7wRHYgZ+OcM70ZGYgV/28E5yJGbgl0e8kx2JGfhlFO8UR2IGfrnFa+BIzMAvy3inOhIz8Ms33mmOxAz8Mo93uiMxA78c5IUciRn4ZSPPcyRm4JeXvLAjMQO/DOWlOhIz8MtVXpojMQO/rOWlk2IuFhFzKLrDy6gevX4FhfLIy5F/iFs2kJdiAT9Z/jOeeaN9LPrjWYyPRX88i/Gx6I9nMT4W/fEsxseiP57F+Fj0x7MYH4v+eBbjY9Efz2J8LPrjWYyPRX88i/Gx6I9nMT4W/fEsxseiP57F+Fj0x7MYH4v+eBbjo4t/PIu5bhZN0ywH8p7tgI9nOODjmQ74eJYDPjZ0wMezHfDxHAd8PNcBH89zwMfzHfDxAgd8bOSAj40d8PFCB3y8yAEfmzjgY1MHfGzmgI8XO+Bjcwd8bOGAjy0d8PESB3xs5YCPrR3w8VIHfLzMAR/bOOBjW+LnfDg/w2Hd9xqvEL5fKaydsPbCrhJ2tbAOwq4Rdq2wjsJyhOUKyxOWL6xAWKGw64RdL6yTsBuE3SjsJmGdhd0s7BZhtwrrIuw2YbcLu0NYV2F3CrtL2N3Cugm7R1h3YT2E9RTWS1hvYX2E9RXWT1h/YQOEDRQ2SNhgYUOEDRU2TNhwYSOEjRQ2SthoYWOEjRU2Tth4YROETRQ2qfrfGtxbPebAlzBJUSJfzHSlZq2dZq29Zu0qzdrVmrUOmrVrNGvXatY6atZyNGu5mrU8zVq+Zq1As1aoWbtOs3a9Zq2TZu0GzdqNmrWbNGudNWs3a9Zu0azdqlnrolm7TbN2u2btDs1aV83anZq1bpq1ezRr3TVrPTRrPTVrvTRrvTVrfTRrfTVr/TRr/TVrAzRrAzVrgzRrgzVrQzRrQzVrwzRrwzVrIzRrIzVrozRrozVrYzRrYzVr4zRr4zVrEzRrEzVrkzRrstGlxBx4qJvCuf4/o/0jBOAX2r0rqnNurOiYkS+Eu9KRmJEvhGvnSMzIF8K1dyRm5AvhrnIkZuQL4a52JGbkC+E6OBIz8oVw1zgSM/KFcNc6EjPyhXAdHYkZ+UK4HEdiRr4QLteRmJEvhMtzJGbkC+HyHYkZ+UK4AkdiRr4QrtCRmJEvhLvOkZiRL4S73pGYkS+E6+RIzMgXwt3gSMzIF8Ld6EjMyBfC3eRIzMgXwnV2JGbkC+FudiRm5AvhbnEkZuQL4W51JGbkC+G6OBIz8oVwtzkSM/KFcLc7EjPyhXB3OBIz8oVwXR2JGflCuDtJMReLiDkU3eHdVT16/dQL4Zh+3g3zM8tj1hDwDy69bo7sG+AfcHr3OBIz8A9Cve6OxAz8A1OvhyMxA/9g1evpSMzAP4D1ejkSM/APar3ejsQM/ANdr48jMQP/4Nfr60jMwD8g9vo5EjPwD5K9/o7EDPwDZ2+AIzED/2DaG+hIzMA/wPYGORIz8A+6vcGOxAz8A3FviCMxA//g3BvqSMzAP2D3hjkSM/AP4r3hjsQM/AN7b4QjMQP/YN8b6UjMwBcAeKMciRn4QgFvtCMxA19Q4I1xJGbgCw+8sY7EDHyBgjfOkZiBL2TwxjsSM/AFD94ER2IGvjDCm+hIzMAXUHiTgDHLH9QqF/P33x/Lo1gg5pjAWlCLUHRH0Q9qgXws+kEtjI9FP6iF8bHoB7UwPhb9oBbGx6If1ML4WPSDWhgfi35QC+Nj0Q9qYXws+kEtjI9FP6iF8bHoB7UwPhb9oBbGx6If1ML4WPSDWhgfi35QC3Hdoh/UYvhY9INaGB+LflAL42PRD2phfCz6QS2Mj0U/qIXxsegHtTA+Fv2gFsbHoh/UwvhY9INaGB+LflAL42PRD2phfCz6QS2Mj0U/qIXxsegHtTA+uvKDWsRre8UC2qprTha6TBE2Vdg0YdOFzRA2U9gsYbOF3SfsfmEPCJsjbK6wB4XNEzZf2AJhC4UtErZY2BJhS4UtE7Zc2AphK4WtErZa2BphDwl7WNgjwh4V9piwx4U9IexJYU8Je1rYM8KeFfacsOeFvSDsRWEvCXtZ2CvCXhX2mrDXhb0h7E1hbwl7W9g7wt4V9p6w94V9IOxDYR8J+7h6zIE/ZiPFiPyBmymatamatWmatematRmatZmatVmatdmatfs0a/dr1h7QrM3RrM3VrD2oWZunWZuvWVugWVuoWVukWVusWVuiWVuqWVumWVuuWVuhWVupWVulWVutWVujWXtIs/awZu0dzdq7mrX3NGvva9Y+0Kx9qFn7SLP2sb8WPIr7/zzX/6dNP+w0mdTg0TEjf9hpiiMxI3/YaaojMSN/2GmaIzEjf9hpuiMxI3/YaYYjMSN/2GmmIzEjf9hpliMxI3/YabYjMSN/2Ok+R2JG/rDT/Y7EjPxhpwcciRn5w05zHIkZ+cNOcx2JGfnDTg86EjPyh53mORIz8oed5jsSM/KHnRY4EjPyh50WOhIz8oedFjkSM/KHnRY7EjPyh52WOBIz8oedljoSM/KHnZY5EjPyh52WOxIz8oedVjgSM/KHnVY6EjPyh51WORIz8oedVjsSM/KHndY4EjPyh50eciRm5A87PUyKGf2loEeqR6+fiR92ehTm54E/7IT28zFH8v64I34+4YifTzri51OO+Pm0I34+44ifzzri53OO+Pm8I36+4IifLzri50uO+PmyI36+4oifrzri52uO+Pm6I36+4Yifbzri51uO+Pk2yc+S0frpHfg/34nOzwOu9m60MQeu9h6A1//3I30tLc1F6MCo30fUjH+1DzD199fVPgTm4gK7cxFSUX8E/CzvY+C1gLXsBXMR1WdiBYXZ8kcFKsbs/0yVkhtybYeiOeytGcYfW/6vZwXzvbb63//8RP4z+IdQ8l98GbEm/6OUmKJCifoXK11oqBEFfYQxh/2YvbVA/T4BblpWLoqDc4HU71PNtXJDefnpXm5GfqZXkJOelZeXnep54ZyMnIzccFZhQW66l5WeJa6ZlxPOEv/vwjl5XkEoJ6NA3kQqxOwfxoMHekD/FNhgg/5+Vp3osLw4+rqfA4uBFffn1fcLDLqu1ldEM5G+ojasui4yR1+AC1/d0OV164p/mpwE3wHe4N8F3uDfA95U3q/OuamA9pN2EvzS369fRU6CX2omwa+Yk6Dv5PvA6eNL4Gb8KnCtcH56QSg7KzcrnJuTmpmblpqbnZ0jrpvheVmF+eFQflq4MN3LyMjLLsgu9FILc9MLcjLSc7Iz8v+6e+af78j0gdTva0enj69J08c31YkOf0OYPr61fPqQcX/ryPTxle8revpA5ug70vTx3VGYPmKB00c14PSB/O5ldQenj3X+fl0fOX2s00wf6w18DuVCoUS7sZs48jlUdeAkuA6o33rgpm3iyCSI1O97RyfB70mT4A/ViQ7/QJgEf7R8EpRx/+jIJLje9xU9CSJz9BNpEvzpKEyClYA3+MrAGzzyr+oYPzsWPKK8tnYS/Nnfr79EToI/aybBXwxMgi4USrQbu5kjk2BV4CT4M1C/X4CbtpkjkyBSvw2OToIbSJPgxupEhzcSJsFfLZ8EZdy/OjIJ/uL7ip4EkTn6jTQJ/nYUJsFjgDf48sAbPPJ9KYwfRA4eUV5bOwlu8vfr5shJcJNmEtxsYBJ0oVCi3djNHZkEKwInwU1A/TYDN21zRyZBpH6/OzoJ/k6aBLdUJzq8hTAJbrV8EpRxb3VkEtzs+4qeBJE52kaaBLcdhUmwNPAGXwZ4g0e+CbOcg5PgH/5+3R45Cf6hmQS3G5gEXSiUaDd2S0cmwXLASfAPoH7bgZu2pSOTIFK/HY5OgjtIk+DO6kSHdxImwV2WT4Iy7l2OTILbfV/RkyAyR7tJk+DuozAJFgfe4EsAb/DI3zgo5eAkuMffr3sjJ8E9mklwr4FJ0IVCiXZjt3JkEiwFnAT3APXbC9y0rRyZBJH67XN0EtxHmgT/rE50+E/CJBhTw+5JUMYtfYzBXpcyCe71fUVPgsgcFavBmQTldU1PgqBfA/zrarBf2fOwv15XzMFJsLi/X0vUiDlw6pP/InISlP9RSkxRoUS7sS91ZBIsBpwEiwMbYwlcY/QudWQSROpXsoabk2BJ8A1RHaVqEB2WF0dft7Tlk6CMu7Qjk2AJ31f0JIjMURnSJFjmKEyCu4A3+N3AGzzyd8mBv/dtbBIs6+/XcpGTYFnNJFjOwCToQqFEu7HbODIJ7o3DTYJlgY2xHHASbOPIJIjU7xhHJ8FjSJNg+RpEh8sTJsEKlk+CMu4KjkyC5Xxf0ZMgMkcVSZNgRZOToH9T3g68Ke8ATm8743BDTA0HPxOs5O/XypGTYCXNJFiZOQk6VCjRbuzLbZ8ENQUd7SRYCdgYKwMnwcsdmQSR+lVxdBKsQpoEq9YgOlyVMAnGWj4JyrhjHZkEK/u+oidBZI6qkSbBav4kKM9rxhx4kw9+9BN8IBj8mljwjweCf1IafNGIPF8fOO9bYf/5FcWP/PyrwDU/CZz3C1y/f+B8QOB8YOB8UOB8cOB8SOB8qH8eJzSoLqyGsJrC4oUlCKslLLHGPydp9L5KBNaBGhaSxDVrC0sWVsefAoM1Iv992ZgD12pr1pI1a3X8teCB/rgqEbjPkgDX+vv3k0NebaBfV5KGlBIRuYgmZpmLZIh+f+e1DnDIQ+rH3uO1CHs8RfZ5YccKq6fZ4ymavVtXs3asZq2egT1eC7iXUoB7vC7Qr/aO7PFjgXu8HnCPt3dojycQ9nh9cc3jhB0v7ATNHq+v2bvHadaO16ydYGCPJwD3Un3gHj8O6NfVjuzx44F7/ATgHr/aoT0eT9jjJ4prniTsZGGnaPb4iZq9e5Jm7WTN2ikG9ng8cC+dCNzjJwH9usaRPX4ycI+fAtzj1zi0x2sS9ngDcc1ThZ0m7HTNHm+g2bunatZO06ydbmCP1wTupQbAPX4q0K+Ojuzx04B7/HTgHu/o0B6vQdjjIXFNT1hYWKpmj4c0e9fTrIU1a6kG9ngN4F4KAfe4B/Qr15E9Hgbu8VTgHs91aI9XJ+zxNHHNdGEZwjI1ezxNs3fTNWsZmrVMA3u8OnAvpQH3eDrQr3xH9ngGcI9nAvd4vkN7PI6wx7PENbOFnSHsTM0ez9Ls3WzN2hmatTMN7PE44F7KAu7xbKBfhY7s8TOAe/xM4B5H6qf29Gz/n/J/F5bYX/sFgfP8wHle4Dw3cJ4TOO8YOL82cH5N4LxD4PzqwPlVgfP2gfN2gfMrA+dXBM4vD5y3DZy3CZxfFji/NHDeOnDeKnB+SeC8ZeC8ReC8eeD84sB5s8B508B5k8D5RSX295ZzQbktul7R9YquV3S9ousVXa/oekXXc+t6qfnY6xVkYq+XFcZeLyNbzYK/l9w/F24OnG8KnP8WOP81cL4xcL4hcP5L4PznwPlPgfMfA+c/BM6/D5yvD5yvC5x/Fzj/NnD+TeD868D5V4HzLwPnXwTOPw+cfxY4/zRw/kngfG3g/OPA+UeB8w8D5x8Ezt8PnPcqvf+8Z+C8R+C8e+D8nsB5t8D53YHzuwLndwbOuwbO7wic3x44vy1w3iVwfmvg/JbA+c2B886B85sC5zcGzm8InHcKnF8fOL8ucF4YOC8InOcHzvMC57mB85zAecfA+bWB82PK7j8vFzgvGzgvEzgvHTgvFTgvGTgvETgvHjgvFjiPCZz/WWb/+b7A+d7A+Z7A+e7A+a7A+c7A+Y7A+fbA+R+B822B862B8y2B898D55sD55sC578Fzn8NnG8MnG8InP8SOD8l8NlX8Hspwe+tBL/XckLgPPhdteB32YLfdasXOA9+fzX4/dbg91/rBM6D32kPfuc9+J34MwPnwc/xgp/zBT8HzAycBz/bD372H3w2kBo4Dz7vCz4PDD4vPD1wHvwOQPA7Auo7BMtj/j7OEv+7obCzhZ0jPzsSdp6w84VdIKyRsMbCLhR2kbAmwpoKaybsYmHNhbUQ1lLYJcJaCWst7FJhlwlrI6ytsMuFXSHsSmHthLUXdpWwq4V1EHaNsGuFdRSWIyxXWJ6wfGEFwgqFXSfsemGdhN0g7EZhNwnrLOxmYbcIu1VYF2G3Cbtd2B3Cugq7U9hdwu4W1k3YPcK6C+shrKewXsJ6C+sjrK+wfsL6CxsgbKCwQcIGCxsibKiwYcKGCxshbKSwUcJGCxsjbKywccLGC5sgbKKwScLuFTZZ2BRhU4VNEzZd2AxhM4XNEjZb2H3C7hf2gLA5wuYKe1DYPGHzhS0QtlDYImGLhS0RtlTYMmHLha0QtlLYKmGrha0R9pCwh4U9IuxRYY8Je1zYE8KeFPaUsKeFPSPsWWHPCXte2AvCXhT2krCXhb0i7FVhrwl7Xdgbwt4U9pawt4W9I+xdYe8Je1/YB8I+FPaRsI+FrRX2ibBPhX0m7HNhXwj7UthXwr4W9o2wb4V9J2ydsPXCvhf2g7Afhf0k7Gdhv9T4+y/Zi6u+6h/q/Fz/n9F+jlxdfGaWUOKf1w1Fd3jymqBrHfAMZUONv/+5sYYvhnqwIP9Fn4i1jf4aU7gSROGi/jXdGod8rbyDXMvbWAOXUFnYpWP0r2iIOUw9D+Z38JroIt8A1CS4yX+NLG65UCxCINSTGl2xHMRX72DB/FoD59dvNWDFcOAvzAaaA0vTjUAdkJpuOgxND/b/K6jpJl9T9lPvbuVwGy/Fv85m4fvvwrYI2ypsm7A/hG0XtkPYTmG7hO0WtkfYXmH7hP0pN2tNEaOw4sJKCCsprJSw0sLKCCsrrJywY4SVF1ZBWEVhlYRVFlbF/zPloJbSn/+Rl//P3zVrWzRrWzVr2zRrf2jWtmvWdmjWdmrWdmnWdmvW9mjW9mrW9mnW/tSsSf0j14pp1opr1kpo1kpq1kpp1kpr1spo1spq1spp1o7RrJXXrFXQrFXUrFXSrFXWrFXx14IH+lsZwT0b9e9hAnqh+lbG78C+er2hV+BE+62MLRD9/s7r1uiv9b/X6WwD5qKTzblI2z+g/hFdzKHgsLs9mmuFDxycdwBzcYOduQhFwsLOI4w5o/Cf4LHryK6VpYOY3cBc3GhbLrL04Lbn8GPO/DcI3Hu418r8d6DcB8zFTfbkIvxfEP3n4cSceRAgr4n7UKJYTVwuOtuQi8yD+ukVP7SYQ4cQs1fiUK4VOiT9vJLAXNx8dHORfoh+eqUOFnPaIcfslf7Pa6UVHoZ+XhlgLm45WrnIPCw/vbL/HnPWYcbslfuXa2UXHrZ+3jHAXNxqPhehI/DTK6+LOXREMXsV/nkt7wj18yoCc9HFZC7yj9hPr9KBMadGEbNXOXCtcGFU+nlVgLm4zZEfIQB+PuAB+dYL8lm0ubjdkVwAOcgDzvFeZ2Au7nAkF8B5zwPOK96twFx0dSQXwPuaB+zL3u3AXNxp6K/nQtEdHnD/esD681j6FY/QL+pXggNnjKo1Yd/KDpl8vTjO7wO/pBBbk+iwvDj6utWAxcCKu1rN/QKDrhv6rx9EQcdQBVZs+YwfC/G9PPArZXG+5tXVu8LVU9E4vwiDa9U1T0rRXR/RtdTTzThg0VcHJ5exweNq4r/qF1fTjbtdZWCua8BizkgzeberQbrb1axJdLgm4W4Xb/ndTsYd7/jdrjKs2LLzNO5S7nYJvua1Iu92CZq7XS0Dd7vKwLtdArDoa5GSi+76yJgTcd3zry9eo+/E1fymURxcg0g0SAJPC+imJXOcRJiSbI9b1Q467tqOTIfIGk8m94lQdIcnc5JM6BNJQA3rOLBf6hD2Swp4Qv/fr70EfGVpga6nZGA91SXpWrfmP8kN3ZsqAXU4FqZDmtGfgTwWnD911KtJdLgegVzrW06uMu76jpNrJVix5YY17lLI9Thf8+MjyfU4Dbkeb4BcEV3rf7/HAyz640nJRXd9ZMwnWD6R1vWbBvovTOsCNUQ23hMtz4eslxMJ0y0wbsrvAqs6RE+yyNo5yXIykhqeRNDwRKCGJzvyqQSyf51iec+ROTmF0HMakMivAZGolRboPYSsp1NJup5qgKiR33Q/DaZDZtgkUZ8Gzp86Tq9JdPh0AlGHLCdqGXfIcaKuCCu2rAKNuxSi9nzNw5FE7WmIOmyAqBFd63+/mgUs+jApueiuj4w51fJp6lS/aaCJ+lSghsjGm2Z5PmS9pBGmW2DcFKJWdYieZJG1k245UUsN0wkapgE1zHCEqJH9K9PyniNzkknoOVkk8ssiErXSAr2HkPWUTdI12wBRVwDqcAZMhwLPJFGfAc6fOs6sSXT4TAJRn2U5Ucu4z3KcqCvAis0r1LhLIeqGvuZnRxJ1Qw1Rn22AqBFdSxF1Q2DRn01KLrrrI2M+x/JpKttvGmiizgZqiGy851qej7/qhTDdAuOmELWqQ/Qki6yd8ywnaqnheQQNzwVqeL4jRI3sXxdY3nNkTi4g9JxGJPJrRCRqpQV6DyHrqTFJ18YGiLo8UIcLYTqkGiXqC8H5U8dFNYkOX0Qg6iaWE7WMu4njRF0eVmx5xoi6qa95s0iibqoh6mYGiBrRtRRRNwUWfTNSctFdHxnzxZZPU439poEm6sZADZGNt7nl+ZD10pww3QLjphC1qkP0JIusnRaWE7XUsAVBw+ZADVs6QtTI/nWJ5T1H5uQSQs9pRSK/VkSiVlqg9xCynlqTdG1tgKiR75q/FKZDjtH3XV4Kzp86LqtJdPgyAlG3sZyoZdxtHCfqY2DFlmHsfZdtfc0vjyTqthqivtwAUSO6liLqtsCiv5yUXHTXR8Z8heXTVGu/aaCJujVQQ2TjvdLyfMh6uZIw3QLjphC1qkP0JIusnXaWE7XUsB1BwyuBGrZ3hKiR/esqy3uOzMlVhJ5zNYn8riYStdICvYeQ9dSBpGsHA0RdDqjDNTAdwtkmifoacP7UcW1NosPXEoi6o+VELePu6DhRl4MVW36mxl0KUef4mudGEnWOhqhzDRA1omspos4BFn0uKbnoro+MOc/yaaqD3zTQRN0BqCGy8eZbng9ZL/mE6RYYN4WoVR2iJ1lk7RRYTtRSwwKChvlADQsdIWpk/7rO8p4jc3IdoedcTyK/64lErbRA7yFkPXUi6drJAFGXBepwA0yH3CyTRH0DOH/quLEm0eEbCUR9k+VELeO+yXGiLgsrtrQsjbsUou7sa35zJFF31hD1zQaIGtG1FFF3Bhb9zaTkors+MuZbLJ+mOvlNA03UnYAaIhvvrZbnQ9bLrYTpFhg3hahVHaInWWTtdLGcqKWGXQga3grU8DZHiBrZv263vOfInNxO6Dl3kMjvDiJRKy3QewhZT11JunY1QNRlgDrcCdMh3ei3vu8E508dd9UkOnwXgajvtpyoZdx3O07UZXAfOxn71nc3X/N7Iom6m4ao7zFA1IiupYi6G7Do7yElF931kTF3t3ya6uo3DTRRdwVqiGy8PSzPh6yXHoTpFhg3hahVHaInWWTt9LScqKWGPQka9gBq2MsRokb2r96W9xyZk96EntOHRH59iESttEDvIWQ99SXp2tcAUZcG6tAP94Qm3SRR9wPnTx39axId7k8g6gGWE7WMe4DjRF0aB125GncpRD3Q13xQJFEP1BD1IANEjehaiqgHAot+ECm56K6PjHmw5dNUX79poIm6L1BDZOMdYnk+ZL0MIUy3wLgpRK3qED3JImtnqOVELTUcStBwCFDDYY4QNbJ/Dbe858icDCf0nBEk8htBJGqlBXoPIetpJEnXkQaIuhRQh1G4eTLDJFGPAudPHaNrEh0eTSDqMZYTtYx7jONEXQr3sVOOxl0KUY/1NR8XSdRjNUQ9zgBRI7qWIuqxwKIfR0ouuusjYx5v+TQ10m8aaKIeCdQQ2XgnWJ4PWS8TCNMtMG4KUas6RE+yyNqZaDlRSw0nEjScANRwkiNEjexf91rec2RO7iX0nMkk8ptMJGqlBXoPIetpCknXKQaIuiRQh6kwHbKM/nrWVHD+1DGtJtHhaQSinm45Ucu4pztO1CVhxZZp7NezZviaz4wk6hkaop5pgKgRXUsR9Qxg0c8kJRfd9ZExz7J8mpriNw00UU8BaohsvLMtz4esl9mE6RYYN4WoVR2iJ1lk7dxnOVFLDe8jaDgbqOH9jhA1sn89YHnPkTl5gNBz5pDIbw6RqJUW6D2ErKe5JF3nGiDqEkAdHnSUqB8E508d82oSHZ5HIOr5lhO1jHu+40RdwkGiXuBrvjCSqBdoiHqhAaJGdC1F1AuARb/QEaJGxrzI8mlqrt800EQ9F6ghsvEutjwfsl4WE6ZbYNwUolZ1iJ5kkbWzxHKilhouIWi4GKjhUkeIGtm/llnec2ROlhF6znIS+S0nErXSAr2HkPW0gqTrCgNEXRyow0qYDulG3/W9Epw/dayqSXR4FYGoV1tO1DLu1Y4TdXFYseUYe9f3Gl/zhyKJeo2GqB8yQNSIrqWIeg2w6B8iJRfd9ZExP2z5NLXCbxpool4B1BDZeB+xPB+yXh4hTLfAuClEreoQPckia+dRy4laavgoQcNHgBo+5ghRI/vX45b3HJmTxwk95wkS+T1BJGqlBXoPIevpSZKuTxog6mJAHZ7CEXW+SaJ+Cpw/dTxdk+jw0wSifsZyopZxP+M4URfDQVeqxl0KUT/ra/5cJFE/qyHq5wwQNaJrKaJ+Flj0z5GSi+76yJift3yaetJvGmiifhKoIbLxvmB5PmS9vECYboFxU4ha1SF6kkXWzouWE7XU8EWChi8ANXzJEaJG9q+XLe85MicvE3rOKyTye4VI1EoL9B5C1tOrJF1fNUDUMUAdXoPpEDb6jPo1cP7U8XpNosOvE4j6DcuJWsb9huNEHQMrtnxjz6jf9DV/K5Ko39QQ9VsGiBrRtRRRvwks+rdIyUV3fWTMb1s+Tb3qNw00Ub8K1BDZeN+xPB+yXt4hTLfAuClEreoQPckia+ddy4laavguQcN3gBq+5whRI/vX+5b3HJmT9wk95wMS+X1AJGqlBXoPIevpQ5KuHxog6j9r4K71EUyH1FSTRP0ROH/q+Lgm0eGPCUS91nKilnGvdZyogxsuFNWRl69xl0LUn/iafxpJ1J9oiPpTA0SN6FqKqD8BFv2nNTnJRXd9ZMyfWT5Nfeg3DTRRfwjUENl4P7c8H7JePidMt8C4KUSt6hA9ySJr5wvLiVpq+AVBw8+BGn7pCFEj+9dXlvccmZOvCD3naxL5fU0kaqUFeg8h6+kbkq7fGCDqfUCi/hamQ4HRZ9TfgvOnju9qEh3+jkDU6ywnahn3OseJeh+MqD1jz6jX+5p/H0nU6zVE/b0Bot4HJOr1wKL/viYnueiuj4z5B8unqW/8poEm6m+AGiIb74+W50PWy4+E6RYYN4WoVR2iJ1lk7fxkOVFLDX8iaPgjUMOfHSFqZP/6xfKeI3PyC6HnbCCR3wYiUSst0HsIWU8bSbpuNEDUe4FE/StMhzSjRP0rOH/q+K0m0eHfCES9yXKilnFvcpyo98KIOtcYUW/2Nf89kqg3a4j6dwNEvRdI1JuBRf97TU5y0V0fGfMWy6epjX7TQBP1RqCGyMa71fJ8yHrZSphugXFTiFrVIXqSRdbONsuJWmq4jaDhVqCGfzhC1Mj+td3yniNzsp3Qc3aQyG8HkaiVFug9hKynnSRddxog6j1Aot4F0yEz2yRR7wLnTx27axId3k0g6j2WE7WMe4/jRL0HRtRZmRp3KUS919d8XyRR79UQ9T4DRL0HSNR7gUW/ryYnufDPUYEx/2n5NLXTbxpoot4J1BDaeOPtzoesF+kjeroFxk0halWH6EkWWTvFyBqGojv+2svSR7SGwdqJ+tdzwBqqA30PQPavEpb3HJmTEoSeUxKY6+AMVTKeR9RKC/QeQtZTKZKupeL5RL0bSNSlYTrkGiXq0uD8qaNMPNHhMvH465YF3lhYcZeN3y8w6LpGiXo3jKjTjBF1OV/zY+JjDqTncvH/JGr5H7GJejeQqMsBi/6YeE5y0V0fGXN5y6epUn7TQBN1KaCGyMZbwfJ8yHqpQJhuK4BJBu2fqkP0JIusnYqWE7XUsCJBwwpADSs5QtTI/lXZ8p4jc1KZ0HOqkMivCpGolRboPYSsp6okXasaIOpdQKKOhemQGTJJ1LHg/KmjWjzR4WoEoo6znKhl3HGOE/UuGFFnhzTuUoi6uq95jUiirq4h6hoGiHoXkKirA4u+Rjwnueiuj4y5puXTVFW/aaCJuipQQ2Tjjbc8H7Je4gnTLTBuClGrOkRPssjaSbCcqKWGCQQN44Ea1nKEqJH9K9HyniNzkkjoOUkk8ksiErXSAr2HkPVUm6RrbQNEvRNI1Mm4edIzSdTJ4Pypo0480eE6BKJOsZyoZdwpjhP1ThhRZxRq3KUQdV1f82MjibquhqiPNUDUO4FEXRdY9MfGc5KL7vrImOtZPk3V9psGmqhrAzVENt76ludD1kt9wnQLjJtC1KoO0ZMssnaOs5yopYbHETSsD9TweEeIGtm/TrC858icnEDoOSeSyO9EIlErLdB7CFlPJ5F0PckAUe8AEvXJuO88Gv31rJPB+VPHKfFEh08hEHUDy4laxt3AcaLegXszmbFfzzrV1/y0SKI+VUPUpxkg6h1Aoj4VWPSnxXOSi+76yJhPt3yaOslvGmiiPgmoIbLxhizPh6yXEGG6BcZNIWpVh+hJFlk7nuVELTX0CBqGgBqGHSFqZP9KtbznyJykEnpOGon80ohErbRA7yFkPaWTdE03QNTbgUSdAdOhwOgz6gxw/tSRGU90OJNA1FmWE7WMO8txot6O+/UsY8+os33Nz4gk6mwNUZ9hgKi3A4k6G1j0Z8Rzkovu+siYz7R8mkr3mwaaqNOBGiIb71mW50PWy1mE6RYYN4WoVR2iJ1lk7TS0nKilhg0JGp4F1PBsR4ga2b/OsbznyJycQ+g555LI71wiUSst0HsIWU/nkXQ9zwBR/wEk6vNhOhSmmyTq88H5U8cF8USHLyAQdSPLiVrG3chxov4DRtShXI27FKJu7Gt+YSRRN9YQ9YUGiPoPIFE3Bhb9hfGc5KK7PjLmiyyfps7zmwaaqM8DaohsvE0sz4eslyaE6RYYN4WoVR2iJ1lk7TS1nKilhk0JGjYBatjMEaJG9q+LLe85MicXE3pOcxL5NScStdICvYeQ9dSCpGsLA0S9DUjULWE6ZBv91ndLcP7UcUk80eFLCETdynKilnG3cpyot+H+jtrYt75b+5pfGknUrTVEfakBot4GJOrWwKK/NJ6TXHTXR8Z8meXTVAu/aaCJugVQQ2TjbWN5PmS9tCFMt8C4KUSt6hA9ySJrp63lRC01bEvQsA1Qw8sdIWpk/7rC8p4jc3IFoedcSSK/K4lErbRA7yFkPbUj6drOAFFvBRJ1e9wzaqPv+m4Pzp86roonOnwVgaivtpyoZdxXO07UW3Hf+jb2ru8OvubXRBJ1Bw1RX2OAqLcCiboDsOivieckF931kTFfa/k01c5vGmiibgfUENl4O1qeD1kvHQnTLTBuClGrOkRPssjaybGcqKWGOQQNOwI1zHWEqJH9K8/yniNzkkfoOfkk8ssnErXSAr2HkPVUQNK1wNfVJF1uqYGNRR2F8USHCwl0eZ3ldCnjvo5AlzpfERvkOsImBm48er5t1RAZ9/WODBMFwJg7WT5MyFivJwwTN1g+fMu83EDuOdFqeCNpcLjxKAwOv5MGh5viiQ7fRBgcOls+OMi4OzsyOMhC7kzYxMCNR8+3rRoi477ZkcHhRmDMt1g+OMhYbyYMDrdaPjjIvNxK7jnRatiFNDh0MfAMfzPwGf5twD1kcli6LZ4zLN0eT3T4dsKwdIflw5KM+w5Dw1IousPr4vuKfnTYBZgjZL67Wn4DlY2uK+EGeqflN1AZ852EuO8i3fTu0nwFBK0JO2eIPX4HYehB7ve7La97qeHdBA27AjXs5ghoIe8591h+n5A5uYfQL7uT+mV34uNepQV6DyHrqQdpD6G17AGMuXjMgQfa17vL4TRN8a/TU8TfS1hvYX2E9RXWT1h/YQOEDRQ2SNhgYUOEDRU2TNhwYSOEjRQ2SthoYWOEjRU2Tth4YROETRQ2Sdi9wiYLmyJsqrBpwqbH/y1ScN/09OeM4FovzVpvzVofzVpfzVo/zVp/zdoAzdpAzdogzdpgzdoQzdpQzdowzdpwzdoIzdpIzdoozdpozdoYzdpYzdo4zdp4zdoEzdpEzdokzdq9mrXJmrUpmrWpmrVpmrXpmpm2pP/Pc/1/hqI7Dtiz0faXnoBepb4i3QvY9wa15PT6yFxEE7PMRW+Ifn/ntU/01wr7+nl9gbkYbHMu0v7np9cvuphDgZi9/tFcK3yAft4AYC6G2JmLUISf3sAjjDmj8B8xe4OO7FpZGv28wcBcDLUtF1laP70hhx9z5r/E7A093Gtl/qt+3jBgLobZk4vwf/jpDT+cmDP/M2ZvxKFfK+8g+nkjgbkYbkMuMg/qpzfq0GIOHULM3uhDuVbokPTzxgBzMeLo5iL9EP30xh4s5rRDjtkb95/XSis8DP288cBcjDxaucg8LD+9Cf8ec9ZhxuxN/JdrZRcetn7eJGAuRpnPRegI/PTu1cUcOqKYvcn/vJZ3hPp5U4C5GG0yF/lH7Kc39cCYU6OI2ZsWuFa4MCr9vOnAXIwxlItQdIcH/HzAA/KtF+SzaHMx1pFcADnIA87x3nBgLsY5kgvgvOcB5xVvFDAX4x3JBfC+5gH7sjcWmIsJpFygXwUC3L8esP48ln7o7wUgZ4wZsOe4qUZfAIXz+8Avj86MJzo8Mx5/3VnAYmDFPSt+v8Cg6xp9AdR0WLHlG3sB1Gxf8/v8h/D/eyo62y/C4Np98fwXQCG6lnq6ORtY9PeBk8vY4LPj8d+Mmh3vxt1uGjDX98Nizkgzebe7n3S3eyCe6PADhLvdHMvvdjLuOY7f7abBii07T+Mu5W4319f8wci73VzN3e5BA3e7acC73Vxg0T9ISi666yNjnofrntrvPkfr3yy/aRQH1yASDeaDpwV005I5nk+YkmyPW9UOOu4FjkyHyBpfSO4ToegOT+ZkIaFPzAdquMiB/bKIsF8Wgyd0NassDvjK0gJdTwuB9bSEpOuSeP4f+U8F6rAUpkNagUlyXQrOnzqWxRMdXkYg1+WWk6uMe7nj5DoVVmy5YY27FHJd4Wu+MpJcV2jIdaUBckV0LUWuK4BFv5KUXHTXR8a8yvKJdInfNNBv21gC1BDZeFdbng9ZL6sJ0y0wbsqbG1QdoidZZO2ssZyMpIZrCBquBmr4kCOfSiD718OW9xyZk4cJPecREvk9QiRqpQV6DyHr6VGSro8aIGrkN90fg+mQGTZJ1I+B86eOx+OJDj9OIOonLCdqGfcTjhP1FFixZRVo3KUQ9ZO+5k9FEvWTGqJ+ygBRI7qWIuongUX/FCm56K6PjPlpy6epR/2mgSbqR4EaIhvvM5bnQ9bLM4TpFhg3hahVHaInWWTtPGs5UUsNnyVo+AxQw+ccIWpk/3re8p4jc/I8oee8QCK/F4hErbRA7yFkPb1I0vVFA0Q9GajDSzAdCoy+iP4lcP7U8XI80eGXCUT9iuVELeN+xXGingwrNq9Q4y6FqF/1NX8tkqhf1RD1awaIGtG1FFG/Ciz610jJRXd9ZMyvWz5Nveg3DTRRvwjUENl437A8H7Je3iBMt8C4KUSt6hA9ySJr503LiVpq+CZBwzeAGr7lCFEj+9fblvccmZO3CT3nHRL5vUMkaqUFeg8h6+ldkq7vGiDqe4E6vAfTIdUoUb8Hzp863o8nOvw+gag/sJyoZdwfOE7U98KKLc8YUX/oa/5RJFF/qCHqjwwQNaJrKaL+EFj0H5GSi+76yJg/tnyaetdvGmiifheoIbLxrrU8H7Je1hKmW2DcFKJWdYieZJG184nlRC01/ISg4Vqghp86QtTI/vWZ5T1H5uQzQs/5nER+nxOJWmmB3kPIevqCpOsXBoga+a75L2E65Bh93+WX4Pyp46t4osNfEYj6a8uJWsb9teNEPQlWbBnG3nf5ja/5t5FE/Y2GqL81QNSIrqWI+htg0X9LSi666yNj/s7yaeoLv2mgifoLoIbIxrvO8nzIellHmG6BcVOIWtUhepJF1s56y4laarieoOE6oIbfO0LUyP71g+U9R+bkB0LP+ZFEfj8SiVppgd5DyHr6iaTrTwaIeiJQh59hOoSzTRL1z+D8qeOXeKLDvxCIeoPlRC3j3uA4UU+EFVt+psZdClFv9DX/NZKoN2qI+lcDRI3oWoqoNwKL/ldSctFdHxnzb5ZPUz/5TQNN1D8BNUQ23k2W50PWyybCdAuMm0LUqg7RkyyydjZbTtRSw80EDTcBNfzdEaJG9q8tlvccmZMthJ6zlUR+W4lErbRA7yFkPW0j6brNAFFPAOrwB0yH3CyTRP0HOH/q2B5PdHg7gah3WE7UMu4djhP1BFixpWVp3KUQ9U5f812RRL1TQ9S7DBA1omspot4JLPpdpOSiuz4y5t2WT1Pb/KaBJuptQA2RjXeP5fmQ9bKHMN0C46YQtapD9CSLrJ29lhO11HAvQcM9QA33OULUyP71p+U9R+bkT0LPiUngkJ+8LouolRboPYSsp2IkXYsl8Il6PFCH4jAd0o1+67s4OH/qKJFAdLhEAv66JRPsJmoZd8mE/QKDrmuUqMfjPnYy9q3vUr7mpRNiDqTnUgn/JGr5H7GJejyQqEsBi750Aie56K6PjLlMgt3TVDG/aaCJuhhQQ2TjLWt5PmS9lE3AT7fAuClEreoQPckia6ccWcNQdMdfe7kcQcOyQA2PAWuoDvQ9ANm/ylvec2ROyhN6TgUS+VUgErXSAr2HkPVUkaRrRQNEPQ5I1JVgOqSlmyTqSuD8qaNyAtHhygSirmI5Ucu4qzhO1ONwRJ2rcZdC1FV9zWMjibqqhqhjDRD1OCBRVwUWfWwCJ7noro+MuZrl01RFv2mgiboiUENk442zPB+yXuII0y0wbgpRqzpET7LI2qluOVFLDasTNIwDaljDEaJG9q+alvccmZOahJ4TTyK/eCJRKy3QewhZTwkkXRMMEPVYIFHXws2TGSaJuhY4f+pITCA6nEgg6iTLiVrGneQ4UY/FfTE4R+Muhahr+5onRxJ1bQ1RJxsg6rFAoq4NLPrkBE5y0V0fGXMdy6epBL9poIk6AaghsvGmWJ4PWS8phOkWGDeFqFUdoidZZO3UtZyopYZ1CRqmADU81hGiRvavepb3HJmTeoSeU59EfvWJRK20QO8hZD0dR9L1OANEPQZI1MfDdMgy+utZx4Pzp44TEogOn0Ag6hMtJ2oZ94mOE/UYGFFnGvv1rJN8zU+OJOqTNER9sgGiHgMk6pOARX9yAie56K6PjPkUy6ep4/ymgSbq44AaIhtvA8vzIeulAWG6BcZNIWpVh+hJFlk7p1pO1FLDUwkaNgBqeJojRI3sX6db3nNkTk4n9JwQifxCRKJWWqD3ELKePJKungGiHg0k6rCjRB0G508dqQlEh1MJRJ1mOVHLuNMcJ+rRDhJ1uq95RiRRp2uIOsMAUY8GEnU6sOgzHCFqZMyZlk9Tnt800ETtATVENt4sy/Mh6yWLMN0C46YQtapD9CSLrJ1sy4laaphN0DALqOEZjhA1sn+daXnPkTk5k9BzziKR31lEolZaoPcQsp4aknRtaICoRwGJ+myYDulG3/V9Njh/6jgngejwOQSiPtdyov4rUY4T9SgYUedkadylEPV5vubnRxL1eRqiPt8AUY8CEvV5wKI/P4GTXHTXR8Z8geXTVEO/aaCJuiFQQ2TjbWR5PmS9NCJMt8C4KUSt6hA9ySJrp7HlRC01bEzQsBFQwwsdIWpk/7rI8p4jc3IRoec0IZFfEyJRKy3QewhZT01JujY1QNQjgUTdDEfU+SaJuhk4f+q4OIHo8MUEom5uOVHLuJs7TtQjcUSdqnGXQtQtfM1bRhJ1Cw1RtzRA1COBRN0CWPQtEzjJRXd9ZMyXWD5NNfWbBpqomwI1RDbeVpbnQ9ZLK8J0C4ybQtSqDtGTLLJ2WltO1FLD1gQNWwE1vNQRokb2r8ss7zkyJ5cRek4bEvm1IRK10gK9h5D11Jaka1sDRD0CSNSXw3QIG31GfTk4f+q4IoHo8BUEor7ScqKWcV/pOFGPgBF1vrFn1O18zdtHEnU7DVG3N0DUI4BE3Q5Y9O0TOMlFd31kzFdZPk219ZsGmqjbAjVENt6rLc+HrJerCdMtMG4KUas6RE+yyNrpYDlRSw07EDS8GqjhNY4QNbJ/XWt5z5E5uZbQczqSyK8jkaiVFug9hKynHJKuOQaIejiQqHNhOqSmmiTqXHD+1JGXQHQ4j0DU+ZYTtYw733GiHg4j6rx8jbsUoi7wNS+MJOoCDVEXGiDq4UCiLgAWfWECJ7noro+M+TrLp6kcv2mgiToHqCGy8V5veT5kvVxPmG6BcVOIWtUhepJF1k4ny4laatiJoOH1QA1vcISokf3rRst7jszJjYSecxOJ/G4iErXSAr2HkPXUmaRrZwNEPQxI1DfDdCgw+oz6ZnD+1HFLAtHhWwhEfavlRC3jvtVxoh4GI2rP2DPqLr7mt0USdRcNUd9mgKiHAYm6C7Dob0vgJBfd9ZEx3275NNXZbxpoou4M1BDZeO+wPB+yXu4gTLfAuClEreoQPckia6er5UQtNexK0PAOoIZ3OkLUyP51l+U9R+bkLkLPuZtEfncTiVppgd5DyHrqRtK1mwGiHgok6ntgOqQZJep7wPlTR/cEosPdCUTdw3KilnH3cJyoh8KIOtcYUff0Ne8VSdQ9NUTdywBRDwUSdU9g0fdK4CQX3fWRMfe2fJrq5jcNNFF3A2qIbLx9LM+HrJc+hOkWGDeFqFUdoidZZO30tZyopYZ9CRr2AWrYzxGiRvav/pb3HJmT/oSeM4BEfgOIRK20QO8hZD0NJOk60ABRDwES9SCYDpnZJol6EDh/6hicQHR4MIGoh1hO1DLuIY4T9RAYUWdlatylEPVQX/NhkUQ9VEPUwwwQ9RAgUQ8FFv2wBE5y4Z+jAmMebvk0NdBvGmiiHgjUENl4R1ieD1kvIwjTLTBuClGrOkRPssjaGWk5UUsNRxI0HAHUcJQjRI3sX6Mt7zkyJ6MJPWcMifzGEIlaaYHeQ8h6GkvSdawBoh4MJOpxuCc0Rol6HDh/6hifQHR4PIGoJ1hO1DLuCY4T9WAYUacZI+qJvuaTIol6ooaoJxkg6sFAop4ILPpJCZzkors+MuZ7LZ+mxvpNA03UY4EaIhvvZMvzIetlMmG6BcZNIWpVh+hJFlk7UywnaqnhFIKGk4EaTnWEqJH9a5rlPUfmZBqh50wnkd90IlErLdB7CFlPM0i6zjBA1IOARD0T94w6ZJKoZ4Lzp45ZCUSHZxGIerblRC3jnu04UQ+CEXV2SOMuhajv8zW/P5Ko79MQ9f0GiHoQkKjvAxb9/Qmc5KK7PjLmByyfpmb4TQNN1DOAGiIb7xzL8yHrZQ5hugXGTSFqVYfoSRZZO3MtJ2qp4VyChnOAGj7oCFEj+9c8y3uOzMk8Qs+ZTyK/+USiVlqg9xCynhaQdF1ggKgHAol6IW6e9EwS9UJw/tSxKIHo8CICUS+2nKhl3IsdJ+qBMKLOKNS4SyHqJb7mSyOJeomGqJcaIOqBQKJeAiz6pQmc5KK7PjLmZZZPUwv8poEm6gVADZGNd7nl+ZD1spww3QLjphC1qkP0JIusnRWWE7XUcAVBw+VADVc6QtTI/rXK8p4jc7KK0HNWk8hvNZGolRboPYSspzUkXdcYIOoBQKJ+CPedR6O/nvUQOH/qeDiB6PDDBKJ+xHKilnE/4jhRD8C9mczYr2c96mv+WCRRP6oh6scMEPUAIFE/Ciz6xxI4yUV3fWTMj1s+Ta3xmwaaqNcANUQ23icsz4eslycI0y0wbgpRqzpET7LI2nnScqKWGj5J0PAJoIZPOULUyP71tOU9R+bkaULPeYZEfs8QiVppgd5DyHp6lqTrswaIuj+QqJ+D6VBg9Bn1c+D8qeP5BKLDzxOI+gXLiVrG/YLjRN0f9+tZxp5Rv+hr/lIkUb+oIeqXDBB1fyBRvwgs+pcSOMlFd31kzC9bPk096zcNNFE/C9QQ2XhfsTwfsl5eIUy3wLgpRK3qED3JImvnVcuJWmr4KkHDV4AavuYIUSP71+uW9xyZk9cJPecNEvm9QSRqpQV6DyHr6U2Srm8aIOp+QKJ+C6ZDYbpJon4LnD91vJ1AdPhtAlG/YzlRy7jfcZyo+8GIOpSrcZdC1O/6mr8XSdTvaoj6PQNE3Q9I1O8Ci/69BE5y0V0fGfP7lk9Tb/pNA03UbwI1RDbeDyzPh6yXDwjTLTBuClGrOkRPssja+dByopYafkjQ8AOghh85QtTI/vWx5T1H5uRjQs9ZSyK/tUSiVlqg9xCynj4h6fqJAaLuCyTqT2E6ZBv91ven4Pyp47MEosOfEYj6c8uJWsb9ueNE3Rf3d9TGvvX9ha/5l5FE/YWGqL80QNR9gUT9BbDov0zgJBfd9ZExf2X5NPWJ3zTQRP0JUENk4/3a8nzIevmaMN0C46YQtapD9CSLrJ1vLCdqqeE3BA2/Bmr4rSNEjexf31nec2ROviP0nHUk8ltHJGqlBXoPIetpPUnX9QaIug+QqL/HPaM2+q7v78H5U8cPCUSHfyAQ9Y+WE7WM+0fHiboP7lvfxt71/ZOv+c+RRP2Thqh/NkDUfYBE/ROw6H9O4CQX3fWRMf9i+TS13m8aaKJeD9QQ2Xg3WJ4PWS8bCNMtMG4KUas6RE+yyNrZaDlRSw03EjTcANTwV0eIGtm/frO858ic/EboOZtI5LeJSNRKC/QeQtbTZpKum31dTdJl73hsLOr4PYHo8O8EutxiOV3KuLcQ6FLnK2KDbCFsYuDGo+fbVg2RcW91ZJjYDIx5m+XDhIx1K2GY+MPy4Vvm5Q9yz4lWw+2kwWH7URgcepEGhx0JRId3EAaHnZYPDjLunY4MDrKQdxI2MXDj0fNtq4bIuHc5MjhsB8a82/LBQca6izA47LF8cJB52UPuOdFquJc0OOw18Ay/J/AZ/j7gHjI5LO1L4AxLfyYQHf6TMCzF1LJ7WJJxSx9jsNel+LrX9xX96HAvcsAB5rtYLbtvoLLRSR/RN9DiteyuQxlzcULcJWpxbnryupFfAUFrws4ZYo/LvYkeepD7vaTldS81LEnQsBhQw1JgDdWBHhKR95zSlt8nZE5KE/plGVK/LFOL97hXaYHeQ8h6KkvaQ2gtywL7RvGYAw+0ryfirhVK8a9TTsR/jLDywioIqyiskrDKwqoIqyosVlg1YXHCqgurIaymsHhhCcJqCUsUliSstrBkYXWEpQirK+xYYfWE1Rd2nLDjhZ0g7MRaf4sU3Dfl/DkjuHaMZq28Zq2CZq2iZq2SZq2yZq2KZq2qZi1Ws1ZNsxanWauuWauhWaupWYvXrCVo1mpp1hI1a0matdqatWTNWh3NWopmra5m7VjNWj3NWn3N2nGateM1aydo1k7UzLQl/X+e6/8zFN1xwJ6Ntr+UA/Qq9RXpY4B9b05LTq+PzEU0MctclIfo93deK0R/rbCvn1cRmIu5Nuci7X9+epWiizkUiNmrHM21wgfo51UB5uJBO3MRivDTq3qEMWcU/iNmL/bIrpWl0c+rBszFPNtykaX104s7/Jgz/yVmr/rhXivzX/XzagBzMd+eXIT/w0+v5uHEnPmfMXvxh36tvIPo5yUAc7HAhlxkHtRPr9ahxRw6hJi9xEO5VuiQ9POSgLlYeHRzkX6Ifnq1DxZz2iHH7CX/57XSCg9DP68OMBeLjlYuMg/LTy/l32POOsyYvbr/cq3swsPWzzsWmIvF5nMROgI/vXq6mENHFLNX/5/X8o5QP+84YC6WmMxF/hH76R1/YMypUcTsnRC4VrgwKv28E4G5WGooF6HoDg/4+YAH5FsvyGfR5mKZI7kAcpAHnOO9BcBcLHckF8B5zwPOK95iYC5WOJIL4H3NA/ZlbxkwFytJuUC/CgS4fz1g/Xks/dDfC0DOGCfBnuOmGn0BFM7vA788enItosMn18Jf9xRgMbDiPqXWfoFB1zX6AqgTYcWWb+wFUA18zU/1H8L/76loA78Ig2un1uK/AArRtdTTzQbAoj8VnFzGBm9QC//NqAa13LjbnQDM9WmwmDPSTN7tTiPd7U6vRXT4dMLdLmT53U7GHXL8bncCrNiy8zTuUu52nq95OPJu52nudmEDd7sTgHc7D1j0YVJy0V0fGXMqrntqv/scrX+n+E2jOLgGkWiQBp4W0E1L5jiNMCXZHreqHXTc6Y5Mh8gazyD3iVB0hydzkkHoE2lADTMd2C+ZhP2SBZ7Q1aySFfCVpQW6njKA9ZRN0jW7Fv+P/I8H6nAGTIe0ApPkegY4f+o4sxbR4TMJ5HqW5eQq4z7LcXI9HlZsuWGNuxRybehrfnYkuTbUkOvZBsgV0bUUuTYEFv3ZpOSiuz4y5nMsn0iz/aaBfttGNlBDZOM91/J8/FUvhOkWGDflzQ2qDtGTLLJ2zrOcjKSG5xE0PBeo4fmOfCqB7F8XWN5zZE4uIPScRiTya0QkaqUFeg8h66kxSdfGBoga+U33C2E6ZIZNEvWF4Pyp46JaRIcvIhB1E8uJWsbdxHGiPg5WbFkFGncpRN3U17xZJFE31RB1MwNEjehaiqibAou+GSm56K6PjPliy6epxn7TQBN1Y6CGyMbb3PJ8yHppTphugXFTiFrVIXqSRdZOC8uJWmrYgqBhc6CGLR0hamT/usTyniNzcgmh57QikV8rIlErLdB7CFlPrUm6tjZA1PWBOlwK06HA6IvoLwXnTx2X1SI6fBmBqNtYTtQy7jaOE3V9WLF5hRp3KUTd1tf88kiibqsh6ssNEDWiaymibgss+stJyUV3fWTMV1g+TbX2mwaaqFsDNUQ23istz4eslysJ0y0wbgpRqzpET7LI2mlnOVFLDdsRNLwSqGF7R4ga2b+usrznyJxcReg5V5PI72oiUSst0HsIWU8dSLp2MEDU9YA6XAPTIdUoUV8Dzp86rq1FdPhaAlF3tJyoZdwdHSfqerBiyzNG1Dm+5rmRRJ2jIepcA0SN6FqKqHOARZ9LSi666yNjzrN8murgNw00UXcAaohsvPmW50PWSz5hugXGTSFqVYfoSRZZOwWWE7XUsICgYT5Qw0JHiBrZv66zvOfInFxH6DnXk8jveiJRKy3QewhZT51IunYyQNTId83fANMhx+j7Lm8A508dN9YiOnwjgahvspyoZdw3OU7Ux8KKLcPY+y47+5rfHEnUnTVEfbMBokZ0LUXUnYFFfzMpueiuj4z5FsunqU5+00ATdSeghsjGe6vl+ZD1cithugXGTSFqVYfoSRZZO10sJ2qpYReChrcCNbzNEaJG9q/bLe85Mie3E3rOHSTyu4NI1EoL9B5C1lNXkq5dDRB1XaAOd8J0CGebJOo7wflTx121iA7fRSDquy0nahn33Y4TdV1YseVnatylEHU3X/N7Iom6m4ao7zFA1IiupYi6G7Do7yElF931kTF3t3ya6uo3DTRRdwVqiGy8PSzPh6yXHoTpFhg3hahVHaInWWTt9LScqKWGPQka9gBq2MsRokb2r96W9xyZk96EntOHRH59iESttEDvIWQ99SXp2tcAUacAdegH0yE3yyRR9wPnTx39axEd7k8g6gGWE7WMe4DjRJ0CK7a0LI27FKIe6Gs+KJKoB2qIepABokZ0LUXUA4FFP4iUXHTXR8Y82PJpqq/fNNBE3ReoIbLxDrE8H7JehhCmW2DcFKJWdYieZJG1M9RyopYaDiVoOASo4TBHiBrZv4Zb3nNkToYTes4IEvmNIBK10gK9h5D1NJKk60gDRF0HqMMomA7pRr/1PQqcP3WMrkV0eDSBqMdYTtQy7jGOE3Ud3MdOxr71PdbXfFwkUY/VEPU4A0SN6FqKqMcCi34cKbnoro+Mebzl09RIv2mgiXokUENk451geT5kvUwgTLfAuClEreoQPckia2ei5UQtNZxI0HACUMNJjhA1sn/da3nPkTm5l9BzJpPIbzKRqJUW6D2ErKcpJF2nGCDqZKAOU3FPaNJNEvVUcP7UMa0W0eFpBKKebjlRy7inO07UyTjoytW4SyHqGb7mMyOJeoaGqGcaIGpE11JEPQNY9DNJyUV3fWTMsyyfpqb4TQNN1FOAGiIb72zL8yHrZTZhugXGTSFqVYfoSRZZO/dZTtRSw/sIGs4Gani/I0SN7F8PWN5zZE4eIPScOSTym0MkaqUFeg8h62kuSde5Boi6NlCHB3HzZIZJon4QnD91zKtFdHgegajnW07UMu75jhN1bdzHTjkadylEvcDXfGEkUS/QEPVCA0SN6FqKqBcAi34hKbnoro+MeZHl09Rcv2mgiXouUENk411seT5kvSwmTLfAuClEreoQPckia2eJ5UQtNVxC0HAxUMOljhA1sn8ts7znyJwsI/Sc5STyW04kaqUFeg8h62kFSdcVBog6CajDSpgOWUZ/PWslOH/qWFWL6PAqAlGvtpyoZdyrHSfqJFixZRr79aw1vuYPRRL1Gg1RP2SAqBFdSxH1GmDRP0RKLrrrI2N+2PJpaoXfNNBEvQKoIbLxPmJ5PmS9PEKYboFxU4ha1SF6kkXWzqOWE7XU8FGCho8ANXzMEaJG9q/HLe85MiePE3rOEyTye4JI1EoL9B5C1tOTJF2fNEDUiUAdnnKUqJ8C508dT9ciOvw0gaifsZyoZdzPOE7UiQ4S9bO+5s9FEvWzGqJ+zgBRI7qWIupngUX/nCNEjYz5ecunqSf9poEm6ieBGiIb7wuW50PWywuE6RYYN4WoVR2iJ1lk7bxoOVFLDV8kaPgCUMOXHCFqZP962fKeI3PyMqHnvEIiv1eIRK20QO8hZD29StL1VQNEXQuow2swHdKNvuv7NXD+1PF6LaLDrxOI+g3LiVrG/YbjRF0LVmw5xt71/aav+VuRRP2mhqjfMkDUiK6liPpNYNG/RUouuusjY37b8mnqVb9poIn6VaCGyMb7juX5kPXyDmG6BcZNIWpVh+hJFlk771pO1FLDdwkavgPU8D1HiBrZv963vOfInLxP6DkfkMjvAyJRKy3QewhZTx+SdP3QAFEnAHX4CEfU+SaJ+iNw/tTxcS2iwx8TiHqt5UQt417rOFEn4KArVeMuhag/8TX/NJKoP9EQ9acGiBrRtRRRfwIs+k9JyUV3fWTMn1k+TX3oNw00UX8I1BDZeD+3PB+yXj4nTLfAuClEreoQPckia+cLy4laavgFQcPPgRp+6QhRI/vXV5b3HJmTrwg952sS+X1NJGqlBXoPIevpG5Ku3xgg6nigDt/CdAgbfUb9LTh/6viuFtHh7whEvc5yopZxr3OcqONhxZZv7Bn1el/z7yOJer2GqL83QNSIrqWIej2w6L8nJRfd9ZEx/2D5NPWN3zTQRP0NUENk4/3R8nzIevmRMN0C46YQtapD9CSLrJ2fLCdqqeFPBA1/BGr4syNEjexfv1jec2ROfiH0nA0k8ttAJGqlBXoPIetpI0nXjQaIuiZQh19hOqSmmiTqX8H5U8dvtYgO/0Yg6k2WE7WMe5PjRF0TVmx5+Rp3KUS92df890ii3qwh6t8NEDWiaymi3gws+t9JyUV3fWTMWyyfpjb6TQNN1BuBGiIb71bL8yHrZSthugXGTSFqVYfoSRZZO9ssJ2qp4TaChluBGv7hCFEj+9d2y3uOzMl2Qs/ZQSK/HUSiVlqg9xCynnaSdN1pgKhrAHXYBdOhwOgz6l3g/Kljdy2iw7sJRL3HcqKWce9xnKhrwIrNM/aMeq+v+b5Iot6rIep9Boga0bUUUe8FFv0+UnLRXR8Z85+WT1M7/aaBJuqdQA2hjTfR7nzIepE+oqdbYNwUolZ1iJ5kkbVTjKxhKLrjr70sfURrGKydaDUsDtZQHeh7ALJ/lbC858iclCD0nJLAXAdnqJKJPKJWWqD3ELKeSpF0LZXIJ+rqQB1Kw3RIM0rUpcH5U0eZRKLDZRLx1y0LvLGw4i6buF9g0HWNEnV1GIDkGiPqcr7mxyTGHEjP5RL/SdTyP2ITdXUgUZcDFv0xiZzkors+Mubylk9TpfymgSbqUkANkY23guX5kPVSgTDdVgCTDNo/VYfoSRZZOxUtJ2qpYUWChhWAGlZyhKiR/auy5T1H5qQyoedUIZFfFSJRKy3QewhZT1VJulY1QNRxQKKOhemQmW2SqGPB+VNHtUSiw9UIRB1nOVHLuOMcJ+o4GFFnZWrcpRB1dV/zGpFEXV1D1DUMEHUckKirA4u+RiInufDPUYEx17R8mqrqNw00UVcFaohsvPGW50PWSzxhugXGTSFqVYfoSRZZOwmWE7XUMIGgYTxQw1qOEDWyfyVa3nNkThIJPSeJRH5JRKJWWqD3ELKeapN0rW2AqKsBiToZ94TGKFEng/OnjjqJRIfrEIg6xXKilnGnOE7U1WBEnWaMqOv6mh8bSdR1NUR9rAGirgYk6rrAoj82kZNcdNdHxlzP8mmqtt800ERdG6ghsvHWtzwfsl7qE6ZbYNwUolZ1iJ5kkbVznOVELTU8jqBhfaCGxztC1Mj+dYLlPUfm5ARCzzmRRH4nEolaaYHeQ8h6Oomk60kGiDoWSNQn455Rh0wS9cng/KnjlESiw6cQiLqB5UQt427gOFHHwog6O6Rxl0LUp/qanxZJ1KdqiPo0A0QdCyTqU4FFf1oiJ7noro+M+XTLp6mT/KaBJuqTgBoiG2/I8nzIegkRpltg3BSiVnWInmSRteNZTtRSQ4+gYQioYdgRokb2r1TLe47MSSqh56SRyC+NSNRKC/QeQtZTOknXdANEXRVI1Bm4edIzSdQZ4PypIzOR6HAmgaizLCdqGXeW40RdFUbUGYUadylEne1rfkYkUWdriPoMA0RdFUjU2cCiPyORk1x010fGfKbl01S63zTQRJ0O1BDZeM+yPB+yXs4iTLfAuClEreoQPckia6eh5UQtNWxI0PAsoIZnO0LUyP51juU9R+bkHELPOZdEfucSiVppgd5DyHo6j6TreQaIugqQqM/HfefR6K9nnQ/OnzouSCQ6fAGBqBtZTtQy7kaOE3UV3JvJjP16VmNf8wsjibqxhqgvNEDUVYBE3RhY9BcmcpKL7vrImC+yfJo6z28aaKI+D6ghsvE2sTwfsl6aEKZbYNwUolZ1iJ5kkbXT1HKilho2JWjYBKhhM0eIGtm/Lra858icXEzoOc1J5NecSNRKC/QeQtZTC5KuLQwQdWUgUbeE6VBg9Bl1S3D+1HFJItHhSwhE3cpyopZxt3KcqCvjfmDJ2DPq1r7ml0YSdWsNUV9qgKgrA4m6NbDoL03kJBfd9ZExX2b5NNXCbxpoom4B1BDZeNtYng9ZL20I0y0wbgpRqzpET7LI2mlrOVFLDdsSNGwD1PByR4ga2b+usLznyJxcQeg5V5LI70oiUSst0HsIWU/tSLq2M0DUlYBE3R6mQ2G6SaJuD86fOq5KJDp8FYGor7acqGXcVztO1JVwP9+bq3GXQtQdfM2viSTqDhqivsYAUVcCEnUHYNFfk8hJLrrrI2O+1vJpqp3fNNBE3Q6oIbLxdrQ8H7JeOhKmW2DcFKJWdYieZJG1k2M5UUsNcwgadgRqmOsIUSP7V57lPUfmJI/Qc/JJ5JdPJGqlBXoPIeupgKRrgQGirggk6kKYDtlGv/VdCM6fOq5LJDp8HYGor7ecqGXc1ztO1BVxf0dt7FvfnXzNb4gk6k4aor7BAFFXBBJ1J2DR35DISS666yNjvtHyaarAbxpooi4AaohsvDdZng9ZLzcRpltg3BSiVnWInmSRtdPZcqKWGnYmaHgTUMObHSFqZP+6xfKeI3NyC6Hn3Eoiv1uJRK20QO8hZD11IenaxQBRVwAS9W24Z9RG3/V9Gzh/6rg9kejw7QSivsNyopZx3+E4UVfAfevb2Lu+u/qa3xlJ1F01RH2nAaKuACTqrsCivzORk1x010fGfJfl01QXv2mgiboLUENk473b8nzIermbMN0C46YQtapD9CSLrJ1ulhO11LAbQcO7gRre4whRI/tXd8t7jsxJd0LP6UEivx5EolZaoPcQsp56knTt6etqki7L18LGoo5eiUSHexHosrfldCnj7k2gS52viA3Sm7CJgRuPnm9bNUTG3ceRYaInMOa+lg8TMtY+hGGin+XDt8xLP3LPiVbD/qTBof9RGByOIQ0OAxKJDg8gDA4DLR8cZNwDHRkcZCEPJGxi4Maj59tWDZFxD3JkcOgPjHmw5YODjHUQYXAYYvngIPMyhNxzotVwKGlwGGrgGX454DP8YcA9ZHJYGpbIGZaGJxIdHk4YlkZYPizJuEcYGpZC0R3eUN9X9KPDocAcIfM90vIbqGx0Iwk30FGW30BlzKMIcY8m3fRGa74CgtaEnTPEHh9BGHqQ+32M5XUvNRxD0HAkUMOxjoAW8p4zzvL7hMzJOEK/HE/ql+OJj3uVFug9hKynCaQ9hNZyAni2ZvnZqThOz+IxBx5oX68D+priX2eiyNMkYfcKmyxsirCpwqYJmy5shrCZwmYJmy3sPmH3C3tA2Bxhc4U9KGyesPnCFghbKGyRsMXClghbKmyZsOXCVghbKWyVsNWJf4sU3N8T/XkouDZJs3avZm2yZm2KZm2qZm2aZm26Zm2GZm2mZm2WZm22Zu0+zdr9mrUHNGtzNGtzNWsPatbmadbma9YWaNYWatYWadYWa9aWaNaWataWadaWa9ZWaNZWatZWadZWa2bvkv4/z/X/GYruOGDPRtsHJwJ6qvoq9yRgf36uJeeeFJmLaGKWubgXot/feZ0c/bXCvn7eFGAunrc5F2n/89ObGl3MoUDM3rRorhU+QD9vOjAXL9iZi1CEn96MI4w5o/AfMXszj+xaWRr9vFnAXLxoWy6ytH56sw8/5sx/idm773Cvlfmv+nn3A3Pxkj25CP+Hn94DhxNz5n/G7M059GvlHUQ/by4wFy/bkIvMg/rpPXhoMYcOIWZv3qFcK3RI+nnzgbl45ejmIv0Q/fQWHCzmtEOO2Vv4n9dKKzwM/bxFwFy8erRykXlYfnqL/z3mrMOM2VvyL9fKLjxs/bylwFy8Zj4XoSPw01umizl0RDF7y/95Le8I9fNWAHPxuslc5B+xn97KA2NOjSJmb1XgWuHCqPTzVgNz8YahXISiOzzg5wMekG+9IJ9Fm4s3HckFkIM84BzvvQzMxVuO5AI473nAecV7DZiLtx3JBfC+5gH7svcmMBfvkHKBfmUJcP96wPrzkPrJ+r1YWIp/vdX+M7GV/jOy5f4zs6X+M7TF/jO1hf4ztvn+M7cH/Wdwc/xncvf7z+hm+8/sZvrP8Kb7z/Sm+s/4JvvP/ORzAPlcIfJAf6cCOfesSUTlIdXoy7Nwfh/4xduHEokOy4ujr/swsBhYcT8c2BSg6xp9edZqWLHlG3t51iO+5o/6Xwz435PaR/wiDK49msh/eRaia6knro8Ai/5RcHIZG/yRRPy3yh5J5Eww6LvdKmCuH4PFnJFm8m73GOlu93gi0eHHCXe7Jyy/28m4n3D8brcKVmzZeRp3KXe7J33Nn4q82z2puds9ZeButwp4t3sSWPRPkZKL7vrImJ/GdU/t98aj9e9hv2kUB9cgEg2eAU8L6KYlc/wMYUqyPW5VO+i4n3VkOkTW+HPkPhGK7vBkTp4j9IlnkN+ZdGC/PE/YLy+AJ3Q1q7wQ8JWlBbqenkN+15Ck64uJ/BckrER+zw+mQ1qBSXJ9CZw/dbycSHT4ZQK5vmI5ucq4X3GcXFfCii03rHGXQq6v+pq/Fkmur2rI9TUD5IroWopcX0V+c42UXHTXR8b8uuUT6Yt+00C/qeRFoIbIxvuG5fmQ9fIGYboFxk1564WqQ/Qki6ydNy0nI6nhmwQN3wBq+JYjn0og+9fblvccmZO3CT3nHRL5vUMkaqUFeg8h6+ldkq7vGiBq5Lfv34PpkBk2SdTvgfOnjvcTiQ6/TyDqDywnahn3B44T9QpYsWUVaNylEPWHvuYfRRL1hxqi/sgAUSO6liLqD4FF/xEpueiuj4z5Y8unqXf9poEm6neBGiIb71rL8yHrZS1hugXGTSFqVYfoSRZZO59YTtRSw08IGq4FavipI0SN7F+fWd5zZE4+I/Scz0nk9zmRqJUW6D2ErKcvSLp+YYColwN1+BKmQ4HRl/h/Cc6fOr5KJDr8FYGov7acqGXcXztO1MthxeYVatylEPU3vubfRhL1Nxqi/tYAUSO6liLqb4BF/y0pueiuj4z5O8unqS/8poEm6i+AGiIb7zrL8yHrZR1hugXGTSFqVYfoSRZZO+stJ2qp4XqChuuAGn7vCFEj+9cPlvccmZMfCD3nRxL5/UgkaqUFeg8h6+knkq4/GSDqZUAdfobpkGqUqH8G508dvyQSHf6FQNQbLCdqGfcGx4l6GazY8owR9UZf818jiXqjhqh/NUDUiK6liHojsOh/JSUX3fWRMf9m+TT1k9800ET9E1BDZOPdZHk+ZL1sIky3wLgpRK3qED3JImtns+VELTXcTNBwE1DD3x0hamT/2mJ5z5E52ULoOVtJ5LeVSNRKC/QeQtbTNpKu2wwQNfL993/AdMgx+r7LP8D5U8f2RKLD2wlEvcNyopZx73CcqJfCii3D2Psud/qa74ok6p0aot5lgKgRXUsR9U5g0e8iJRfd9ZEx77Z8mtrmNw00UW8DaohsvHssz4eslz2E6RYYN4WoVR2iJ1lk7ey1nKilhnsJGu4BarjPEaJG9q8/Le85Mid/EnpOTBKH/OR1WUSttEDvIWQ9FSPpWiyJT9RLgDoUh+kQzjZJ1MXB+VNHiSSiwyWS8NctmWQ3Ucu4SybtFxh0XaNEvQR288nP1LhLIepSvualk2IOpOdSSf8kavkfsYl6CZCoSwGLvnQSJ7noro+MuUyS3dNUMb9poIm6GFBDZOMta3k+ZL2UTcJPt8C4KUSt6hA9ySJrpxxZw1B0x197uRxBw7JADY8Ba6gO9D0A2b/KW95zZE7KE3pOBRL5VSAStdICvYeQ9VSRpGtFA0S9GEjUlWA65GaZJOpK4Pypo3IS0eHKBKKuYjlRy7irOE7Ui2FEnZalcZdC1FV9zWMjibqqhqhjDRD1YiBRVwUWfWwSJ7noro+MuZrl01RFv2mgiboiUENk442zPB+yXuII0y0wbgpRqzpET7LI2qluOVFLDasTNIwDaljDEaJG9q+alvccmZOahJ4TTyK/eCJRKy3QewhZTwkkXRMMEPUiIFHXgumQbvRb37XA+VNHYhLR4UQCUSdZTtQy7iTHiXoRjKhzjX3ru7aveXIkUdfWEHWyAaJeBCTq2sCiT07iJBfd9ZEx17F8mkrwmwaaqBOAGiIbb4rl+ZD1kkKYboFxU4ha1SF6kkXWTl3LiVpqWJegYQpQw2MdIWpk/6pnec+ROalH6Dn1SeRXn0jUSgv0HkLW03EkXY8zQNQLgUR9PO4JTbpJoj4enD91nJBEdPgEAlGfaDlRy7hPdJyoF+KIOlfjLoWoT/I1PzmSqE/SEPXJBoh6IZCoTwIW/clJnOSiuz4y5lMsn6aO85sGmqiPA2qIbLwNLM+HrJcGhOkWGDeFqFUdoidZZO2cajlRSw1PJWjYAKjhaY4QNbJ/nW55z5E5OZ3Qc0Ik8gsRiVppgd5DyHrySLp6Boh6AZCow7h5MsMkUYfB+VNHahLR4VQCUadZTtQy7jTHiXoB7lvfORp3KUSd7mueEUnU6RqizjBA1AuARJ0OLPqMJE5y0V0fGXOm5dOU5zcNNFF7QA2RjTfL8nzIeskiTLfAuClEreoQPckiayfbcqKWGmYTNMwCaniGI0SN7F9nWt5zZE7OJPScs0jkdxaRqJUW6D2ErKeGJF0bGiDq+UCiPhumQ5bRX886G5w/dZyTRHT4HAJRn2s5Uf+VKMeJej6MqDON/XrWeb7m50cS9Xkaoj7fAFHPBxL1ecCiPz+Jk1x010fGfIHl01RDv2mgibohUENk421keT5kvTQiTLfAuClEreoQPckia6ex5UQtNWxM0LARUMMLHSFqZP+6yPKeI3NyEaHnNCGRXxMiUSst0HsIWU9NSbo2NUDU84BE3cxRom4Gzp86Lk4iOnwxgaibW07UMu7mjhP1PAeJuoWvectIom6hIeqWBoh6HpCoWwCLvqUjRI2M+RLLp6mmftNAE3VToIbIxtvK8nzIemlFmG6BcVOIWtUhepJF1k5ry4laatiaoGEroIaXOkLUyP51meU9R+bkMkLPaUMivzZEolZaoPcQsp7aknRta4CoHwQS9eUwHdKNvuv7cnD+1HFFEtHhKwhEfaXlRC3jvtJxon4Q96Ptxt713c7XvH0kUbfTEHV7A0T9IJCo2wGLvn0SJ7noro+M+SrLp6m2ftNAE3VboIbIxnu15fmQ9XI1YboFxk0halWH6EkWWTsdLCdqqWEHgoZXAzW8xhGiRvavay3vOTIn1xJ6TkcS+XUkErXSAr2HkPWUQ9I1xwBRzwUSdS6OqPNNEnUuOH/qyEsiOpxHIOp8y4laxp3vOFHPxRF1qsZdClEX+JoXRhJ1gYaoCw0Q9VwgURcAi74wiZNcdNdHxnyd5dNUjt800ESdA9QQ2Xivtzwfsl6uJ0y3wLgpRK3qED3JImunk+VELTXsRNDweqCGNzhC1Mj+daPlPUfm5EZCz7mJRH43EYlaaYHeQ8h66kzStbMBop4DJOqbYTqEjT6jvhmcP3XckkR0+BYCUd9qOVHLuG91nKjnwIg639gz6i6+5rdFEnUXDVHfZoCo5wCJuguw6G9L4iQX3fWRMd9u+TTV2W8aaKLuDNQQ2XjvsDwfsl7uIEy3wLgpRK3qED3JImunq+VELTXsStDwDqCGdzpC1Mj+dZflPUfm5C5Cz7mbRH53E4laaYHeQ8h66kbStZsBon4ASNT3wHRITTVJ1PeA86eO7klEh7sTiLqH5UQt4+7hOFE/ACPqvHyNuxSi7ulr3iuSqHtqiLqXAaJ+AEjUPYFF3yuJk1x010fG3Nvyaaqb3zTQRN0NqCGy8faxPB+yXvoQpltg3BSiVnWInmSRtdPXcqKWGvYlaNgHqGE/R4ga2b/6W95zZE76E3rOABL5DSAStdICvYeQ9TSQpOtAA0R9P5CoB8F0KDD6jHoQOH/qGJxEdHgwgaiHWE7UMu4hjhP1/TCi9ow9ox7qaz4skqiHaoh6mAGivh9I1EOBRT8siZNcdNdHxjzc8mlqoN800EQ9EKghsvGOsDwfsl5GEKZbYNwUolZ1iJ5kkbUz0nKilhqOJGg4AqjhKEeIGtm/Rlvec2RORhN6zhgS+Y0hErXSAr2HkPU0lqTrWANEfR+QqMfBdEgzStTjwPlTx/gkosPjCUQ9wXKilnFPcJyo74MRda4xop7oaz4pkqgnaoh6kgGivg9I1BOBRT8piZNcdNdHxnyv5dPUWL9poIl6LFBDZOOdbHk+ZL1MJky3wLgpRK3qED3JImtniuVELTWcQtBwMlDDqY4QNbJ/TbO858icTCP0nOkk8ptOJGqlBXoPIetpBknXGQaIejaQqGfCdMjMNknUM8H5U8esJKLDswhEPdtyopZxz3acqGfDiDorU+Muhajv8zW/P5Ko79MQ9f0GiHo2kKjvAxb9/Umc5MI/RwXG/IDl09QMv2mgiXoGUENk451jeT5kvcwhTLfAuClEreoQPckia2eu5UQtNZxL0HAOUMMHHSFqZP+aZ3nPkTmZR+g580nkN59I1EoL9B5C1tMCkq4LDBD1LCBRL8Q9oTFK1AvB+VPHoiSiw4sIRL3YcqKWcS92nKhnwYg6zRhRL/E1XxpJ1Es0RL3UAFHPAhL1EmDRL03iJBfd9ZExL7N8mlrgNw00US8AaohsvMstz4esl+WE6RYYN4WoVR2iJ1lk7aywnKilhisIGi4HarjSEaJG9q9VlvccmZNVhJ6zmkR+q4lErbRA7yFkPa0h6brGAFHPBBL1Q7hn1CGTRP0QOH/qeDiJ6PDDBKJ+xHKilnE/4jhRz4QRdXZI4y6FqB/1NX8skqgf1RD1YwaIeiaQqB8FFv1jSZzkors+MubHLZ+m1vhNA03Ua4AaIhvvE5bnQ9bLE4TpFhg3hahVHaInWWTtPGk5UUsNnyRo+ARQw6ccIWpk/3ra8p4jc/I0oec8QyK/Z4hErbRA7yFkPT1L0vVZA0Q9A0jUz+HmSc8kUT8Hzp86nk8iOvw8gahfsJyoZdwvOE7UM2BEnVGocZdC1C/6mr8USdQvaoj6JQNEPQNI1C8Ci/6lJE5y0V0fGfPLlk9Tz/pNA03UzwI1RDbeVyzPh6yXVwjTLTBuClGrOkRPssjaedVyopYavkrQ8BWghq85QtTI/vW65T1H5uR1Qs95g0R+bxCJWmmB3kPIenqTpOubBoh6OpCo38J959Hor2e9Bc6fOt5OIjr8NoGo37GcqGXc7zhO1NNxbyYz9utZ7/qavxdJ1O9qiPo9A0Q9HUjU7wKL/r0kTnLRXR8Z8/uWT1Nv+k0DTdRvAjVENt4PLM+HrJcPCNMtMG4KUas6RE+yyNr50HKilhp+SNDwA6CGHzlC1Mj+9bHlPUfm5GNCz1lLIr+1RKJWWqD3ELKePiHp+okBop4GJOpPYToUGH1G/Sk4f+r4LIno8GcEov7ccqKWcX/uOFFPw/16lrFn1F/4mn8ZSdRfaIj6SwNEPQ1I1F8Ai/7LJE5y0V0fGfNXlk9Tn/hNA03UnwA1RDbery3Ph6yXrwnTLTBuClGrOkRPssja+cZyopYafkPQ8Gught86QtTI/vWd5T1H5uQ7Qs9ZRyK/dUSiVlqg9xCyntaTdF1vgKinAon6e5gOhekmifp7cP7U8UMS0eEfCET9o+VELeP+0XGingoj6lCuxl0KUf/ka/5zJFH/pCHqnw0Q9VQgUf8ELPqfkzjJRXd9ZMy/WD5NrfebBpqo1wM1RDbeDZbnQ9bLBsJ0C4ybQtSqDtGTLLJ2NlpO1FLDjQQNNwA1/NURokb2r98s7zkyJ78Res4mEvltIhK10gK9h5D1tJmk62YDRD0FSNS/w3TINvqt79/B+VPHliSiw1sIRL3VcqKWcW91nKin4P6O2ti3vrf5mv8RSdTbNET9hwGingIk6m3Aov8jiZNcdNdHxrzd8mlqs9800ES9GaghsvHusDwfsl52EKZbYNwUolZ1iJ5kkbWz03KilhruJGi4A6jhLkeIGtm/dlvec2ROdhN6zh4S+e0hErXSAr2HkPW0l6TrXgNEPRlI1Ptwz6iNvut7Hzh/6vgziejwnwSijqltN1HLuKWPMdjrGiXqybhvfRt713cxX/PitWMOpGf5LyKJWv5HbKKeDCTqYsCiL16bk1x010fGXKI2sAHF4DfcXr9poIl6L/LjR2A+SlqeD1kvJWvjp1tg3BSiVnWInmSRtVOKrGEouuOvvVyKoGFJoIalwRqqA30PQPavMpb3HJmTMoSeUxaY6+AMVbY2j6iVFug9hKynciRdy/m6mqTLexOxsajjmNpEh4+pjb9uecvpUsZdnkCXOl8RG6Q8YRMDNx4937ZqiIy7giPDRDlgzBUtHyZkrBUIw0Qly4dvmZdK5J4TrYaVSYND5aMwOEwiDQ5VahMdrkIYHKpaPjjIuKs6MjjIQq5K2MTAjUfPt60aIuOOdWRwqAyMuZrlg4OMNZYwOMRZPjjIvMSRe060GlYnDQ7Va/Of4U8EPsOvAdxDJoelGrU5w1LN2kSHaxKGpXjLhyUZd7yhYSkU3eFV931FPzqsDswRMt8Jlt9AZaNLINxAa1l+A5Ux1yLEnUi66SVqvgKC1oSdM8QejycMPcj9nmR53UsNkwgaJgA1rO0IaCHvOcmW3ydkTpIJ/bIOqV/WIT7uVVqg9xCynlJIewitZQp4tlYHeq9fXxx3rbqBmL2s1HA4M1X+d1n5IS8tPy+cFQ7n56aF8kI5eeGC7DQvuzAtnJaal5+XK66Z4xWGCnPysguz/r6WSSCsSwLCY2sTHT6WAIT1LAdCGXc9AhDKYpNWPIZfbMENF4ry0LgL24DBQq4f/GQKfaesB5wQgnfK+v9xpzyIz3kHEeevjVL/CO6UBxO9PnADHkeaQOR1+xxhLXhCuzwvVBjKDodyQpl5GZm52fnh3KycwtTC9NT81CPV9WDFjtT1eJKuxx+5rv9f1OsJJF1P+D9eryeSdD3R11XdOE1MasibZ/Bmf5I/VJws7xmMG1x9wrRW3/KPtY50c4QOI+5ofTzF8o+1ZGGeQvh4ogGpKTT4j2Ybiu7wTiZpcSpJi1OJWshGyNDi65Z29xTWfvjm6MaddxD/aLX/LThudaD/ihdYlx4w1x5SPzlIlY7RfwoRc5h6Hqyegtdk3LNQmgSHytP+61OIUHSHdwrpJnDakX9e7x3s/4/0+TRCU/ie1BRKHmbODmd4izbm02vb2WCQuQjW5emB4eRI83MwzZH5CQWfLaSmir2Rn+kV5hempmdmh3O9jNSMjMK0wsyMrLT8wvS0nPzMAi8tJzWcXZAZKvSyCgoy01PzMjMKs/PzMgqDTdvLT01Ny8/OzfPSwxk5uaGs/NScUGFaZqoA/vzUzPz81KyMjJzU1PyMrMKsbAHpAv2zQumZmdmhjHBqdpiVn1CArlE3hYN9mhO8pis3Bc/Fm4JHvil4hJvCj5bcFP61iDP/eklLIbLphC29KfxIajphwE3hYB9tIvOTaulNgZWf1P+PPnJN8z9yTdd95BqK7vjX5x3IZ5XRXgv48S3lm1FKQ/Q3mlkaRnutDMvzITdMBuHGnkkacjKJH3+mk7TIImmRRf4omKHFz5Z/FMzaD79Y/lEwq/Y3OPJRMLAuPWCuvQ1FHwVHHn/ds1CaBIfdbCb1Z5BuAtlE6pc+ZxOawiZHPgrOAA6CZ9S2s8FsIlHlGQY+Ckbm50wg9W8AUj8rP2dq8nO436k52Ee/yPycReqfZwF0ONinU0gdGpJ0aOhYPZxN0uFsx+rhHJIO5xzCoyKbBzuNu7A6Dg6N57o4NJ5LHhrPJQyNvxsaGqP8Vjy0yZ0HvBZyaPydNJScdwhDY7Tfrkfm5/zauEEPOTSy8nM+4OZ4kMNbDXyZ0AWw/plF+SJ2Pf9TN/QTJWSNN7L8CYbMcSPC/aYx6d4rr1vW/98Xx/zzQP3/VNdD631Fcft9vBA9SLpStFstf7wiY76QEPc2Sz5RPMhxQGFGG/NFwMYMrBsPmQtyk/zfY4r/i03yov+rTbKJ5X+eJ2NuQoi7KWmiaVp7/9vWGH/uqZuQQ9EdHnJCbmZ5PUmiakaop4sd2EcXE+JuTtpHzf9jH4WiO2g9ZUfL/5s1sNPQ91qi9bMFcEgE5trbSfqEqkURXdN9bMkeHBGU2ZKw6fc4QpktHdj0Uf96pCMN+BJgLoD15+0tonQnmu0lyGbr6l3xovL2+9iqKFEhr4MDO6p1UaJCXjMHdtSlRYkKec0dSNRlRYkSQ7cDiWpTlChxo3YgUW2LEiX6vwOJurwoUaKtOJCoK4oSJarVgURdWZQoIYIDiWpXlKiQ196BRLUvSlTIu9qBRF1VlKiQd40Dibq6KFEhr6MDiepQlKiQt9iBD2WvKUpUyMtzYEddW5SokFfgQKI6FiUq5F3nQKJyihIV8jo5kKjcokSFvBsdSFReUaJCXmcHEpVflKiQd4sDiSooSlTI6+JAogqLEhXybncgUdcVJSrkdXUgUdcXJSrk3eVAojoVJSrkdXMgUTcUJSrkdXcgUTcWJSrk9XQgUTcVJSrk9XYgUZ2LEhXy+jqQqJtZr6JE/03iLTBHUzOZft565H6mRy5I32rE7P+7Sfm/pQ77/PONNfafbwic3+r/N+r/rov437cJu13YHbX3r6sD/SMD95QDfhgBfIFFV1Kxo/XrDtTvNqB+d4JfCBFZ210DtX1n4Pz2wPkdEbV9l/jfdwvrJuwev7aLxxx4wCkRqEOKf53u4po9hPUU1ktYb/kKSmF9hfUT1l/YAGEDhQ0SNljYEGFDhQ0TNlzYCGEjhY0SNlrYGGFjhY0TNl7YBGEThU0Sdq+wycKmCJta+2+Rgi8Y6O6/YCC41kOz1lOz1kuz1luz1kez1lez1k+z1l+zNkCzNlCzNkizNlizNkSzNlSzNkyzNlyzNkKzNlKzNkqzNlqzNkazNlazNk6zNl6zNkGzNlGzNkmzdq9mbbJmbYpmbWrt/S+EUQf6XQF3Aftgd8C1Cv76vc2Q1wPoV8wlnPvb4b6a+L9ilrnoCdHv77z2iv5aYfVjPr2BuShmcy7S9v+AUZ/oYg4FfwypbzTXCh/4w0r9gLkobmcuQpE/JtX/CGPOKPznD1MNOLJrZel+5GogMBclbMtFlv6HvQYdfsyZ//YjYYMP91qZ//6DY0OAuShpTy7C//Uja0MPJ+bM//7BtmGHfq2D/pjgcGAuStmQi8yD+umNOLSYQ4cQszfyUK4VOiT9vFHAXJQ+urlIP0Q/vdEHizntkGP2xvzntdIKD0M/bywwF2WOVi4yD8tPb9y/x5x1mDF74//lWtmFh62fNwGYi7LmcxE6Aj+9ibqYQ0cUszfpn9fyjlA/715gLsqZzEX+EfvpTT4w5tQoYvamBK4VLoxKP28qMBfHGMpFKLrDA34+4AH51gvyWbS5KO9ILoAc5AHneK8UMBcVHMkFcN7zgPOKVxaYi4qO5AJ4X/OAfdkrD8xFJVIu0M8hgfvXA9afx9KveIR+0eYZOWNMw33/ISR/67RCzP7nosED/awU5/eBv0c6vTbRYXlx9HVnIB/0kOKeUXu/wKDr/lVsFWPM/LDuVFix5Yc07mKu7YkHEoFrzvQ1n+U/hP/fU9GZfhEG12ZpnpSiuz6ia6mnmzOBRT8LnFzGBp9ZG/+Nspm13bjbTQHmejYs5ow0k3e72aS73X21iQ7fR7jb3W/53U7Gfb/jd7spsGLLztO4S7nbPeBrPifybveA5m43x8DdbgrwbvcAsOjnkJKL7vrImOfiuqf2J5ij9W+G3zSKg2sQiQYPgqcFdNOSOX6QMCXZHreqHXTc8xyZDpE1Pp/cJ0LRHZ7MyXxCn3gQqOECB/bLAsJ+WQie0NWssjDgK0sLdD3NB9bTIpKui2r/k9zQvWkyUIfFMB3SCkyS62Jw/tSxpDbR4SUEcl1qObnKuJc6Tq6TYcWWG9a4SyHXZb7myyPJdZmGXJcbIFdE11LkugxY9MtJyUV3fWTMKyyfSBf5TQP9q5+LgBoiG+9Ky/Mh62UlYboFxq29eSHqZSlhkkXWzirLyUhquIqg4Uqghqsd+VQC2b/WWN5zZE7WEHrOQyTye4hI1EoL9B5C1tPDJF0fNkDUyG+6PwLTITNskqgfAedPHY/WJjr8KIGoH7OcqGXcjzlO1PfCii2rQOMuhagf9zV/IpKoH9cQ9RMGiBrRtRRRPw4s+idIyUV3fWTMT1o+TT3sNw00UT8M1BDZeJ+yPB+yXp4iTLfAuClEreoQPckia+dpy4laavg0QcOngBo+4whRI/vXs5b3HJmTZwk95zkS+T1HJGqlBXoPIevpeZKuzxsg6klAHV6A6VDgmSTqF8D5U8eLtYkOv0gg6pcsJ2oZ90uOE/UkWLF5hRp3KUT9sq/5K5FE/bKGqF8xQNSIrqWI+mVg0b9CSi666yNjftXyaep5v2mgifp5oIbIxvua5fmQ9fIaYboFxk0halWH6EkWWTuvW07UUsPXCRq+BtTwDUeIGtm/3rS858icvEnoOW+RyO8tIlErLdB7CFlPb5N0fdsAUU8E6vAOTIdUo0T9Djh/6ni3NtHhdwlE/Z7lRC3jfs9xop4IK7Y8Y0T9vq/5B5FE/b6GqD8wQNSIrqWI+n1g0X9ASi666yNj/tDyaeptv2mgifptoIbIxvuR5fmQ9fIRYboFxk0halWH6EkWWTsfW07UUsOPCRp+BNRwrSNEjexfn1jec2ROPiH0nE9J5PcpkaiVFug9hKynz0i6fmaAqJHvmv8cpkOO0fddfg7Onzq+qE10+AsCUX9pOVHLuL90nKgnwIotw9j7Lr/yNf86kqi/0hD11waIGtG1FFF/BSz6r0nJRXd9ZMzfWD5NfeY3DTRRfwbUENl4v7U8H7JeviVMt8C4KUSt6hA9ySJr5zvLiVpq+B1Bw2+BGq5zhKiR/Wu95T1H5mQ9oed8TyK/74lErbRA7yFkPf1A0vUHA0Q9HqjDjzAdwtkmifpHcP7U8VNtosM/EYj6Z8uJWsb9s+NEPR5WbPmZGncpRP2Lr/mGSKL+RUPUGwwQNaJrKaL+BVj0G0jJRXd9ZMwbLZ+mfvCbBpqofwBqiGy8v1qeD1kvvxKmW2DcFKJWdYieZJG185vlRC01/I2g4a9ADTc5QtTI/rXZ8p4jc7KZ0HN+J5Hf70SiVlqg9xCynraQdN1igKjHAXXYCtMhN8skUW8F508d22oTHd5GIOo/LCdqGfcfjhP1OFixpWVp3KUQ9XZf8x2RRL1dQ9Q7DBA1omspot4OLPodpOSiuz4y5p2WT1Nb/KaBJuotQA2RjXeX5fmQ9bKLMN0C46YQtapD9CSLrJ3dlhO11HA3QcNdQA33OELUyP611/KeI3Oyl9Bz9pHIbx+RqJUW6D2ErKc/Sbr+aYCoxyIhKhmlQ7rRb33j/D6QqIslEx2WF0dft3iy3UQt4y6evF9g0HWNEvVY3MdOxr71XcLXvGRyzIH0XCL5n0Qt/yM2USO6liLqEsCiL5nMSS666yNjLpUM3OAx+A0n76KyaaCJ+k/gnRPZeEtbng9ZL6WT8dMtMG4KUas6RE+yyNopQ9YwFN3x114uQ9CwNFDDsmAN1YG+ByD7VznLe47MSTlCzzkGTA5qhjommUfUSgv0HkLWU3mSruWT+UQ9BqhDBZgOaekmiboCOH/qqJhMdLgigagrWU7UMu5KjhP1GBxR52rcpRB1ZV/zKpFEXVlD1FUMEPUYIFFXBhZ9lWROctFdHxlzVcunqfJ+00ATdXmghsjGG2t5PmS9xBKm21gwyaD9U3WInmSRtVPNcqKWGlYjaBgL1DDOEaJG9q/qlvccmZPqhJ5Tg0R+NYhErbRA7yFkPdUk6VrTAFGPBhJ1PG6ezDBJ1PHg/KkjIZnocAKBqGtZTtQy7lqOE/Vo3BeDczTuUog60dc8KZKoEzVEnWSAqEcDiToRWPRJyZzkors+Mubalk9TNf2mgSbqmkANkY032fJ8yHpJJky3wLgpRK3qED3JImunjuVELTWsQ9AwGahhiiNEjexfdS3vOTIndQk951gS+R1LJGqlBXoPIeupHknXegaIehSQqOvDdMgy+utZ9cH5U8dxyUSHjyMQ9fGWE7WM+3jHiXoUjKgzjf161gm+5idGEvUJGqI+0QBRjwIS9QnAoj8xmZNcdNdHxnyS5dNUPb9poIm6HlBDZOM92fJ8yHo5mTDdAuOmELWqQ/Qki6ydUywnaqnhKQQNTwZq2MARokb2r1Mt7zkyJ6cSes5pJPI7jUjUSgv0HkLW0+kkXU83QNQjgUQdcpSoQ+D8qcNLJjrsEYg6bDlRy7jDjhP1SAeJOtXXPC2SqFM1RJ1mgKhHAok6FVj0aY4QNTLmdMunqdP9poEm6tOBGiIbb4bl+ZD1kkGYboFxU4ha1SF6kkXWTqblRC01zCRomAHUMMsRokb2r2zLe47MSTah55xBIr8ziESttEDvIWQ9nUnS9UwDRD0CSNRnwXRIN/qu77PA+VNHw2Siww0JRH225UQt4z7bcaIeASPqHGPv+j7H1/zcSKI+R0PU5xog6hFAoj4HWPTnJnOSi+76yJjPs3yaOtNvGmiiPhOoIbLxnm95PmS9nE+YboFxU4ha1SF6kkXWzgWWE7XU8AKChucDNWzkCFEj+1djy3uOzEljQs+5kER+FxKJWmmB3kPIerqIpOtFBoh6OJCom+CIOt8kUTcB508dTZOJDjclEHUzy4laxt3McaIejiPqVI27FKK+2Ne8eSRRX6wh6uYGiHo4kKgvBhZ982ROctFdHxlzC8unqYv8poEm6ouAGiIbb0vL8yHrpSVhugXGTSFqVYfoSRZZO5dYTtRSw0sIGrYEatjKEaJG9q/WlvccmZPWhJ5zKYn8LiUStdICvYeQ9XQZSdfLDBD1MCBRt4HpEDb6jLoNOH/qaJtMdLgtgagvt5yoZdyXO07Uw2BEnW/sGfUVvuZXRhL1FRqivtIAUQ8DEvUVwKK/MpmTXHTXR8bczvJp6jK/aaCJ+jKghsjG297yfMh6aU+YboFxU4ha1SF6kkXWzlWWE7XU8CqChu2BGl7tCFEj+1cHy3uOzEkHQs+5hkR+1xCJWmmB3kPIerqWpOu1Boh6KJCoO8J0SE01SdQdwflTR04y0eEcAlHnWk7UMu5cx4l6KIyo8/I17lKIOs/XPD+SqPM0RJ1vgKiHAok6D1j0+cmc5KK7PjLmAsunqWv9poEm6muBGiIbb6Hl+ZD1UkiYboFxU4ha1SF6kkXWznWWE7XU8DqChoVADa93hKiR/auT5T1H5qQToefcQCK/G4hErbRA7yFkPd1I0vVGA0Q9BEjUN8F0KDD6jPomcP7U0TmZ6HBnAlHfbDlRy7hvdpyoh8CI2jP2jPoWX/NbI4n6Fg1R32qAqIcAifoWYNHfmsxJLrrrI2PuYvk0daPfNNBEfSNQQ2Tjvc3yfMh6uY0w3QLjphC1qkP0JIusndstJ2qp4e0EDW8DaniHI0SN7F9dLe85MiddCT3nThL53UkkaqUFeg8h6+kukq53GSDqwUCivhumQ5pRor4bnD91dEsmOtyNQNT3WE7UMu57HCfqwTCizjVG1N19zXtEEnV3DVH3MEDUg4FE3R1Y9D2SOclFd31kzD0tn6bu8psGmqjvAmqIbLy9LM+HrJdehOkWGDeFqFUdoidZZO30tpyopYa9CRr2AmrYxxGiRvavvpb3HJmTvoSe049Efv2IRK20QO8hZD31J+na3wBRDwIS9QCYDpnZJol6ADh/6hiYTHR4IIGoB1lO1DLuQY4T9SAYUWdlatylEPVgX/MhkUQ9WEPUQwwQ9SAgUQ8GFv2QZE5y4Z+jAmMeavk01d9vGmii7g/UENl4h1meD1kvwwjTLTBuClGrOkRPssjaGW45UUsNhxM0HAbUcIQjRI3sXyMt7zkyJyMJPWcUifxGEYlaaYHeQ8h6Gk3SdbQBoh4IJOoxuCc0Rol6DDh/6hibTHR4LIGox1lO1DLucY4T9UAYUacZI+rxvuYTIol6vIaoJxgg6oFAoh4PLPoJyZzkors+MuaJlk9To/2mgSbq0UANkY13kuX5kPUyiTDdAuOmELWqQ/Qki6ydey0naqnhvQQNJwE1nOwIUSP71xTLe47MyRRCz5lKIr+pRKJWWqD3ELKeppF0nWaAqAcAiXo67hl1yCRRTwfnTx0zkokOzyAQ9UzLiVrGPdNxoh4AI+rskMZdClHP8jWfHUnUszREPdsAUQ8AEvUsYNHPTuYkF931kTHfZ/k0Nc1vGmiingbUENl477c8H7Je7idMt8C4KUSt6hA9ySJr5wHLiVpq+ABBw/uBGs5xhKiR/Wuu5T1H5mQuoec8SCK/B4lErbRA7yFkPc0j6TrPAFH3BxL1fNw86Zkk6vng/KljQTLR4QUEol5oOVHLuBc6TtT9YUSdUahxl0LUi3zNF0cS9SINUS82QNT9gUS9CFj0i5M5yUV3fWTMSyyfpub5TQNN1POAGiIb71LL8yHrZSlhugXGTSFqVYfoSRZZO8ssJ2qp4TKChkuBGi53hKiR/WuF5T1H5mQFoeesJJHfSiJRKy3QewhZT6tIuq4yQNT9gES9GvedR6O/nrUanD91rEkmOryGQNQPWU7UMu6HHCfqfrg3kxn79ayHfc0fiSTqhzVE/YgBou4HJOqHgUX/SDInueiuj4z5UcunqVV+00AT9SqghsjG+5jl+ZD18hhhugXGTSFqVYfoSRZZO49bTtRSw8cJGj4G1PAJR4ga2b+etLznyJw8Seg5T5HI7ykiUSst0HsIWU9Pk3R92gBR9wUS9TMwHQqMPqN+Bpw/dTybTHT4WQJRP2c5Ucu4n3OcqPvifj3L2DPq533NX4gk6uc1RP2CAaLuCyTq54FF/0IyJ7noro+M+UXLp6mn/aaBJuqngRoiG+9LludD1stLhOkWGDeFqFUdoidZZO28bDlRSw1fJmj4ElDDVxwhamT/etXyniNz8iqh57xGIr/XiESttEDvIWQ9vU7S9XUDRN0HSNRvwHQoTDdJ1G+A86eON5OJDr9JIOq3LCdqGfdbjhN1HxhRh3I17lKI+m1f83ciifptDVG/Y4Co+wCJ+m1g0b+TzEkuuusjY37X8mnqdb9poIn6daCGyMb7nuX5kPXyHmG6BcZNIWpVh+hJFlk771tO1FLD9wkavgfU8ANHiBrZvz60vOfInHxI6DkfkcjvIyJRKy3QewhZTx+TdP3YAFH3BhL1WpgO2Ua/9b0WnD91fJJMdPgTAlF/ajlRy7g/dZyoe+P+jtrYt74/8zX/PJKoP9MQ9ecGiLo3kKg/Axb958mc5KK7PjLmLyyfpj72mwaaqD8GaohsvF9ang9ZL18Spltg3BSiVnWInmSRtfOV5UQtNfyKoOGXQA2/doSokf3rG8t7jszJN4Se8y2J/L4lErXSAr2HkPX0HUnX7wwQdS8gUa/DPaM2+q7vdeD8qWN9MtHh9QSi/t5yopZxf+84UffCfevb2Lu+f/A1/zGSqH/QEPWPBoi6F5CofwAW/Y/JnOSiuz4y5p8sn6a+85sGmqi/A2qIbLw/W54PWS8/E6ZbYNwUolZ1iJ5kkbXzi+VELTX8haDhz0ANNzhC1Mj+tdHyniNzspHQc34lkd+vRKJWWqD3ELKefiPp+puvq0m67FkbG4s6NiUTHd5EoMvNltOljHszgS51viI2yGbCJgZuPHq+bdUQGffvjgwTvwFj3mL5MCFj/Z0wTGy1fPiWedlK7jnRariNNDhsOwqDQw/S4PBHMtHhPwiDw3bLBwcZ93ZHBgdZyNsJmxi48ej5tlVDZNw7HBkctgFj3mn54CBj3UEYHHZZPjjIvOwi95xoNdxNGhx2G3iG3x34DH8PcA+ZHJb2JHOGpb3JRIf3EoalfZYPSzLufYaGpVB0h7fb9xX96HA3MEfIfP9p+Q1UNro/CTfQmDp216GMWfqIjrtYHc5NT1438isgaE3YOUPs8X2EoQe534tbXvdSQ+kjWsM/gRqWAGuoDvSQiLznlKxj931C5qQkoV+WIvXLUnV4j3uVFug9hKyn0qQ9hNYy6CditlYH+uuRTXCfHHsXA+GyDHj/yKNPINdVav49d8jzyoHzSoHzioHzCoHz8oHzYwLn5QLnZQPnZQLnpQPnpQLnJQPnJQLnxQPnxQLnMYHzP2vsP98XON8bON8TON8dON8VON8ZON8RON8eOP8jcL4tcL41cL4lcP574Hxz4Hx6/P7zaYHzqYHzKYHzyYHzewPnkwLnEwPnEwLn4wPn4wLnYwPnYwLnowPnowLnIwPnIwLnwwPnwwLnQwPnQwLngwPngwLnAwPnAwLn/QPn/QLnfQPnfQLnvQPnvQLnPQPnJ9baf35C4Pz4wPlxgfP6gfN6gfNjA+d1A+cpgfM6gfPkwHntwHlS4DwxcF4rcJ4QOI8PnNcMnNcInFcPnMcFzqsFzmMD51UD51UC55UD55UC5xUD5xUC5+UD58cEzssFzsvU2X/eqvb+89aB80sD55cFztsEztsGzi8PnF8ROL8ycN4ucN4+cH5V4PzqwHmHwPk1gfNrA+cdA+c5gfPcwHle4Dw/cF4QOC8MnF8XOL8+cN4pcH5D4PzGwPlNgfPOgfObA+fDAudDA+dDAueDA+eDAucDA+cDAuf9A+f9Aud9A+d9Aue9A+e9Auc9A+c9AufdA+dTA+dTAueTA+f3Bs4nBc4nBs4nBM7HB87HBc7HBs7HBM5HB85HBc5HBs5HBM6H++djYv4+yoo9UE7YMcLKC6sgrKKwSsIqC6sirKqwWGHVhMUJqy6shrCawuKFJQirJSxRWJKw2sKShdURliKsrrBjhdUTVl/YccKOF3aCsBOFnSTsZGGnCGsg7FRhpwk7XVhImCcsLCxVWJqwdGEZwjKFZQnLFnaGsDOFnSWsobCzhZ0j5xdh5wk7X9gFwhoJayzsQmEXCWsirKmwZsIuFtZcWAthLYVdIqyVsNbCLhV2mbA2wtoKu1zYFcKuFNZOWHthVwm7WlgHYdcIu1ZYR2E5wnKF5QnLF1YgrFDYdcKuF9ZJ2A3CbhR2k7DOwm4WdouwW4V1EXabsNuF3SGsq7A7hd0l7G5h3YTdI6y7sB7CegrrJay3sD7C+grrJ6y/sAHCBgobJGywsCHChgobJmy4sBHCRgobJWy0sDHCxgobJ2y8sAnCJgqbJOzeOjEHHMX8f57r/zMU3eH1KoebP4vHcH29B+hrin+dyULfKcKmCpsmbLqwGcJmCpslbLaw+4TdL+wBYXOEzRX2oLB5wuYLWyBsobBFwhYLWyJsqbBlwpYLWyFspbBVwlYLWyPsIWEP1/lbJKmT4l7pj+ojam2KZm2qZm2aZm26Zm2GZm2mZm2WZm22Zu0+zdr9mrUHNGtzNGtzNWsPatbmadbma9YWaNYWatYWadYWa9aWaNaWataWadaWa9ZWaNZWatZWadZWa9bWaNYe0qw97K8Fj5L+P8/1/xmK7jhgz0bLynJvRHst9SeOU+rg/Eq+hPNZTWQuoolZ5mIqRL+/8zot+muFff286cBc1LE5F2n/89ObEV3MoUDM3sxorhU+QD9vFjAXKXbmIhThpzf7CGPOKPxHzN59R3atLI1+3v3AXNS1LRdZWj+9Bw4/5sx/idmbc7jXyvxX/by5wFwca08uwv/hp/fg4cSc+Z8xe/MO/Vp5B9HPmw/MRT0bcpF5UD+9BYcWc+gQYvYWHsq1Qoekn7cImIv6RzcX6Yfop7f4YDGnHXLM3pL/vFZa4WHo5y0F5uK4o5WLzMPy01v27zFnHWbM3vJ/uVZ24WHr560A5uJ487kIHYGf3kpdzKEjitlb9c9reUeon7camIsTTOYi/4j99NYcGHNqFDF7DwWuFS6MSj/vYWAuTjSUi1B0hwf8fMAD8q0X5LNoc3GSI7kAcpAHnOO9esBcnOxILoDzngecV7zjgbk4xZFcAO9rHrAveycBc9GAlAv0d9WA+9cD1p+H1E/WbythKf71Hvafia3xn5Gt8p+ZrfCfoS3zn6kt8Z+xLfKfuS3wn8HN85/JzfWf0T3gP7O7z3+GN8t/pjfDf8Y3zX/mJ58DTI54xioP9HeNkXPPI3VQeUg1+lJZnN8H/kHao3WIDsuLo6/7GLAYWHE/FtgUoOsafansw7Biyzf2UtnHfc2f8L8Y8L8ntY/7RRhce0Lz9BZ9J0J0LfXE9XFg0T8BTi5jgz+uaRzRxv14Hc4Eg77bPQTM9ZOwmDPSTN7tniTd7Z6qQ3T4KcLd7mnL73Yy7qcdv9s9BCu27DyNu5S73TO+5s9G3u2e0dztnjVwt3sIeLd7Blj0z5KSi+76yJifw3VP7d9TRuvfY37TKA6uQSQaPA+eFtBNS+b4ecKUZHvcqnbQcb/gyHSIrPEXyX0iFN3hyZy8SOgTzwM1fMmB/fISYb+8DJ7Q1azycsBXlhboenoRWE+vkHR9pc4/yQ3dm9YAdXgVpkNagUlyfRWcP3W8Vofo8GsEcn3dcnKVcb/uOLmugRVbbljjLoVc3/A1fzOSXN/QkOubBsgV0bUUub4BLPo3SclFd31kzG9ZPpG+4jcN9Bv8XgFqiGy8b1ueD1kvbxOmW2DclLfBqTpET7LI2nnHcjKSGr5D0PBtoIbvOvKpBLJ/vWd5z5E5eY/Qc94nkd/7RKJWWqD3ELKePiDp+oEBokZ++/5DmA6ZYZNE/SE4f+r4qA7R4Y8IRP2x5UQt4/7YcaJeDSu2rAKNuxSiXutr/kkkUa/VEPUnBoga0bUUUa8FFv0npOSiuz4y5k8tn6Y+8JsGmqg/AGqIbLyfWZ4PWS+fEaZbYNwUolZ1iJ5kkbXzueVELTX8nKDhZ0ANv3CEqJH960vLe47MyZeEnvMVify+IhK10gK9h5D19DVJ168NEPUqoA7fwHQoMPrjVt+A86eOb+sQHf6WQNTfWU7UMu7vHCfqVbBi8wo17lKIep2v+fpIol6nIer1Boga0bUUUa8DFv16UnLRXR8Z8/eWT1Nf+00DTdRfAzVENt4fLM+HrJcfCNMtMG4KUas6RE+yyNr50XKilhr+SNDwB6CGPzlC1Mj+9bPlPUfm5GdCz/mFRH6/EIlaaYHeQ8h62kDSdYMBol4J1GEjTIdUo0S9EZw/dfxah+jwrwSi/s1yopZx/+Y4Ua+EFVueMaLe5Gu+OZKoN2mIerMBokZ0LUXUm4BFv5mUXHTXR8b8u+XT1Aa/aaCJegNQQ2Tj3WJ5PmS9bCFMt8C4KUSt6hA9ySJrZ6vlRC013ErQcAtQw22OEDWyf/1hec+ROfmD0HO2k8hvO5GolRboPYSspx0kXXcYIGrk++93wnTIMfq+y53g/KljVx2iw7sIRL3bcqKWce92nKhXwIotw9j7Lvf4mu+NJOo9GqLea4CoEV1LEfUeYNHvJSUX3fWRMe+zfJra4TcNNFHvAGqIbLx/Wp4PWS9/EqZbYNwUolZ1iJ5koTftFLuJWmoofURr+CdQw2JgDdWBvgcg+1fxFLt7jsyJ9BG9p0sAcx2coUqk8IhaaYHeQ8h6KknStWQKn6iXA3UoBdMhnG2SqHF+H0jUpVOIDpdOwV+3TIrdRC3jLpOyX2DQdY0S9XLY4JefqXGXQtRlU/7+Z7mUmAPpWf6LSKKW/xGbqJcDiVrGEO21VNGXS+EkF931kTEfk4LLa0wMfsPJu6hsGmiiLgnUENl4y1ueD1kv0kf0dAuMm0LUqg7RkyyydiqQNQxFd/y1lysQNCwP1LAiWEN1oO8ByP5VKcXuniNzIn1E7+nKwFwHZ6jKKTyiVlqg9xCynqqQdK2SwifqZUCirgrTITfLJFHj/D6QqGNTiA7HpuCvWy3FbqKWcVdL2S8w6LpGiXoZjKjTsjTuUog6LuXvf1ZPiTmQnuW/iCRq+R+xiXoZkKhlDNFeSxV99RROctFdHxlzjRS7pyl5F5VNA03UVYAaIhtvTcvzIetF+oieboFxU4ha1SF6kkXWTjxZw1B0x197OZ6gYU2ghglgDdWBvgcg+1etFLt7jsyJ9BG9pxOBuQ7OUIkpPKJWWqD3ELKekki6JqXwiXopkKhrw3RIN/qtb5zfBxJ1cgrR4eQU/HXrpNhN1DLuOin7BQZd1yhRL4URda6xb32npPz9z7opMQfSs/wXkUQt/yM2US8FErWMIdprqaKvm8JJLrrrI2M+NsXuaUreRWXTQBP1/2PvPMCkKtK2PYKRrEgQUHqGMAwq9Jk8KjnnnONEchIREBQQRQQVVBRzzjnnnHPOAXN21VXXVXdX/zpyeml669tgP9Vz7t8+1/V+fbaGr7zfUFXPO9Onu4UwhsqNt1XI8+HXi8+oVrdCv5101LE6VCtZZe20dhzDaHLXb2u5tYMYthLGsI04hrFLfQYo96+2kXDvOX5OfEb1ms4W5jpeQ2VH3HXUsVio15Cynto5imu7iPuO+mphR50ji0N+QSo7ah339h11+4hD4PYR/bz7RsLdUft+7xvZFmDRvCntqK/WddRlFlwnHfV+ka2v+0cytu+e/R8kdtT+P3LdUV8t7Kh9H5KdK1b0+0fcJFe96yt97hAJt5ryT1F/01B31O2EMVRuvB1Dng+/XnxGtboV+u2ko47VoVrJKmsn6jiG0eSu39Zy1EEMOwpj6IljGLvUZ4By/8qNhHvP8XPiM6rXdJ4w1/EaKi/irqOOxUK9hpT1lO8orvkR9x31VcKOukAWh7LCVHbUOu7tO+rCiEPgwoh+3qJIuDtq3++iyLYAi+ZNaUd9le5d36UWXCcddXFk62tJJGP77tn/QWJH7f8j1x31VcKO2vch2bliRV8ScZNc9a6v9PmASLjVlH+K+puGuqPOF8ZQufEeGPJ8+PXiM6rVrdBvJx11rA7VSlZZOwc5jmE0ueu3tXyQgxgeKIxhJ3EMY5f6DFDuX50j4d5z/Jz4jOo13UWY63gN1SXirqOOxUK9hpT11NVRXLtG3HfUVwo76m6yOBSn9NuzdNzbd9TdIw6Bu0f08/aIhLuj9v3uEdkWYNG8Ke2or5R11EUp+/asnpGtr70iGdt3z/4PEjtq/x+57qivFHbUvg/JzhUr+l4RN8lV7/pKn3tHdHnNyNAvOP8U9TcNdUfdVRhD5cbbJ+T58OvFZ1SrW6HfTjrqWB2qlayydvo6jmE0ueu3tdzXQQz7CGPYTxzD2KU+A5T7V/9IuPccPyc+o3pNDxDmOl5DDYi466hjsVCvIWU9DXQU14ER9x31FcKOepAsDqntqHXc23fUgyMOgQdH9PMOiYS7o/b9HhLZFmDRvCntqK8AdtRDI1tfh0Uytu+e/R8kdtT+P3LdUV8h7Kh9H5KdK1b0wyKMjlrp8/BIuNWUf4r6m4a6ox4ojKFy4x0R8nz49eIzqtWt0G8nHXWsDtVKVlk7Ix3HMJrc9dtaHukghiOEMRwljmHsUp8Byv1rdCTce46fE59RvabHCHMdr6HGRNx11LFYqNeQsp7GOorr2Ij7jvpyYUc9ThaHgpR+1reOe/uOenzEIfD4iH7eCZFwd9S+3xMi2wIsmjelHfXlui9tT9lnfU+MbH2dFMnYvnv2f5DYUfv/yHVHfbmwo/Z9SHauWNFPirhJrnrXV/o8ORJuNeWfov6moe6oxwpjqNx4p4Q8H369+IxqdSv020lHHatDtZJV1s5UxzGMJnf9tpanOojhFGEMS8UxjF3qM0C5f5VFwr3n+DnxGdVrulyY63gNVR5x11HHYqFeQ8p6qnAU14qI+476MmFHXSmLQ0FFKjtqHff2HXVVxCFwVUQ/77RIuDtq3+9pkW0BFs2b0o76Ml1HnWfBddJRT49sfZ0Rydi+e/Z/kNhR+//IdUd9mbCj9n1Idq5Y0c+IuEmuetdX+jwzEm415Z+i/qah7qgrhDFUbryzQp4Pv158RrW6FfrtpKOO1aFaySprZ7bjGEaTu35by7MdxHCWMIZzxDGMXeozQLl/zY2Ee8/xc+Izqtf0PGGu4zXUvIi7jjoWC/UaUtbTfEdxnR9x31FfKuyoF8jikJvSv1HruLfvqA+OOAQ+OKKfd2Ek3B217/fCyLYAi+ZNaUd9qayjrkjZ36gPiWx9XRTJ2L579n+Q2FH7/8h1R32psKP2fUh2rljRL4q4Sa5611f6fGgk3GrKP0X9TUPdUc8XxlC58S4OeT78evEZ1epW6LeTjjpWh2olq6ydJY5jGE3u+m0tL3EQw8XCGC4VxzB2qc8A5f51WCTce46fE59RvaaXCXMdr6GWRdx11LFYqNeQsp6WO4rr8oj7jvoSYUd9uCwOeXmp7Kh13Nt31EdEHAIfEdHPuyIS7o7a93tFZFuARfOmtKO+RNZRl1dYcJ101CsjW19XRTK27579HyR21P4/ct1RXyLsqH0fkp0rVvSrIm6Sq971lT4fGQm3mvJPUX/TUHfUy4UxVG68q0OeD79efEa1uhX67aSjjtWhWskqa+coxzGMJnf9tpaPchDD1cIYHi2OYexSnwHK/WtNJNx7jp8Tn1G9po8R5jpeQx0TcddRx2KhXkPKelrrKK5rI+476ouFHfWxsjhUpvRv1Dru7TvqdRGHwOsi+nnXR8LdUft+r49sC7Bo3pR21BfLOmovZX+jPi6y9fX4SMb23bP/g8SO2v9Hrjvqi4Udte9DsnPFiv74iJvkqnd9pc8nRMKtpvxT1N801B31WmEMlRvvhpDnw68Xn1GtboV+O+moY3WoVrLK2tnoOIbR5K7f1vJGBzHcIIzhieIYxi71GaDcv06KhHvP8XPiM6rX9MnCXMdrqJMj7jrqWCzUa0hZT5scxXVTxH1HfZGwoz5FFof8lHbUOu7tO+pTIw6BT43o590cCXdH7fu9ObItwKJ5U9pRXyTrqMtS1lGfFtn6enokY/vu2f9BYkft/yPXHfVFwo7a9yHZuWJFf3rETXLVu77S5zMi4VZT/inqbxrqjnqTMIbKjffMkOfDrxefUa1uhX476ahjdahWssraOctxDKPJXb+t5bMcxPBMYQzPFscwdqnPAOX+dU4k3HuOnxOfUb2mzxXmOl5DnRtx11HHYqFeQ8p6Os9RXM+LuO+oLxR21OfL4lBUksqOWse9fUd9QcQh8AUR/bwXRsLdUft+XxjZFmDRvCntqC+UddTFRRZcJx31RZGtrxdHMrbvnv0fJHbU/j9y3VFfKOyofR+Sneuf7/iJuEmu/PeoQp8viYRbTfmnqL9pqDvq84QxVG68l4Y8H369+IxqdSv020lHHatDtZJV1s5ljmMYTe76bS1f5iCGlwpjeLk4hrFLfQYo968rIuHec/yc+IzqNX2lMNfxGurKiLuOOhYL9RpS1tNVjuJ6VcR9R32BsKO+WhaHspR21Dru7TvqayIOga+J6Oe9NhLujtr3+9rItgCL5k1pR32BrKPOT1lHfV1k6+v1kYztu2f/B4kdtf+PXHfUFwg7at+HZOeKFf31ETfJVe/6Sp9viIRbTfmnqL9pqDvqq4QxVG68N4Y8H369+IxqdSv020lHHatDtZJV1s5NjmMYTe76bS3f5CCGNwpjeLM4hrFLfQYo969bIuHec/yc+IzqNX2rMNfxGurWiLuOOhYL9RpS1tNtjuJ6W8R9R32+sKO+XRaHomgqO2od9/Yd9R0Rh8B3RPTz3hkJd0ft+31nZFuARfOmtKM+X9ZRl0QtuE466rsiW1/vjmRs3z37P0jsqP1/5LqjPl/YUfs+JDtXrOjvjrhJrnrXV/p8TyTcaso/Rf1NQ91R3yaMoXLjvTfk+fDrxWdUq1uh30466lgdqpWssnbucxzDaHLXb2v5PgcxvFcYw/vFMYxd6jNAuX89EAn3nuPnxGdUr+kHhbmO11APRtx11LFYqNeQsp4echTXhyLuO+rzhB31w7I4lHip7Kh13Nt31I9EHAI/EtHP+2gk3B217/ejkW0BFs2b0o76PFlHXVhlwXXSUT8W2fr6eCRj++7Z/0FiR+3/I9cd9XnCjtr3Idm5YkX/eMRNctW7vtLnJyLhVlP+KepvGuqO+iFhDJUb75Mhz4dfLz6jWt0K/XbSUcfqUK1klbXzlOMYRpO7flvLTzmI4ZPCGD4tjmHsUp8Byv3rmUi49xw/Jz6jek0/K8x1vIZ6NuKuo47FQr2GlPX0nKO4Phdx31GfK+yon5fFIT+l356l496+o34h4hD4hYh+3hcj4e6ofb9fjGwLsGjelHbU5+o+mSxl3571UmTr68uRjO27Z/8HiR21/49cd9TnCjtq34dk54oV/csRN8lV7/pKn1+JhFtN+aeov2moO+rnhDFUbryvhjwffr34jGp1K/TbSUcdq0O1klXWzmuOYxhN7vptLb/mIIavCmP4ujiGsUt9Bij3rzci4d5z/Jz4jOo1/aYw1/Ea6s2Iu446Fgv1GlLW01uO4vpWxH1HfY6wo35bFofKlP6NWse9fUe9JeIQeEtEP+87kXB31L7f70S2BVg0b0o76nN0356Vsr9RvxvZ+vpeJGP77tn/QWJH7f8j1x31OcKO2vch2bliRf9exE1y1bu+0uf3I+FWU/4p6m8a6o76LWEMlRvvByHPh18vPqNa3Qr9dtJRx+pQrWSVtfOh4xhGk7t+W8sfOojhB8IYfiSOYexSnwHK/evjSLj3HD8nPqN6TX8izHW8hvok4q6jjsVCvYaU9fSpo7h+GnHfUZ8t7Kg/k8WhqiCVHbWOe/uO+vOIQ+DPI/p5v4iEu6P2/f4isi3AonlT2lGfLeuoo2UWXCcd9ZeRra9/imRs3z37P0jsqP1/5LqjPlvYUfs+JDtXrOj/FHGTXPWur/T5q0i41ZR/ivqbhrqj/lQYQ+XG+3XI8+HXi8+oVrdCv5101LE6VCtZZe184ziG0eSu39byNw5i+LUwhn8WxzB2qc8A5f71bSTce46fE59Rvaa/E+Y6XkN9F3HXUcdioV5Dynr63lFcv4+476jPEnbUf5HFoSSl7/rWcW/fUf8QcQj8Q0Q/718j4e6ofb//GtkWYNG8Ke2oz9I9R52yd33/GNn6+lMkY/vu2f9BYkft/yPXHfVZwo7a9yHZuWJF/1PETXLVu77S558j4VZT/inqbxrqjvp7YQyVG+/fQp4Pv158RrW6FfrtpKOO1aFaySpr5++OYxhN7vptLf/dQQz/JozhP8QxjF3qM0C5f/0SCfee4+fEZ1Sv6V+FuY7XUL9G3HXUsVio15CynjIy3cTVn9d1R32msKPeQRaHqpR+1vcO4vz9M1eZDoFrZOrnrZkZ7o7a97tm5rYAi+ZNaUd9pu5d3yn7rO8dg5jvlJmxffe8Y+a/dtT+P3LdUZ8p7Kh3FBb9Tplukqve9ZU+75wZbjWVEWwa6o46QxhD5ca7S8jz4dfLLpl6dSv020lHHatDtZJV1s6ujmMYTe76bS3v6iCGuwhjuJs4hrFLfQYo969aId9z/JzUcrDn1HbU+dXOdNdRx2KhXkPKeqrjKK51grimsrs8o6XWl9hVN9MhcF0H3WW9kHeXvt/1HHSXNlbFAqnnYBELF57zfIc1hkq/60PERB2hzw1CLiZ8X+s7EBO7h1x8+3nZ3fGek2wM93AkHPaoBuFwuiPh0DDTIXBDB8Jhz5ALB9/vPSHCwS/kPR0sYuHCc57vsMZQ6XcjiHDYQ+hz45ALB9/XRg6EQ5OQCwc/L00c7znJxrCpI+HQNNP93/BPE/4Nfy/hGkqlWNor041YapbpELiZA7HUPORiyfe7eYrEUjS5y2sasKr/dNhUmCNlvluE/AD1N7oWDg7QvUN+gPo+7+3A730cHXr+vIlvAVHHxHXOFGu8uQPRo1zvLUNe934MWzqIYQthDCOQRkt55mSG/Jzwc5LpYL/McrRfZmW6+3NvLBbqNaSsp1aO1pA6lq3E2jp2qdf6st10c7WO89krzsvNLcrz/11xRdTLryjPLc7NrSjLj5ZHS8tzK0vyvZKq/Nz8vPKK8jIzZ6lXFa0qLS+pKt46VyobwtaOGsI2mQ6B2zhoCNuGvCH0/W7roCH0i823Ghnuiy1+wUWTvCy4sgUYX8jZcbUmPynbChVC/EmZ/W9Oyv/AXP4fgvPbQsn+HSflfwp6tnABtnOkQPx5V/7OWvBM7Mq9aFW0JDdaGi0qLywqK6nILSsurcqrKsiryPu9cf1Pxa6Ma46juOb8/rj+f1Gv7R3Ftf0fvF73dRTXfYO4xg7OVCg15eEZf9jvF4iK/f0zw8UBl+1ArWWH/Ndav3dxRP8Hv5Nl7BDyX2v5hdnBwa8nOjraFDr+m802mtzl7e8oFlFHsYg6jIW/EbqIxUFDwr2nuFoPnarX7/L/wOes9juL/Y5d6qd4hXXpCXPtKePnC6mdM+y/hcj4H+P5n+opfk4XZ5YqJvGi0sv8N7+FiCZ3eR0cHQLe7/99vfef/js+s+dgU+juaFPY8X/M2f8i3pL1OTcznBuMMhfxdZkbJ05+b37+U8yV+cmL/9tCXp5ZGxVFXlVFVV5BUUlumVeYV1hYlV9VVFicX1FVkF9aUVTp5Zfm5ZZUFkWrvOLKyqKCvPKiwqqSivLCqvhN26vIy8uvKCkr9wpyC0vLosUVeaXRqvyiPNPwV+QVVVTkFRcWlublVRQWVxWXmCbdtP7F0YKiopJoYW5eSa6r/OTFddeqQ+E//TYnfk7KoZBPPBTyHR8K+Q4OhZ4hORT+zyIu+u1DWqqUm05BSA+Fno42nQLBofCffrWpzE9hSA8FV/kp/P/oV65FmVtfi22/co0md/2ff+9Q/q0y2bmEv7518s6oWAzV72h2FcNk5yoJeT78BVPi4GA/wJHIOcDhrz+LHcXiQEexONDxr4JdxKJ3yH8V7Go99An5r4Jd1X5fyK+ChXXpCXPt9U3/Kjjx+u3MUsUkXuwe5LLrL3F0CBzksOv3mQ9ysCkMhPwquEQoBDtlhnODGeioq+yUgl8FK/PTWdj19xV2/a7y09mSn//1PTX/6Ve/yvx0cbR/dhHE4T++K1oYh66O4tAVVg/dHMWhG6weujuKQ/f/4k9FYRZ2FlxZHceLxh5E0djDsWjs4UA0Dk6RaEzyXfHSTa6ncC6laBzsSJT0/C9EY7Lvrlfmp1emTugpRaOr/PQSHI7/4fJuFX6YUG/Z/lns5I3YbYPfuqn/oqSs8T7CxtVFDP0c93Hxm0tHZ68/767B/x6a8a+X6r8Zm08d7zE1ws/YTy0kKUU7NOR/XvF97ufA72Eh+Y3if7i2K8xkfe4v3JiFdeMpc+F4k/znnyn+iJtk/z/qJjkg0+0mGU3u8nyfB7j4s4sjRTMwc9unramZ/y+FHE3u8pQKeVDI68nvqAa5+I0MYB0NduD3EEfraMi/WUfR5C5ne8rIIX/MGhiVove1JN0QCEWiMNfeKEe/oRqa7q6dMw5zLRwVXeYwB4t+LKTLHAZY9MnmYhxkAx4uzIWw/rxx6S4dsdkOV2621FOxT+3wM45IJyrqTQKsqJHpRJlf/gFW1Kh0oqLeQECiRqcTFfUGAxI1Jp0o87cuQKLGphNlpC8gUePSiTKKCpCo8elEmYMakKgJ6USZ/R+QqInpRJltBZCoSelEmWoFJGpyOlEmCIBETUknKupNBSRqajpRUe8qwC9lS9OJinrlgBVVlk5U1KsEJKo8naioNw2QqIp0oqLeDECiKtOJinqzAImqSicq6s0BJGpaOlFRbx4gUdPTiYp6CwCJmpFOVNRbCEjUzHSiot4iQKJmpRMV9RYDEjU7naiotxSQqDnpREW9ZYBEzU0nKuodDkjUvHSiot4KQKLmpxMV9VYBErVAmSj/MzRrZWx7tuw32BoZ1kv2H03Pm543PW963vS86XnT86bnTc+bnjc9b3re9LzpedPzpudNz5ueNz1vet70vKGYt4Z2Xk/4Icee+oNe/SvUH7/kiHEkgHEUgHE0gHEMgHEsgHEcgHE8gHECgHEigHESgHEygHEKgHEqgLEUwFgGYCwHMFYAGCsBjFUAxmkAxukAxhkAxpkAxlkAxtkAxjkAxrkAxnkAxvkAxgUAxs71ws/YBcDYFcDYDcDYHcDYA8DYE8DYC8DYG8DYB8DYF8DYD8DYH8A4AMA4EMA4CMA4GMA4BMA4FMA4DMA4HMA4AsA4EsA4CsA4GsA4BsA4FsA4DsA4HsA4AcA4EcA4CcA4GcA4BcA4FcBYCmAsAzCWAxgrAIyVAMYqAOM0AON0AOMMAONMAOMsAONsAOMcAGPNhuFn3BHAuBOAcWcA4y4Axl0BjLsBGGsBGGsDGOsAGOsCGOsBGOsDGBsAGHcHMO4BYGwIYNwTwNgIwNgYwNgEwNgUwLgXgLEZgLE5gLEFgHFvAOM+AMaWAMYIgDETwJgFYGwFYGwNYGwDYGwLYMwGMLYDMOYAGNsDGPcFMO4HYNwfwNgBwNgRwBgFMHoAxlzC3+JaAv4WB2CsBWCsDWCsA2CsC2CsB2CsD2BsAGDcHcC4B4CxIYBxTwBjIwBjYwBjEwBjUwDjXgDGZgDG5gDGFgDGvQGM+wAYWwIYIwDGTABjFoCxFYCxNYCxDYCxLYAxG8DYDsCYA2BsD2DcF8C4H4BxfwBjBwBjRwBjFMDoARhzAYx5AMZ8AGMBgLEQwFgEYCwGMJYAGA8AMB4IYDwIwNgJwNgZwNgFwNgVwNgNwNgdwNgDwNgTwNgLwNgbwNgHwNgXwNgPwNgfwDgAwDgQwDgIwDgYwDgEwDgUwDgMwDgcwDgCwDgSwDgKwDgawDgGwDgWwDgOwDgewDgBwDgRwDgJwDgZwDgFwDgVwFgKYCwDMJYDGCsAjJUAxioA4zQA43QA4wwA40wA4ywA42wA4xwA41wA4zwA43wA4wIA48EAxoUAxkMAjIsAjIcCGBcDGJcAGJcCGA8DMC4DMC4HMB4OYDwCwLgCwLgSwLgKwHgkgHE1gPEoAOPRAMY1AMZjAIxrAYzHAhjXARjXAxiPAzAeD2A8AcC4AcC4EcB4IoDxJADjyQDGTQDGUwCMpwIYNxOed20cfsZOAMbOAMYuAMauAMZuAMbuAMYeAMaeAMZeAMbeAMY+AMa+AMZ+AMb+AMYBAMaBAMZBAMbBAMYhAMahAMZhAMbhAMYRAMaRAMZRAMbRAMYxAMaxAMZxAMbxAMYJAMaJAMZJAMbJAMYpAMapAMZSAGMZgLEcwFgBYKwEMFYBGKcBGKcDGGcAGGcCGGcBGGcDGOcAGOcCGOcBGOcDGBcAGA8GMC4EMB4CYFwEYDwUwLgYwLgEwLgUwHgYgHEZgHE5gPFwAOMRAMYVAMaVAMZVAMYjAYyrAYxHARiPBjCuATAeA2BcC2A8FsC4DsC4HsB4HIDxeADjCQDGDQDGjQDGEwGMJwEYTwYwbgIwngJgPBXAuBnAeBqA8XQA4xkAxjMBjGcBGM8GMJ4DYDwXwHgegPF8AOMFAMYLAYwXARgvBjBeAmC8FMB4GYDxcgDjFQDGKwGMVwEYrwYwXgNgvBbAeB2A8XoA4w0AxhsBjDcBGG8GMN4CYLwVwHgbgPF2AOMdAMY7AYx3ARjvBjDeA2C8F8B4H4DxfgDjAwDGBwGMDwEYHwYwPgJgfBTA+BiA8XEA4xMAxicBjE8BGJ8GMD4DYHwWwPgcgPF5AOMLAMYXAYwvARhfBjC+AmB8FcD4GoDxdQDjGwDGNwGMbwEY3wYwbgEwvgNgfBfA+B6A8X0A4wcAxg8BjB8BGD8GMH4CYPwUwPgZgPFzAOMXDhjjL8ncuQ7nNleNuNjG5jw4MyNjobFDjC0ydqixxcaWGFtq7DBjy4wtN3a4sSOMrTC20tgqY0caW23sKGNHG1tj7Bhja40da2ydsfXGjjN2vLETjG0wttHYicZOMnaysU3GTjF2qrHNxk4zdrqxM4ydaewsY2cbO8fYucbOM3a+sQuMXWjsImMXG7vE2KXGLjN2ubErjF1p7CpjVxu7xti1xq4zdn3m1hjckBkEpWbw6g9EEpKgLkg/8KrEuuRcCOE8BMK5CMJ5KIRzMYRzCYRzKYTzMAjnMgjncgjn4RDOIyCcKyCcKyGcqyCcR0I4V0M4j4JwHg3hXAPhPAbCuRbCeSyEcx2Ecz2E8zgI5/EQzhMgnBsgnBshnCdCOE+CcJ4M4dwE4TwFwnkqhHMzhPM0COfpEM4zIJxnQjjPgnCeDeE8B8J5LoTzPAjn+RDOCyCcF0I4L4JwXgzhvATCeSmE8zII5+UQzisgnFdCOK+CcF4N4bwGwnkthPM6COf1Qk6frUnAOKbG1veEUu+PrLPtfnXc/VFx90fH3a+Juz8m7n5t3P2xwf2NJuY3GbvZ2C3GbjV2m7Hbjd1hbCfzb2plbH1/7T9zXiPDenUV5S49b3re9LzpedPzpudNz5ueNz1vet70vOl50/Om503Pm543PW963vS86XnT84Zj3hraeb0Bur8DeIMd/O1D/XePEQDGkQDGUQDG0QDGMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqQDGUgBjGYCxHMBYAWCsBDBWARinARinAxhnABhnAhhnARhnAxjnABjnAhjnARjnAxgXABg71ws/YxcAY1cAYzcAY3cAYw8AY08AYy8AY28AYx8AY18AYz8AY38A4wAA40AA4yAA42AA4xAA41AA4zAA43AA4wgA40gA4ygA42gA4xgA41gA4zgA43gA4wQA40QA4yQA42QA4xQA41QAYymAsQzAWA5grAAwVgIYqwCM0wCM0wGMMwCMMwGMswCMswGMcwCMNRuGn3FHAONOAMadAYy7ABh3BTDuBmCsBWCsDWCsA2CsC2CsB2CsD2BsAGDcHcC4B4CxIYBxTwBjIwBjYwBjEwBjUwDjXgDGZgDG5gDGFgDGvQGM+wAYWwIYIwDGTABjFoCxFYCxNYCxDYCxLYAxG8DYDsCYA2BsD2DcF8C4H4BxfwBjBwBjRwBjFMDoARhzCX+Lawn4WxyAsRaAsTaAsQ6AsS6AsR6AsT6AsQGAcXcA4x4AxoYAxj0BjI0AjI0BjE0AjE0BjHsBGJsBGJsDGFsAGPcGMO4DYGwJYIwAGDMBjFkAxlYAxtYAxjYAxrYAxmwAYzsAYw6AsT2AcV8A434Axv0BjB0AjB0BjFEAowdgzAUw5gEY8wGMBQDGQgBjEYCxGMBYAmA8AMB4IIDxIABjJwBjZwBjFwBjVwBjNwBjdwBjDwBjTwBjLwBjbwBjHwBjXwBjPwBjfwDjAADjQADjIADjYADjEADjUADjMADjcADjCADjSADjKADjaADjGADjWADjOADjeADjBADjRADjJADjZADjFADjVABjKYCxDMBYDmCsADBWAhirAIzTAIzTAYwzAIwzAYyzAIyzAYxzAIxzAYzzAIzzAYwLAIwHAxgXAhgPATAuAjAeCmBcDGBcAmBcCmA8DMC4DMC4HMB4OIDxCADjCgDjSgDjKgDjkQDG1QDGowCMRwMY1wAYjwEwrgUwHgtgXAdgXA9gPA7AeDyA8QQA4wYA40YA44kAxpMAjCcDGDcBGE8BMJ4KYNxMeN61cfgZOwEYOwMYuwAYuwIYuwEYuwMYewAYewIYewEYewMY+wAY+wIY+wEY+wMYBwAYBwIYBwEYBwMYhwAYhwIYhwEYhwMYRwAYRwIYRwEYRwMYxwAYxwIYxwEYxwMYJwAYJwIYJwEYJwMYpwAYpwIYSwGMZQDGcgBjBYCxEsBYBWCcBmCcDmCcAWCcCWCcBWCcDWCcA2CcC2CcB2CcD2BcAGA8GMC4EMB4CIBxEYDxUADjYgDjEgDjUgDjYQDGZQDG5QDGwwGMRwAYVwAYVwIYVwEYjwQwrgYwHgVgPBrAuAbAeAyAcS2A8VgA4zoA43oA43EAxuMBjCcAGDcAGDcCGE8EMJ4EYDwZwLgJwHgKgPFUAONmAONpAMbTAYxnABjPBDCeBWA8G8B4DoDxXADjeQDG8wGMFwAYLwQwXgRgvBjAeAmA8VIA42UAxssBjFcAGK8EMF4FYLwawHgNgPFaAON1AMbrAYw3ABhvBDDeBGC8GcB4C4DxVgDjbQDG2wGMdwAY7wQw3gVgvBvAeA+A8V4A430AxvsBjA8AGB8EMD4EYHwYwPgIgPFRAONjAMbHAYxPABifBDA+BWB8GsD4DIDxWQDjcwDG5wGMLwAYXwQwvgRgfBnA+AqA8VUA42sAxtcBjG8AGN8EML4FYHwbwLgFwPgOgPFdAON7AMb3AYwfABg/BDB+BGD8GMD4CYDxUwDjZwDGzwGMXzhgjL8kc+c6nDuaH60RF9vYnHdmZmTcZexuY/cYu9fYfcbuN/aAsQeNPWTsYWOPGHvU2GPGHjf2hLEnjT1l7Gljzxh71thzxp439oKxF429ZOxlY68Ye9XYa8ZeN/aGsTeNvWXsbWNbjL1j7F1j7xl739gHxj409pGxj419YuxTY58Z+9zYF8a+NPYnY18Z+9rYN8b+bOxbY98Z+97YX4z9YOyvxn409pOxnzO3xuBvmUFQagavflB2TRi7yzJ2t2XsHsvYvZax+yxj91vGHrCMPWgZe8gy9rBl7BHL2KOWsccsY49bxp6wjD1pGXvKMva0ZewZy9izlrHnLGPPW8ZesIy9aBl7yTL2smXsFcvYq5ax1yxjr1vG3rCMvWkZe8sy9rZlbItl7B3L2LuWsfcsY+9bxj6wjH1oGfvIMvaxZewTy9inlrHPLGOfW8a+sIx9aRn7k2XsK8vY15axbyxjf7aMfWsZ+84y9r1l7C+WsR8sY3+1jP1oGfvJMvazZczfECMZ2181g9euwWtetDA/v7Iot9LL80qjuSVlxQXR/IKywmKv2CsoLqjILc7LqyzOLy4qKSspipZ4+XmVXlVBSV5VcBwNyNTNNThT+Ea3TDdCoYY4fiOEPt8F8Xmk0Oe7IT6PEvp8D8Tn0UKf74X4PEbo830Qn8cKfb4f4vM4oc8PQHweL/T5QYjPE4Q+PwTxeaLQ54chPk8S+vwIxOfJQp8fhfg8RejzYxCfpwp9fhzic6nQ5ycgPpcJfX4S4nO50OenID5XCH1+GuJzpdDnZyA+Vwl9fhbi8zShz89BfJ4u9Pl5iM8zhD6/APF5ptDnFyE+zxL6/BLE59lCn1+G+DxH6PMrEJ/nCn1+FeLzPKHPr0F8ni/0+XWIzwuEPr8B8blzPZ3Pb0J87iL0+S2Iz12FPr8N8bmb0OctEJ+7C31+B+JzD6HP70J87in0+T2Iz72EPr8P8bm30OcPID73Efr8IcTnvkKfP4L43E/o88cQn/sLff4E4vMAoc+fQnweKPT5M4jPg4Q+fw7xebDQ5y8gPg8R+vwlxOehQp//BPF5mNDnryA+Dxf6/DXleQyhz99QnscQ+vxnyvMYQp+/pTyPIfT5O8rzGEKfv6c8jyH0+S+U5zGEPv9AeR5D6PNfKc9jCH3+kfI8htDnnyjPYwh9/lno805mjrpx/sZfOybEIPp7L2/ri2h9/zabbN142noU5tnFh654sZv4fP89c+vrP/zXHTK2PXDv/2BLwtg/LA/h/xELJelNcIibQpHlYuu1XUH/Tp9zA5+9vws/XOEfwjf0uMpFDXEulPH7xTJXWbS8osArK6wo8ipLC4rLy0vyPC+3tLC0sCy3uKqyrMArLig2c5aX5hab/1xuablXGS0trPQPkToZW/eHxGsHcQx+ER5+8by/ZjoE9idXz5uRpSsGV377jBnaea2sis3EZ1Ut2H/GVZijHbK0hR870P15ffdTqQRHCw/4McIDXvmbhnFAJVgjWK81szK2V33+DxKVoP+PIhnpQkn6sXWIEhwnVII1hBtjTd3G6E2GKEFl/HbMYirBHcUHYuzaKcshsD+5et6dQ64Efb93ztoWYNG8TpRgzYBVrQSVOdrFkRLcpRqU4HDhAT9CeMAr/4Y8CqgEdw3W626JSnBXixLcLQVKkFAoSX+wDUQJjhIqwV2FG+NuQiU4FaIElfGrBVWCtRwpwdpZDoFrO1CCdUKuBH2/62RtC7BoXidKcLeAVa0ElTmq60gJ1q0GJThYeMAPER7wyncHDwMqwXrBeq2fqATrWZRg/RQoQUKhJP3RdxAlOEyoBOsJN8b6QiVYBlGCyvg1gCrBBo6U4O5ZDoF3d6AE9wi5EvT93iNrW4BF8zpRgvUDVrUSVOaooSMl2LAalGB/4QE/QHjAK5/7HARUgnsG67VRohLc06IEG6VACRIKJekPx4UowUFCJbincGNsJFSCFRAlqIxfY6gSbOxICTbJcgjcxIESbBpyJej73TRrW4BF8zpRgo0CVrUSVOZoL0dKcK9qUIK9hQd8H+EBr/xEn35AJdgsWK/NE5VgM4sSbJ4CJUgolKQ/Ph+iBPsJlWAz4cbYXKgEqyBKUBm/FlAl2MKREtw7yyHw3g6U4D4hV4K+3/tkbQuwaF4nSrB5wKpWgsoctXSkBFtWgxLsLjzgewgPeOVntfYCKsFIsF4zE5VgxKIEM1OgBAmFkvQX7ECUYC+hEowIN8ZMoRKcDlGCyvhlQZVgliMl2CrLIXArB0qwdciVoO9366xtARbN60QJZgasaiWozFEbR0qwTTUowc7CA76L8IBXfgtHN6ASbBus1+xEJdjWogSzU6AECYWS9FfwQZRgN6ESbCvcGLOFSnAmRAkq49cOqgTbOVKCOVkOgXMcKMH2IVeCvt/ts7YFWDSvEyWYHbCqlaAyR/s6UoL7VoMSFH1f5W+zyb4H0tN+v6LwewtTpgT3C9br/olKcD+LEtw/BUqQUChJf0kvRAkuyNQpwf2EG+P+QiU4G6IElfHrAFWCHRwpwY5ZDoE7OlCC0ZArQd/vaNa2AIvmdaIE9w9Y1UpQmSPPkRL0qkEJzhQe8LOEB/xsoRKcA1SCucF6zUtUgrkWJZiXAiVIKJRkF/ZciBKcI1SCucKNMU+oBOdClKAyfvlQJZjvSAkWZDkELnCgBAtDrgR9vwuztgVYNK8TJZgXsKqVoDJHRY6UYFE1KMEq4QE/TXjATxcqwRlAJVgcrNeSRCVYbFGCJSlQgoRCSXZhz4cowRlCJVgs3BhLhEpwPkQJKuN3AFQJHuBICR6Y5RD4QAdK8KCQK0Hf74OytgVYNK8TJVgSsKqVoDJHnRwpwU7VoATLhAd8ufCArxAqwUqgEuwcrNcuiUqws0UJdkmBEiQUSrIL+2CIEqwUKsHOwo2xi1AJHgxRgsr4dYUqwa6OlGC3LIfA3Rwowe4hV4K+392ztgVYNK8TJdglYFUrQWWOejhSgj2qQQlOFh7wU4QH/FShEiwFKsGewXrtlagEe1qUYK8UKEFCoSS7sA+BKMFSoRLsKdwYewmV4CEQJaiMX2+oEuztSAn2yXII3MeBEuwbciXo+903a1uARfM6UYK9Ala1ElTmqJ8jJdivGpTgeOEBP0F4wE8UKsFJQCXYP1ivAxKVYH+LEhyQAiVIKJRkF/ahECU4SagE+ws3xgFCJXgoRAkq4zcQqgQHOlKCg7IcAg9yoAQHh1wJ+n4PztoWYNG8TpTggIBVrQSVORriSAkOqQYlOFp4wI8RHvBjhUpwHFAJDg3W67BEJTjUogSHpUAJEgol2YW9BKIExwmV4FDhxjhMqASXQJSgMn7DoUpwuCMlOCLLIfAIB0pwZMiVoO/3yKxtARbN60QJDgtY1UpQmaNRjpTgqFQqweBQHiE8lEcK1duoTJ2IuROoBEcH63VMohIcbVGCY1wqQVChJLuwDwu7ErQUdLJKcLRwYxwjVIKHQZSgMn5joUpwrCMlOC7LIfA4B0pwfMiVoO/3+KxtARbN60QJjglY1UpQmaMJjpTghEAJ+vdNMrY/5ON/9RP/B8H4t4nFPzzg35fE3efF3e8fd58dd58Zd9887r5R3H39uPvd4u5rxt3/I3Pb/Y1x9zfF3d8cd39L3P2tcfe3xd3fHnd/R3A/0fw3JxmbbGyKsanGSo2VGSvP2qqoawXx/Wetxgor4eoqymd63vS86XnT86bnTc+bnjc9b3re9LzpedPzpudNz5ueNz1vet70vOl50/Om5w3HvOq/tbh414GacQSAcSSAcRSAcTSAcQyAcSyAcRyAcTyAcQKAcSKAcRKAcTKAcQqAcSqAsRTAWAZgLAcwVgAYKwGMVQDGaQDG6QDGGQDGmQDGWQDG2QDGOQDGuQDGeQDG+QDGBQDGzvXCz9gFwNgVwNgNwNgdwNgDwNgTwNgLwNgbwNgHwNgXwNgPwNgfwDgAwDgQwDgIwDgYwDgEwDgUwDgMwDgcwDgCwDgSwDgKwDgawDgGwDgWwDgOwDgewDgBwDgRwDgJwDgZwDgFwDgVwFgKYCwDMJYDGCsAjJUAxioA4zQA43QA4wwA40wA4ywA42wA4xwAY82G4WfcEcC4E4BxZwDjLgDGXQGMuwEYawEYawMY6wAY6wIY6wEY6wMYGwAYdwcw7gFgbAhg3BPA2AjA2BjA2ATA2BTAuBeAsRmAsTmAsQWAcW8A4z4AxpYAxgiAMRPAmAVgbAVgbA1gbANgbAtgzAYwtgMw5gAY2wMY9wUw7gdg3B/A2AHA2BHAGAUwegDGXMLf4loC/hYHYKwFYKwNYKwDYKwLYKwHYKwPYGwAYNwdwLgHgLEhgHFPAGMjAGNjAGMTAGNTAONeAMZmAMbmAMYWAMa9AYz7ABhbAhgjAMZMAGMWgLEVgLE1gLENgLEtgDEbwNgOwJgDYGwPYNwXwLgfgHF/AGMHAGNHAGMUwOgBGHMBjHkAxnwAYwGAsRDAWARgLAYwlgAYDwAwHghgPAjA2AnA2BnA2AXA2BXA2A3A2B3A2APA2BPA2AvA2BvA2AfA2BfA2A/A2B/AOADAOBDAOAjAOBjAOATAOBTAOAzAOBzAOALAOBLAOArAOBrAOAbAOBbAOA7AOB7AOAHAOBHAOAnAOBnAOAXAOBXAWApgLAMwlgMYKwCMlQDGKgDjNADjdADjDADjTADjLADjbADjHADjXADjPADjfADjAgDjwQDGhQDGQwCMiwCMhwIYFwMYlwAYlwIYDwMwLgMwLgcwHg5gPALAuALAuBLAuArAeCSAcTWA8SgA49EAxjUAxmMAjGsBjMcCGNcBGNcDGI8DMB4PYDwBwLgBwLgRwHgigPEkAOPJAMZNAMZTAIynAhg3E553bRx+xk4Axs4Axi4Axq4Axm4Axu4Axh4Axp4Axl4Axt4Axj4Axr4Axn4Axv4AxgEAxoEAxkEAxsEAxiEAxqEAxmEAxuEAxhEAxpEAxlEAxtEAxjEAxrEAxnEAxvEAxgkAxokAxkkAxskAxikAxqkAxlIAYxmAsRzAWAFgrAQwVgEYpwEYpwMYZwAYZwIYZwEYZwMY5wAY5wIY5wEY5wMYFwAYDwYwLgQwHgJgXARgPBTAuBjAuATAuBTAeBiAcRmAcTmA8XAA4xEAxhUAxpUAxlUAxiMBjKsBjEcBGI8GMK4BMB4DYFwLYDwWwLgOwLgewHgcgPF4AOMJAMYNAMaNAMYTAYwnARhPBjBuAjCeAmA8FcC4GcB4GoDxdADjGQDGMwGMZwEYzwYwngNgPBfAeB6A8XwA4wUAxgsBjBcBGC8GMF4CYLwUwHgZgPFyAOMVAMYrAYxXARivBjBeA2C8FsB4HYDxegDjDQDGGwGMNwEYbwYw3gJgvBXAeBuA8XYA4x0AxjsBjHcBGO8GMN4DYLwXwHgfgPF+AOMDAMYHAYwPARgfBjA+AmB8FMD4GIDxcQDjEwDGJwGMTwEYnwYwPgNgfBbA+ByA8XkA4wsAxhcBjC8BGF8GML4CYHwVwPgagPF1AOMbAMY3AYxvARjfBjBuATC+A2B8F8D4HoDxfQDjBwDGDwGMHwEYPwYwfgJg/BTA+BmA8XMA4xcOGOMvydy5DueOFkdrxMU2NmdFVkZGpbEqY9OMTTc2w9hMY7OMzTY2x9hcY/OMzTe2wNjBxhYaO8TYImOHGltsbImxpcYOM7bM2HJjhxs7wtgKYyuNrTJ2pLHVxo4ydrSxNcaOMbbW2LHG1hlbb+w4Y8cbO8HYBmMbjZ1o7CRjJxvbZOwUY6ca22zsNGOnGzvD2JnGzjJ2trFzjJ1r7Dxj5xu7wNiFWVtjcFFWEJSawasflF0TxiotY1WWsWmWsemWsRmWsZmWsVmWsdmWsTmWsbmWsXmWsfmWsQWWsYMtYwstY4dYxhZZxg61jC22jC2xjC21jB1mGVtmGVtuGTvcMnaEZWyFZWylZWyVZexIy9hqy9hRlrGjLWNrLGPHWMbWWsaOtYyts4ytt4wdZxk73jJ2gmVsg2Vso2XsRMvYSZaxky1jmyxjp1jGTrWMbbaMnWYZO90ydoZl7EzL2FmWsbMtY+dYxs61jJ1nGTvfMnaBZexCy5i/IUYytr9qBK9dg9e8aGF+fmVRbqWX55VGc0vKigui+QVlhcVesVdQXFCRW5yXV1mcX1xUUlZSFC3x8vMqvaqCkryq4DiaXE93uPv7tWiuqEufpwh9roT4PFXocxXE51Khz9MgPpcJfZ4O8blc6PMMiM8VQp9nQnyuFPo8C+JzldDn2RCfpwl9ngPxebrQ57kQn2cIfZ4H8Xmm0Of5EJ9nCX1eAPF5ttDngyE+zxH6vBDic82GOp8Pgfi8o9DnRRCfdxL6fCjE552FPi+G+LyL0OclEJ93Ffq8FOLzbkKfD4P4XEvo8zKIz7WFPi+H+FxH6PPhEJ/rCn0+AuJzPaHPKyA+1xf6vBLicwOhz6sgPu8u9PlIiM97CH1eDfG5odDnoyA+7yn0+WiIz42EPq+B+NxY6PMxEJ+bCH1eC/G5qdDnYyE+7yX0eR3E52ZCn9dDfG4u9Pk4iM8thD4fD/F5b6HPJ0B83kfo8waIzy2FPm+E+BwR+nwixOdMoc8nQXzOEvp8MsTnVkKfN0F8bi30+RSIz22EPp8K8bmt0OfNEJ+zhT6fBvG5ndDn0yE+5wh9PgPic3uhz2dCfN5X6PNZEJ/3E/p8NsTn/YU+nwPxuYPQ53MhPncU+nwexOeo0OfzIT57Qp8vgPicK/T5QqHPO5k56sb5G3/tmBCD6O+9vK0vovW9dTZVPD1tPQrz7OKDUrzYTXy+L87a+nqJ/xr/kLz/gy0JY/4/imSkCyXZDWH5EDeFIsvF1mu7gv6dPucGPnsXZ+nid4luE/Rc5aKGOBfK+F1qmassWl5R4JUVVhR5laUFxeXlJXmel1taWFpYlltcVVlW4BUXFJs5y0tzi81/Lre03KuMlhZW+odInYyt+0PitYM4BpcKD7943suyHAL7k6vnvVxYDK78vjxrW4BF81pZFZuJz6pasLF5lTm6Qlz4sQPdnzfTvKZSCe4rPOD3Ex7wyt80dAAqwSuD9XpVohK80qIEr0qBEiQUSrIL+wiIEuwgVIJXCjfGq4RK8AiIElTG72qoErzakRK8Jssh8DUOlOC1IVeCvt/XZm0LsGheJ0rwqoBVrQSVObrOkRK8rhqUYLbwgG8nPOCVf0NuD1SC1wfr9YZEJXi9RQnekAIlSCiUZBf2SogSbC9UgtcLN8YbhEpwJUQJKuN3I1QJ3uhICd6U5RD4JgdK8OaQK0Hf75uztgVYNK8TJXhDwKpWgsoc3eJICd5SDUqwlfCAby084JXvDm4LVIK3Buv1tkQleKtFCd6WAiVIKJRkF/aRECXYVqgEbxVujLcJleCRECWojN/tUCV4uyMleEeWQ+A7HCjBO0OuBH2/78zaFmDRvE6U4G0Bq1oJKnN0lyMleFc1KMGWwgM+Ijzglc99ZgGV4N3Ber0nUQnebVGC96RACRIKJdmFfRRECWYJleDdwo3xHqESPAqiBJXxuxeqBO91pATvy3IIfJ8DJXh/yJWg7/f9WdsCLJrXiRK8J2BVK0Fljh5wpAQfqAYl2Fx4wLcQHvDKT/TZB6gEHwzW60OJSvBBixJ8KAVKkFAoyS7sNRAluI9QCT4o3BgfEirBNRAlqIzfw1Al+LAjJfhIlkPgRxwowUdDrgR9vx/N2hZg0bxOlOBDAataCSpz9JgjJfhYNSjBJsIDvqnwgFd+VmszoBJ8PFivTyQqwcctSvCJFChBQqEku7DXQpRgM6ESfFy4MT4hVIJrIUpQGb8noUrwSUdK8Kksh8BPOVCCT4dcCfp+P521LcCieZ0owScCVrUSVOboGUdK8JlqUIINhQf8nsIDXvktHI2BSvDZYL0+l6gEn7UowedSoAQJhZLswl4HUYKNhUrwWeHG+JxQCa6DKEFl/J6HKsHnHSnBF7IcAr/gQAm+GHIl6Pv9Yta2AIvmdaIEnwtY1UpQmaOXHCnBl6pBCdYXHvANhAe88vsV9wAqwZeD9fpKohJ82aIEX0mBEiQUSrIL+ziIEtxDqARfFm6MrwiV4HEQJaiM36tQJfiqIyX4WpZD4NccKMHXQ64Efb9fz9oWYNG8TpTgKwGrWgkqc/SGIyX4RjUowdrCA76O8ICvK1SC9YBK8M1gvb6VqATftCjBt1KgBAmFkuzCPgGiBOsJleCbwo3xLaESPAGiBJXxexuqBN92pAS3ZDkE3uJACb4TciXo+/1O1rYAi+Z1ogTfCljVSlCZo3cdKcF3q0EJ7iI84HcVHvC7CZVgLaASfC9Yr+8nKsH3LErw/RQoQUKhJLuwN0KUYC2hEnxPuDG+L1SCGyFKUBm/D6BK8ANHSvDDLIfAHzpQgh+FXAn6fn+UtS3AonmdKMH3A1a1ElTm6GNHSvDjalCCNYUH/I7CA34noRLcGagEPwnW66eJSvATixL8NAVKkFAoyS7skyBKcGehEvxEuDF+KlSCJ0GUoDJ+n0GV4GeOlODnWQ6BP3egBL8IuRL0/f4ia1uARfM6UYKfBqxqJajM0ZeOlOCX1aAEZ9bTHfCz6ukO+Nn1dPU/p56bQ0W0nqxK8E/Bev0qUQn+yaIEv0qBEiQUSrILexNECc6pp1OCfxJujF8JleAmiBJUxu9rqBL82pES/CbLIfA3DpTgn0OuBH2//5y1LcCieZ0owa8CVrUSVOboW0dK8NtqUIJVwgN+mvCAny5UgjOASvC7YL1+n6gEv7Mowe9ToAQJhZLswj4VogRnCJXgd8KN8XuhEjwVogSV8fsLVAn+xZES/CHLIfAPDpTgX0OuBH2//5q1LcCieZ0owe8DVrUSVOboR0dK8MdqUIJlwgO+XHjAVwiVYCVQCf4UrNefE5XgTxYl+HMKlCChUJJd2KdBlGClUAn+JNwYfxYqwdMgSlAZv79BleDfHCnBv2c5BP67AyX4j5ArQd/vf2RtC7BoXidK8OeAVa0ElTn6xZES/KUalOBk4QE/RXjATxUqwVKgEvw1tl5bZWyv+n61KEH/H0Uy0oWS7MI+A6IES4VK8Ffl4dVK5+MZECWojN8OrZhKcIdW2gPxn7lq5RDYn1w9b81W4VaCvt81W20LsGheJ0owI2BVK0FljnZs5UYJ+vNmBvdNMrY/5ON/9RP/B8H4t4nFPzwQ/0hp/AeN+PevxN0/F3f/RNz9Q3H398Td3xZ3f0Pc/VVx95fE3U+Mu58Udz857n5K3P3UuPvSuPuyuPvy4H4nE5udje1ibFdjuxmrZay2sTqttirqWkF8/1mrscJKuLqK8pmeNz1vet70vOl50/Om503Pm543PW963vS86XnT86bnTc+bnjc9b3re9LzpecMxr/pvLXdmhp9xBIBxJIBxFIBxNIBxDIBxLIBxHIBxPIBxAoBxIoBxEoBxMoBxCoBxKoCxFMBYBmAsBzBWABgrAYxVAMZpAMbpAMYZAMaZAMZZAMbZAMY5AMa5AMZ5AMb5AMYFAMbO9cLP2AXA2BXA2A3A2B3A2APA2BPA2AvA2BvA2AfA2BfA2A/A2B/AOADAOBDAOAjAOBjAOATAOBTAOAzAOBzAOALAOBLAOArAOBrAOAbAOBbAOA7AOB7AOAHAOBHAOAnAOBnAOAXAOBXAWApgLAMwlgMYKwCMlQDGKgDjNADjdADjDADjTADjLADjbADjHABjzYbhZ9wRwLgTgHFnAOMuAMZdAYy7ARhrARhrAxjrABjrAhjrARjrAxgbABh3BzDuAWBsCGDcE8DYCMDYGMDYBMDYFMC4F4CxGYCxOYCxBYBxbwDjPgDGlgDGCIAxE8CYBWBsBWBsDWBsA2BsC2DMBjC2AzDmABjbAxj3BTDuB2DcH8DYAcDYEcAYBTB6AMZcwt/iWgL+FgdgrAVgrA1grANgrAtgrAdgrA9gbABg3B3AuAeAsSGAcU8AYyMAY2MAYxMAY1MA414AxmYAxuYAxhYAxr0BjPsAGFsCGCMAxkwAYxaAsRWAsTWAsQ2AsS2AMRvA2A7AmANgbA9g3BfAuB+AcX8AYwcAY0cAYxTA6AEYcwGMeQDGfABjAYCxEMBYBGAsBjCWABgPADAeCGA8CMDYCcDYGcDYBcDYFcDYDcDYHcDYA8DYE8DYC8DYG8DYB8DYF8DYD8DYH8A4AMA4EMA4CMA4GMA4BMA4FMA4DMA4HMA4AsA4EsA4CsA4GsA4BsA4FsA4DsA4HsA4AcA4EcA4CcA4GcA4BcA4FcBYCmAsAzCWAxgrAIyVAMYqAOM0AON0AOMMAONMAOMsAONsAOMcAONcAOM8AON8AOMCAOPBAMaFAMZDAIyLAIyHAhgXAxiXABiXAhgPAzAuAzAuBzAeDmA8AsC4AsC4EsC4CsB4JIBxNYDxKADj0QDGNQDGYwCMawGMxwIY1wEY1wMYjwMwHg9gPAHAuAHAuBHAeCKA8SQA48kAxk0AxlMAjKcCGDcTnndtHH7GTgDGzgDGLgDGrgDGbgDG7gDGHgDGngDGXgDG3gDGPgDGvgDGfgDG/gDGAQDGgQDGQQDGwQDGIQDGoQDGYQDG4QDGEQDGkQDGUQDG0QDGMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqQDGUgBjGYCxHMBYAWCsBDBWARinARinAxhnABhnAhhnARhnAxjnABjnAhjnARjnAxgXABgPBjAuBDAeAmBcBGA8FMC4GMC4BMC4FMB4GIBxGYBxOYDxcADjEQDGFQDGlQDGVQDGIwGMqwGMRwEYjwYwrgEwHgNgXAtgPBbAuA7AuB7AeByA8XgA4wkAxg0Axo0AxhMBjCcBGE8GMG4CMJ4CYDwVwLgZwHgagPF0AOMZAMYzAYxnARjPBjCeA2A8F8B4HoDxfADjBQDGCwGMFwEYLwYwXgJgvBTAeBmA8XIA4xUAxisBjFcBGK8GMF4DYLwWwHgdgPF6AOMNAMYbAYw3ARhvBjDeAmC8FcB4G4DxdgDjHQDGOwGMdwEY7wYw3gNgvBfAeB+A8X4A4wMAxgcBjA8BGB8GMD4CYHwUwPgYgPFxAOMTAMYnAYxPARifBjA+A2B8FsD4HIDxeQDjCwDGFwGMLwEYXwYwvgJgfBXA+BqA8XUA4xsAxjcBjG8BGN8GMG4BML4DYHwXwPgegPF9AOMHAMYPAYwfARg/BjB+AmD8FMD4GYDxcwDjFw4Y4y/J3LkO546WR2vExTY2Z91WGRn1jNU31sDY7sb2MNbQ2J7GGhlrbKyJsabG9jLWzFhzYy2M7W1sH2MtjUWMZRrLMtbKWGtjbYy1NZZtrJ2xHGPtje1rbD9j+xvrYKyjsagxz1iusTxj+cYKjBUaKzJWbKzE2AHGDjR2kLFOxjob62Ksq7Fuxrob62Gsp7Fexnob62Osr7F+xvobG2BsYKutMRjUKghKzeDVD8quCWP1LGP1LWMNLGO7W8b2sIw1tIztaRlrZBlrbBlrYhlrahnbyzLWzDLW3DLWwjK2t2VsH8tYS8tYxDKWaRnLsoy1soy1toy1sYy1tYxlW8baWcZyLGPtLWP7Wsb2s4ztbxnrYBnraBmLWsY8y1iuZSzPMpZvGSuwjBVaxoosY8WWsRLL2AGWsQMtYwdZxjpZxjpbxrpYxrpaxrpZxrpbxnpYxnpaxnpZxnpbxvpYxvpaxvpZxvpbxgZYxgZaxvwNMZKx/RU7PLoGr3nRwvz8yqLcSi/PK43mlpQVF0TzC8oKi71ir6C4oCK3OC+vsji/uKikrKQoWuLl51V6VQUleVXBcbSr7guFPX+/Fs0VdenzbkKf60F8riX0uT7E59pCnxtAfK4j9Hl3iM91hT7vAfG5ntDnhhCf6wt93hPicwOhz40gPu8u9LkxxOc9hD43gfjcUOhzU4jPewp93gvicyOhz80gPjcW+twc4nMToc8tID43Ffq8N8TnvYQ+7wPxuZnQ55YQn5sLfY5AfG4h9DkT4vPeQp+zID7vI/S5FcTnlkKfW0N8jgh9bgPxOVPoc1uIz1lCn7MhPrcS+twO4nNroc85EJ/bCH1uD/G5rdDnfSE+Zwt93g/iczuhz/tDfM4R+twB4nN7oc8dIT7vK/Q5CvF5P6HPHsTn/YU+50J87iD0OQ/ic0ehz/kQn6NCnwsgPntCnwshPucKfS6C+Jwn9LkY4nO+0OcSiM8FQp8PgPhcKPT5QIjPRUKfD4L4XCz0uRPE5xKhz50hPh8g9LkLxOcDhT53hfh8kNDnbhCfOwl97g7xubPQ5x4Qn7sIfe4J8bmr0OdeEJ+7CX3uDfG5u9DnPhCfewh97gvxuafQ534Qn3sJfe4P8bm30OcBEJ/7CH0eKPR5JzNH3Th/468dE2IQ/b2Xt/VFtL5/m022bjxtPQrz7OKDUrzYTXy+B7fa+jrEf41/SN7/wZaEsSGWB+f/iIWS7IZw1hA3hSLLxdZru4L+nT7nBj57g1vp4jdEtwl6rnJRQ5wLZfyGWuYqi5ZXFHhlhRVFXmVpQXF5eUme5+WWFpYWluUWV1WWFXjFBcVmzvLS3GLzn8stLfcqo6WFlf4hUidj6/6QeO0gjsFQ4eEXzzuslUNgf3L1vMOFxeDK7+GttgVYNK+VVbGZ+KyqBRubV5mjEeLCjx3o/ryZ5jWVSrCr8IDvJjzglb9p6AFUgiOD9ToqUQmOtCjBUSlQgoRCSXZhnwNRgj2ESnCkcGMcJVSC50CUoDJ+o6FKcLQjJTimlUPgMQ6U4NiQK0Hf77EQJTgqYFUrQWWOxjlSguOqQQkeJDzgOwkPeOXfkLsAleD4YL1OSFSC4y1KcEIKlCChUJJd2OdBlGAXoRIcL9wYJwiV4HkQJaiM30SoEpzoSAlOauUQeJIDJTg55ErQ93syRAlOCFjVSlCZoymOlOCUalCCxcIDvkR4wCvfHXwgUAlODdZraaISnGpRgqUpUIKEQkl2YV8AUYIHCpXgVOHGWCpUghdAlKAyfmVQJVjmSAmWt3IIXO5ACVaEXAn6fldAlGBpwKpWgsocVTpSgpXVoATzhQd8gfCAVz73WQRUglXBep2WqASrLEpwWgqUIKFQkl3YF0GUYJFQCVYJN8ZpQiV4EUQJKuM3HaoEpztSgjNaOQSe4UAJzgy5EvT9nglRgtMCVrUSVOZoliMlOKsalGBUeMB7wgNe+Yk+eUAlODtYr3MSleBsixKckwIlSCiUZBf2JRAlmCdUgrOFG+McoRK8BKIElfGbC1WCcx0pwXmtHALPc6AE54dcCfp+z4cowTkBq1oJKnO0wJESXFANSnA/4QG/v/CAV35Wa0egEjw4WK8LE5XgwRYluDAFSpBQKMku7MsgSrCjUAkeLNwYFwqV4GUQJaiM3yFQJXiIIyW4qJVD4EUOlOChIVeCvt+HQpTgwoBVrQSVOVrsSAkurgYl2E54wOcID3jlt3DsC1SCS4L1ujRRCS6xKMGlKVCChEJJdmFfAVGC+wqV4BLhxrhUqASvgChBZfwOgyrBwxwpwWWtHAIvc6AEl4dcCfp+L4cowaUBq1oJKnN0uCMleHg1KMHWwgO+jfCAV36/YjZQCR4RrNcViUrwCIsSXJECJUgolGQX9lUQJZgtVIJHCDfGFUIleBVECSrjtxKqBFc6UoKrWjkEXuVACR4ZciXo+30kRAmuCFjVSlCZo9WOlODqalCCEeEBnyk84LOESrAVUAkeFazXoxOV4FEWJXh0CpQgoVCSXdjXQJRgK6ESPEq4MR4tVILXQJSgMn5roEpwjSMleEwrh8DHOFCCa0OuBH2/10KU4NEBq1oJKnN0rCMleGw1KMEWwgN+b+EBv49QCbYEKsF1wXpdn6gE11mU4PoUKEFCoSS7sK+DKMGWQiW4TrgxrhcqwesgSlAZv+OgSvA4R0rw+FYOgY93oARPCLkS9P0+AaIE1wesaiWozNEGR0pwQzUowabCA34v4QHfTKgEmwOV4MZgvZ6YqAQ3WpTgiSlQgoRCSXZh3wBRgs2FSnCjcGM8UagEb4AoQWX8ToIqwZMcKcGTWzkEPtmBEtwUciXo+70JogRPDFjVSlCZo1McKcFTqkEJ7ik84BsJD/jGQiXYBKgETw3W6+ZEJXiqRQluToESJBRKsgv7JogSbCJUgqcKN8bNQiV4E0QJKuN3GlQJnuZICZ7eyiHw6Q6U4BkhV4K+32dAlODmgFWtBJU5OtOREjyzGpRgA+EBv7vwgN9DqAQbApXgWcF6PTtRCZ5lUYJnp0AJEgol2YV9C0QJNhQqwbOEG+PZQiV4C0QJKuN3DlQJnuNICZ7byiHwuQ6U4HkhV4K+3+dBlODZAataCSpzdL4jJXh+NSjBOsIDvq7wgK8nVIL1gUrwgmC9XpioBC+wKMELU6AECYWS7MK+DaIE6wuV4AXCjfFCoRK8DaIElfG7CKoEL3KkBC9u5RD4YgdK8JKQK0Hf70sgSvDCgFWtBJU5utSREry0GpTgrsIDfjfhAV9LqARrA5XgZcF6vTxRCV5mUYKXp0AJEgol2YV9B0QJ1hYqwcuEG+PlQiV4B0QJKuN3BVQJXuFICV7ZyiHwlQ6U4FUhV4K+31dBlODlAataCSpzdLUjJXh1oAT9+yYZ2x/y8b/6if+DYPzbxOIfHoh/pDT+g0b8+xVx90vj7hfG3c+Ju58Wd18adz8h7n5U3P2QuPud4u53jrvfJe5+17j73eLua8Xd1467rxPcX2NerzV2nbHrjd1g7EZjNxm7udVWRV0riO8/a9UmrzPcHDrpedPzpudNz5ueNz1vet70vOl50/Om503Pm543PW963vS86XnT86bnTc+bnrf65lX/reXOzPAzjgAwjgQwjgIwjgYwjgEwjgUwjgMwjgcwTgAwTgQwTgIwTgYwTgEwTgUwlgIYywCM5QDGCgBjJYCxCsA4DcA4HcA4A8A4E8A4C8A4G8A4B8A4F8A4D8A4H8C4AMDYuV74GbsAGLsCGLsBGLsDGHsAGHsCGHsBGHsDGPsAGPsCGPsBGPsDGAcAGAcCGAcBGAcDGIcAGIcCGIcBGIcDGEcAGEcCGEcBGEcDGMcAGMcCGMcBGMcDGCcAGCcCGCcBGCcDGKcAGKcCGEsBjGUAxnIAYwWAsRLAWAVgnAZgnA5gnAFgnAlgnAVgnA1gnANgrNkw/Iw7Ahh3AjDuDGDcBcC4K4BxNwBjLQBjbQBjHQBjXQBjPQBjfQBjAwDj7gDGPQCMDQGMewIYGwEYGwMYmwAYmwIY9wIwNgMwNgcwtgAw7g1g3AfA2BLAGAEwZgIYswCMrQCMrQGMbQCMbQGM2QDGdgDGHABjewDjvgDG/QCM+wMYOwAYOwIYowBGD8CYS/hbXMvwM+4GYKwFYKwNYKwDYKwLYKwHYKwPYGwAYNwdwLgHgLEhgHFPAGMjAGNjAGMTAGNTAONeAMZmAMbmAMYWAMa9AYz7ABhbAhgjAMZMAGMWgLEVgLE1gLENgLEtgDEbwNgOwJgDYGwPYNwXwLgfgHF/AGMHAGNHAGMUwOgBGHMBjHkAxnwAYwGAsRDAWARgLAYwlgAYDwAwHghgPAjA2AnA2BnA2AXA2BXA2A3A2B3A2APA2BPA2AvA2BvA2AfA2BfA2A/A2B/AOADAOBDAOAjAOBjAOATAOBTAOAzAOBzAOALAOBLAOArAOBrAOAbAOBbAOA7AOB7AOAHAOBHAOAnAOBnAOAXAOBXAWApgLAMwlgMYKwCMlQDGKgDjNADjdADjDADjTADjLADjbADjHADjXADjPADjfADjAgDjwQDGhQDGQwCMiwCMhwIYFwMYlwAYlwIYDwMwLgMwLgcwHg5gPALAuALAuBLAuArAeCSAcTWA8SgA49EAxjUAxmMAjGsBjMcCGNcBGNcDGI8DMB4PYDwBwLgBwLgRwHgigPEkAOPJAMZNAMZTAIynAhg3E553bRx+xk4Axs4Axi4Axq4Axm4Axu4Axh4Axp4Axl4Axt4Axj4Axr4Axn4Axv4AxgEAxoEAxkEAxsEAxiEAxqEAxmEAxuEAxhEAxpEAxlEAxtEAxjEAxrEAxnEAxvEAxgkAxokAxkkAxskAxikAxqkAxlIAYxmAsRzAWAFgrAQwVgEYpwEYpwMYZwAYZwIYZwEYZwMY5wAY5wIY5wEY5wMYFwAYDwYwLgQwHgJgXARgPBTAuBjAuATAuBTAeBiAcRmAcTmA8XAA4xEAxhUAxpUAxlUAxiMBjKsBjEcBGI8GMK4BMB4DYFwLYDwWwLgOwLgewHgcgPF4AOMJAMYNAMaNAMYTAYwnARhPBjBuAjCeAmA8FcC4GcB4GoDxdADjGQDGMwGMZwEYzwYwngNgPBfAeB6A8XwA4wUAxgsBjBcBGC8GMF4CYLwUwHgZgPFyAOMVAMYrAYxXARivBjBeA2C8FsB4HYDxegDjDQDGGwGMNwEYbwYw3gJgvBXAeBuA8XYA4x0AxjsBjHcBGO8GMN4DYLwXwHgfgPF+AOMDAMYHAYwPARgfBjA+AmB8FMD4GIDxcQDjEwDGJwGMTwEYnwYwPgNgfBbA+ByA8XkA4wsAxhcBjC8BGF8GML4CYHwVwPgagPF1AOMbAMY3AYxvARjfBjBuATC+A2B8F8D4HoDxfQDjBwDGDwGMHwEYPwYwfgJg/BTA+BmA8XMA4xcOGOMvydy5Duf2otEacbGNzXlLq4yMW43dZux2Y3cYu9PYXcbuNnaPsXuN3WfsfmMPGHvQ2EPGHjb2iLFHjT1m7HFjTxh70thTxp429oyxZ409Z+x5Yy8Ye9HYS8ZeNvaKsVeNvWbsdWNvGHvT2FvG3ja2xdg7xt419p6x9419YOxDYx8Z+9jYJ8Y+NfaZsc+NfWHsS2N/MvaVsa+NfWPsz8a+Nfadse+N/aXV1hj80CoISs3g1Q/Krgljt1rGbrOM3W4Zu8Mydqdl7C7L2N2WsXssY/daxu6zjN1vGXvAMvagZewhy9jDlrFHLGOPWsYes4w9bhl7wjL2pGXsKcvY05axZyxjz1rGnrOMPW8Ze8Ey9qJl7CXL2MuWsVcsY69axl6zjL1uGXvDMvamZewty9jblrEtlrF3LGPvWsbes4y9bxn7wDL2oWXsI8vYx5axTyxjn1rGPrOMfW4Z+8Iy9qVl7E+Wsa8sY19bxr6xjP3ZMvatZew7y9j3lrG/WMb8DTGSsf0VOzy6Bq950cL8/Mqi3EovzyuN5paUFRdE8wvKCou9Yq+guKAitzgvr7I4v7iopKykKFri5edVelUFJXlVwXnUV/eFwp6/X4vmirr0uZ/Q51shPvcX+nwbxOcBQp9vh/g8UOjzHRCfBwl9vhPi82Chz3dBfB4i9PluiM9DhT7fA/F5mNDneyE+Dxf6fB/E5xFCn++H+DxS6PMDEJ9HCX1+EOLzaKHPD0F8HiP0+WGIz2OFPj8C8Xmc0OdHIT6PF/r8GMTnCUKfH4f4PFHo8xMQnycJfX4S4vNkoc9PQXyeIvT5aYjPU4U+PwPxuVTo87MQn8uEPj8H8blc6PPzEJ8rhD6/APG5UujzixCfq4Q+vwTxeZrQ55chPk8X+vwKxOcZQp9fhfg8U+jzaxCfZwl9fh3i82yhz29AfJ4j9PlNiM9zhT6/BfF5ntDntyE+zxf6vAXi8wKhz+9AfD5Y6PO7EJ8XCn1+D+LzIUKf34f4vEjo8wcQnw8V+vwhxOfFQp8/gvi8ROjzxxCflwp9/gTi82FCnz+F+LxM6PNnEJ+XC33+HOLz4UKfv4D4fITQ5y8hPq8Q+vwniM8rhT5/BfF5ldDnryE+Hyn0+RuIz6uFPv8Z4vNRQp+/hfh8tNDn7yA+rxH6/D3E52OEPv9F6PNOZo66cf7GXzsmxCD6ey9v64toff82m2zdeNp6FObZxQeleLGb+Hz/tdXW1x/91/iH5P0fbEkY+9Hy4PwfsVCS3RDuGuKmUGS52HptV9C/0+fcwGfvr6108ftRtwl6rnJRQ5wLZfx+ssxVFi2vKPDKCiuKvMrSguLy8pI8z8stLSwtLMstrqosK/CKC4rNnOWlucXmP5dbWu5VRksLK/1DpE7G1v0h8dpBHIOfhIdfPO/PrRwC+5Or5/2bsBhc+f23VtsCLJrXyqrYTHxW1YKNzavM0d/FhR870P15M81rKpXgSuEBv0p4wCt/07AaqAT/EazXXxKV4D8sSvCXFChBQqEku7DvgSjB1UIl+A/hxviLUAneA1GCyvj9ClWCvzpSghmtHQL7k6vn3aF1uJWg7/cOrbfFVzSvEyX4S8CqVoLKHNVo7UYJ+vOmWgkuFx7whwsPeOXfkFcAlWDNYL3u2Dpje9Xn/yBRCfr/KJKRLpRkF/Z9ECW4QqgEawo3xh11G6N3H0QJKuO3U2umEtxJfCDGrp1bOwTe2YES3CXkStD3exeIEtwxYFUrQWWOdnWkBHetBiW4RHjALxUe8Mp3By8DKsHdgvVaK1EJ7mZRgrVSoAQJhZLswn4AogSXCZXgbsKNsZZQCT4AUYLK+NWGKsHajpRgndYOges4UIJ1Q64Efb/rQpRgrYBVrQSVOarnSAnWqwYleIjwgF8kPOCVz30uBirB+sF6bZCoBOtblGCDFChBQqEku7AfgijBxUIlWF+4MTYQKsGHIEpQGb/doUpwd0dKcI/WDoH3cKAEG4ZcCfp+N4QowQYBq1oJKnO0pyMluGc1KMH5wgN+gfCAV36iz0KgEmwUrNfGiUqwkUUJNk6BEiQUSrIL+xGIElwoVIKNhBtjY6ESfASiBJXxawJVgk0cKcGmrR0CN3WgBPcKuRL0/d4LogQbB6xqJajMUTNHSrBZNSjB2cIDfo7wgFd+Vus8oBJsHqzXFolKsLlFCbZIgRIkFEqyC/sxiBKcJ1SCzYUbYwuhEnwMogSV8dsbqgT3dqQE92ntEHgfB0qwZciVoO93S4gSbBGwqpWgMkcRR0owUg1KcLrwgJ8hPOCV38IxC6gEM4P1mpWoBDMtSjArBUqQUCjJLuwnIEpwllAJZgo3xiyhEnwCogSV8WsFVYKtHCnB1q0dArd2oATbhFwJ+n63gSjBrIBVrQSVOWrrSAm2rQYlWCE84CuFB7zy+xWnAZVgdrBe2yUqwWyLEmyXAiVIKJRkF/ZTECU4TagEs4UbYzuhEnwKogSV8cuBKsEcR0qwfWuHwO0dKMF9Q64Efb/3hSjBdgGrWgkqc7SfIyW4XzUowanCA75UeMCXCZVgOVAJ7h+s1w6JSnB/ixLskAIlSCiUZBf2MxAlWC5UgvsLN8YOQiX4DEQJKuPXEaoEOzpSgtHWDoGjDpSgF3Il6PvtQZRgh4BVrQSVOcp1pARzq0EJThQe8JOEB/xkoRKcAlSCecF6zU9UgnkWJZifAiVIKJRkF/ZzECU4RagE84QbY75QCT4HUYLK+BVAlWCBIyVY2NohcKEDJVgUciXo+10EUYL5AataCSpzVOxICRZXgxIcKzzgxwkP+PFCJTgBqARLgvV6QKISLLEowQNSoAQJhZLswn4BogQnCJVgiXBjPECoBF+AKEFl/A6EKsEDHSnBg1o7BD7IgRLsFHIl6PvdCaIEDwhY1UpQmaPOjpRg52pQgiOFB/wo4QE/WqgExwCVYJdgvXZNVIJdLEqwawqUIKFQkl3YL0GU4BihEuwi3Bi7CpXgSxAlqIxfN6gS7OZICXZv7RC4uwMl2CPkStD3uwdECXYNWNVKUJmjno6UYM9qUIJDhQf8MOEBP1yoBEcAlWCvYL32TlSCvSxKsHcKlCChUJJd2K9AlOAIoRLsJdwYewuV4CsQJaiMXx+oEuzjSAn2be0QuK8DJdgv5ErQ97sfRAn2DljVSlCZo/6OlGD/alCCA4UH/CDhAT9YqASHAJXggGC9DkxUggMsSnBgCpQgoVCSXdivQZTgEKESHCDcGAcKleBrECWojN8gqBIc5EgJDm7tEHiwAyU4JORK0Pd7CEQJDgxY1UpQmaOhjpTg0GpQgn2FB3w/4QHfX6gEBwCV4LBgvQ5PVILDLEpweAqUIKFQkl3Yb0CU4AChEhwm3BiHC5XgGxAlqIzfCKgSHOFICY5s7RB4pAMlOCrkStD3exRECQ4PWNVKUJmj0Y6U4OhACfr3TTK2P+Tjf/UT/wfB+LeJxT88EP9IafwHjfj37eLus+LuW8TdN467bxB3Xyvufse4+19abbv/Me7+mrj7a+Pur4u7vz7u/oa4+xvj7m+Ku785uB9j/vtjjY0zNt7YBGMTjU0yNrn1VkVdK4jvP2vVJq8z3Bw66XnT86bnTc+bnjc9b3re9LzpedPzpudNz5ueNz1vet70vOl50/Om503Pm563+uZV/63lzszwM44AMI4EMI4CMI4GMI4BMI4FMI4DMI4HME4AME4EME4CME4GME4BME4FMJYCGMsAjOUAxgoAYyWAsQrAOA3AOB3AOAPAOBPAOAvAOBvAOAfAOBfAOA/AOB/AuADA2Lle+Bm7ABi7Ahi7ARi7Axh7ABh7Ahh7ARh7Axj7ABj7Ahj7ARj7AxgHABgHAhgHARgHAxiHABiHAhiHARiHAxhHABhHAhhHARhHAxjHABjHAhjHARjHAxgnABgnAhgnARgnAxinABinAhhLAYxlAMZyAGMFgLESwFgFYJwGYJwOYJwBYJwJYJwFYJwNYJwDYKzZMPyMOwIYdwIw7gxg3AXAuCuAcTcAYy0AY20AYx0AY10AYz0AY30AYwMA4+4Axj0AjA0BjHsCGBsBGBsDGJsAGJsCGPcCMDYDMDYHMLYAMO4NYNwHwNgSwBgBMGYCGLMAjK0AjK0BjG0AjG0BjNkAxnYAxhwAY3sA474Axv0AjPsDGDsAGDsCGKMARg/AmEv4W1zL8DPuBmCsBWCsDWCsA2CsC2CsB2CsD2BsAGDcHcC4B4CxIYBxTwBjIwBjYwBjEwBjUwDjXgDGZgDG5gDGFgDGvQGM+wAYWwIYIwDGTABjFoCxFYCxNYCxDYCxLYAxG8DYDsCYA2BsD2DcF8C4H4BxfwBjBwBjRwBjFMDoARhzAYx5AMZ8AGMBgLEQwFgEYCwGMJYAGA8AMB4IYDwIwNgJwNgZwNgFwNgVwNgNwNgdwNgDwNgTwNgLwNgbwNgHwNgXwNgPwNgfwDgAwDgQwDgIwDgYwDgEwDgUwDgMwDgcwDgCwDgSwDgKwDgawDgGwDgWwDgOwDgewDgBwDgRwDgJwDgZwDgFwDgVwFgKYCwDMJYDGCsAjJUAxioA4zQA43QA4wwA40wA4ywA42wA4xwA41wA4zwA43wA4wIA48EAxoUAxkMAjIsAjIcCGBcDGJcAGJcCGA8DMC4DMC4HMB4OYDwCwLgCwLgSwLgKwHgkgHE1gPEoAOPRAMY1AMZjAIxrAYzHAhjXARjXAxiPAzAeD2A8AcC4AcC4EcB4IoDxJADjyQDGTQDGUwCMpwIYNxOed20cfsZOAMbOAMYuAMauAMZuAMbuAMYeAMaeAMZeAMbeAMY+AMa+AMZ+AMb+AMYBAMaBAMZBAMbBAMYhAMahAMZhAMbhAMYRAMaRAMZRAMbRAMYxAMaxAMZxAMbxAMYJAMaJAMZJAMbJAMYpAMapAMZSAGMZgLEcwFgBYKwEMFYBGKcBGKcDGGcAGGcCGGcBGGcDGOcAGOcCGOcBGOcDGBcAGA8GMC4EMB4CYFwEYDwUwLgYwLgEwLgUwHgYgHEZgHE5gPFwAOMRAMYVAMaVAMZVAMYjAYyrAYxHARiPBjCuATAeA2BcC2A8FsC4DsC4HsB4HIDxeADjCQDGDQDGjQDGEwGMJwEYTwYwbgIwngJgPBXAuBnAeBqA8XQA4xkAxjMBjGcBGM8GMJ4DYDwXwHgegPF8AOMFAMYLAYwXARgvBjBeAmC8FMB4GYDxcgDjFQDGKwGMVwEYrwYwXgNgvBbAeB2A8XoA4w0AxhsBjDcBGG8GMN4CYLwVwHgbgPF2AOMdAMY7AYx3ARjvBjDeA2C8F8B4H4DxfgDjAwDGBwGMDwEYHwYwPgJgfBTA+BiA8XEA4xMAxicBjE8BGJ8GMD4DYHwWwPgcgPF5AOMLAMYXAYwvARhfBjC+AmB8FcD4GoDxdQDjGwDGNwGMbwEY3wYwbgEwvgNgfBfA+B6A8X0A4wcAxg8BjB8BGD8GMH4CYPwUwPgZgPFzAOMXDhjjL8ncuQ7n9vKjNeJiG5tzSuuMjKnGSo2VGSs3VmGs0liVsWnGphubYWymsVnGZhubY2yusXnG5htbYOxgYwuNHWJskbFDjS02tsTYUmOHGVtmbLmxw40dYWyFsZXGVhk70thqY0cZO9rYGmPHGFtr7Fhj64ytN3acseONnWBsg7GNxk40dpKxk41tMnaKsVONbTZ2mrHTjZ1h7ExjZxk729g5rbfG4NzWQVBqBq9+UHZNGJtqGSu1jJVZxsotYxWWsUrLWJVlbJplbLplbIZlbKZlbJZlbLZlbI5lbK5lbJ5lbL5lbIFl7GDL2ELL2CGWsUWWsUMtY4stY0ssY0stY4dZxpZZxpZbxg63jB1hGVthGVtpGVtlGTvSMrbaMnaUZexoy9gay9gxlrG1lrFjLWPrLGPrLWPHWcaOt4ydYBnbYBnbaBk70TJ2kmXsZMvYJsvYKZaxUy1jmy1jp1nGTreMnWEZO9MydpZl7GzL2DmWMX9DjGRsf8UOj67Ba160MD+/sii30svzSqO5JWXFBdH8grLCYq/YKyguqMgtzsurLM4vLiopKymKlnj5eZVeVUFJXlVwHq3VfaGw5+/XormiLn0+VujzVIjP64Q+l0J8Xi/0uQzi83FCn8shPh8v9LkC4vMJQp8rIT5vEPpcBfF5o9DnaRCfTxT6PB3i80lCn2dAfD5Z6PNMiM+bhD7Pgvh8itDn2RCfTxX6PAfi82ahz3MhPh+k+4W2Nw/icyehz/MhPncW+rwA4nMXoc8HQ3zuKvR5IcTnbkKfD4H43F3o8yKIzz2EPh8K8bmn0OfFEJ97CX1eAvG5t9DnpRCf+wh9Pgzic1+hz8sgPvcT+rwc4nN/oc+HQ3weIPT5CIjPA4U+r4D4PEjo80qIz4OFPq+C+DxE6POREJ+HCn1eDfF5mNDnoyA+Dxf6fDTE5xFCn9dAfB4p9PkYiM+jhD6vhfg8WujzsRCfxwh9XgfxeazQ5/UQn8cJfT4O4vN4oc/HQ3yeIPT5BIjPE4U+b4D4PEno80aIz5OFPp8I8XmK0OeTID5PFfp8MsTnUqHPmyA+lwl9PgXic7nQ51MhPlcIfd4M8blS6PNpEJ+rhD6fDvF5mtDnMyA+Txf6fCbE5xlCn8+C+DxT6PPZEJ9nCX0+R+jzTmaOunH+xl87JsQg+nsvb+uLaH3/Npts3XjaehTm2cUHpXixm/h8n9d66+v5/mv8Q/L+D7YkjJ1veXD+j1goyW4Ibw1xUyiyXGy9tivo3+lzbuCzd15rXfzO122Cnqtc1BDnQhm/CyxzlUXLKwq8ssKKIq+ytKC4vLwkz/NySwtLC8tyi6sqywq84oJiM2d5aW6x+c/llpZ7ldHSwkr/EKmTsXV/SLx2EMfgAuHhF897YWuHwP7k6nkvEhaDK78var0twKJ5rayKzcRnVS3Y2LzKHF0sLvzYge7Pm2leU6kEK4QHfKXwgFf+pmEaUAleEqzXSxOV4CUWJXhpCpQgoVCSXdhbIEpwmlAJXiLcGC8VKsEtECWojN9lUCV4mSMleHlrh8CXO1CCV4RcCfp+XwFRgpcGrGolqMzRlY6U4JXVoASnCg/4UuEBr/wbcjlQCV4VrNerE5XgVRYleHUKlCChUJJd2O9ClGC5UAleJdwYrxYqwXchSlAZv2ugSvAaR0rw2tYOga91oASvC7kS9P2+DqIErw5Y1UpQmaPrHSnB66tBCU4UHvCThAe88t3BU4BK8IZgvd6YqARvsCjBG1OgBAmFkuzCfh+iBKcIleANwo3xRqESfB+iBJXxuwmqBG9ypARvbu0Q+GYHSvCWkCtB3+9bIErwxoBVrQSVObrVkRK8tRqU4FjhAT9OeMArn/ucAFSCtwXr9fZEJXibRQnengIlSCiUZBf2hxAlOEGoBG8Tboy3C5XghxAlqIzfHVAleIcjJXhna4fAdzpQgneFXAn6ft8FUYK3B6xqJajM0d2OlODd1aAERwoP+FHCA175iT5jgErwnmC93puoBO+xKMF7U6AECYWS7ML+GKIExwiV4D3CjfFeoRL8GKIElfG7D6oE73OkBO9v7RD4fgdK8IGQK0Hf7wcgSvDegFWtBJU5etCREnywGpTgUOEBP0x4wCs/q3UEUAk+FKzXhxOV4EMWJfhwCpQgoVCSXdifQpTgCKESfEi4MT4sVIKfQpSgMn6PQJXgI46U4KOtHQI/6kAJPhZyJej7/RhECT4csKqVoDJHjztSgo9XgxIcKDzgBwkPeOW3cAwBKsEngvX6ZKISfMKiBJ9MgRIkFEqyC/tziBIcIlSCTwg3xieFSvBziBJUxu8pqBJ8ypESfLq1Q+CnHSjBZ0KuBH2/n4EowScDVrUSVOboWUdK8NlqUIJ9hQd8P+EBr/x+xQFAJfhcsF6fT1SCz1mU4PMpUIKEQkl2YX8JUYIDhErwOeHG+LxQCX4JUYLK+L0AVYIvOFKCL7Z2CPyiAyX4UsiVoO/3SxAl+HzAqlaCyhy97EgJvlwNSrCn8IDvJTzgewuVYB+gEnwlWK+vJirBVyxK8NUUKEFCoSS7sL+CKME+QiX4inBjfFWoBL+CKEFl/F6DKsHXHCnB11s7BH7dgRJ8I+RK0Pf7DYgSfDVgVStBZY7edKQE36wGJdhVeMB3Ex7w3YVKsAdQCb4VrNe3E5XgWxYl+HYKlCChUJJd2N9AlGAPoRJ8S7gxvi1Ugt9AlKAyflugSnCLIyX4TmuHwO84UILvhlwJ+n6/C1GCbwesaiWozNF7jpTge9WgBA8SHvCdhAd8Z6ES7AJUgu8H6/WDRCX4vkUJfpACJUgolGQX9rcQJdhFqATfF26MHwiV4LcQJaiM34dQJfihIyX4UWuHwB85UIIfh1wJ+n5/DFGCHwSsaiWozNEnjpTgJ9WgBDe11B3wp7TUHfCnttTV/+aWbg4V0XqyKsFPg/X6WaIS/NSiBD9LgRIkFEqyC/t7iBLc3FKnBD8VboyfCZXg9xAlqIzf51Al+LkjJfhFa4fAXzhQgl+GXAn6fn8JUYKfBaxqJajM0Z8cKcE/VYMS3Cg84E8UHvAnCZXgyUAl+FWwXr9OVIJfWZTg1ylQgoRCSXZh/wBRgicLleBXwo3xa6ES/AGiBJXx+waqBL9xpAT/3Noh8J8dKMFvQ64Efb+/hSjBrwNWtRJU5ug7R0rwu2pQgscJD/jjhQf8CUIluAGoBL8P1utfEpXg9xYl+JcUKEFCoSS7sH+EKMENQiX4vXBj/ItQCf4IUYLK+P0AVYI/OFKCf23tEPivDpTgjyFXgr7fP0KU4F8CVrUSVOboJ0dK8KdqUIJrhQf8scIDfp1QCa4HKsGfg/X6t0Ql+LNFCf4tBUqQUCjJLuyfIUpwvVAJ/izcGP8mVII/Q5SgMn5/hyrBvztSgv9o7RD4Hw6U4C8hV4K+379AlODfAla1ElTm6FdHSvDXQAn6900ytj/k43/1E/8Hwfi3icU/PBD/SGn8B43498/H3T8Zd/9w3P29cfe3x93fGHd/ddz9pXH358fdj4m7Hxt3Py7ufnzc/YS4+4lx95Pi7ifHhE8b87+N1TBW09iOxnYytrOxXdpsVdS1gvj+s1Zt8jrDzaGTnjc9b3re9LzpedPzpudNz5ueNz1vet70vOl50/Om503Pm543PW963vS86Xmrb17131ruzAw/4wgA40gA4ygA42gA4xgA41gA4zgA43gA4wQA40QA4yQA42QA4xQA41QAYymAsQzAWA5grAAwVgIYqwCM0wCM0wGMMwCMMwGMswCMswGMcwCMcwGM8wCM8wGMCwCMneuFn7ELgLErgLEbgLE7gLEHgLEngLEXgLE3gLEPgLEvgLEfgLE/gHEAgHEggHEQgHEwgHEIgHEogHEYgHE4gHEEgHEkgHEUgHE0gHEMgHEsgHEcgHE8gHECgHEigHESgHEygHEKgHEqgLEUwFgGYCwHMFYAGCsBjFUAxmkAxukAxhkAxpkAxlkAxtkAxjkAxpoNw8+4I4BxJwDjzgDGXQCMuwIYdwMw1gIw1gYw1gEw1gUw1gMw1gcwNgAw7g5g3APA2BDAuCeAsRGAsTGAsQmAsSmAcS8AYzMAY3MAYwsA494Axn0AjC0BjBEAYyaAMQvA2ArA2BrA2AbA2BbAmA1gbAdgzAEwtgcw7gtg3A/AuD+AsQOAsSOAMQpg9ACMuYS/xbUMP+NuAMZaAMbaAMY6AMa6AMZ6AMb6AMYGAMbdAYx7ABgbAhj3BDA2AjA2BjA2ATA2BTDuBWBsBmBsDmBsAWDcG8C4D4CxJYAxAmDMBDBmARhbARhbAxjbABjbAhizAYztAIw5AMb2AMZ9AYz7ARj3BzB2ADB2BDBGAYwegDEXwJgHYMwHMBYAGAsBjEUAxmIAYwmA8QAA44EAxoMAjJ0AjJ0BjF0AjF0BjN0AjN0BjD0AjD0BjL0AjL0BjH0AjH0BjP0AjP0BjAMAjAMBjIMAjIMBjEMAjEMBjMMAjMMBjCMAjCMBjKMAjKMBjGMAjGMBjOMAjOMBjBMAjBMBjJMAjJMBjFMAjFMBjKUAxjIAYzmAsQLAWAlgrAIwTgMwTgcwzgAwzgQwzgIwzgYwzgEwzgUwzgMwzgcwLgAwHgxgXAhgPATAuAjAeCiAcTGAcQmAcSmA8TAA4zIA43IA4+EAxiMAjCsAjCsBjKsAjEcCGFcDGI8CMB4NYFwDYDwGwLgWwHgsgHEdgHE9gPE4AOPxAMYTAIwbAIwbAYwnAhhPAjCeDGDcBGA8BcB4KoBxM+F518bhZ+wEYOwMYOwCYOwKYOwGYOwOYOwBYOwJYOwFYOwNYOwDYOwLYOwHYOwPYBwAYBwIYBwEYBwMYBwCYBwKYBwGYBwOYBwBYBwJYBwFYBwNYBwDYBwLYBwHYBwPYJwAYJwIYJwEYJwMYJwCYJwKYCwFMJYBGMsBjBUAxkoAYxWAcRqAcTqAcQaAcSaAcRaAcTaAcQ6AcS6AcR6AcT6AcQGA8WAA40IA4yEAxkUAxkMBjIsBjEsAjEsBjIcBGJcBGJcDGA8HMB4BYFwBYFwJYFwFYDwSwLgawHgUgPFoAOMaAOMxAMa1AMZjAYzrAIzrAYzHARiPBzCeAGDcAGDcCGA8EcB4EoDxZADjJgDjKQDGUwGMmwGMpwEYTwcwngFgPBPAeBaA8WwA4zkAxnMBjOcBGM8HMF4AYLwQwHgRgPFiAOMlAMZLAYyXARgvBzBeAWC8EsB4FYDxagDjNQDGawGM1wEYrwcw3gBgvBHAeBOA8WYA4y0AxlsBjLcBGG8HMN4BYLwTwHgXgPFuAOM9AMZ7AYz3ARjvBzA+AGB8EMD4EIDxYQDjIwDGRwGMjwEYHwcwPgFgfBLA+BSA8WkA4zMAxmcBjM8BGJ8HML4AYHwRwPgSgPFlAOMrAMZXAYyvARhfBzC+AWB8E8D4FoDxbQDjFgDjOwDGdwGM7wEY3wcwfgBg/BDA+BGA8WMA4ycAxk8BjJ8BGD8HMH7hgDH+ksyd63BurzhaIy62sTl3bZORsZuxWsZqG6tjrK6xesbqG2tgbHdjexhraGxPY42MNTbWxFhTY3sZa2asubEWxvY2to+xlsYixjKNZRlrZay1sTbG2hrLNtbOWI6x9sb2Nbafsf2NdTDW0VjUmGcs11iesXxjBcYKjRUZKzZWYuwAYwcaO8hYJ2OdjXUx1tVYN2PdjfUw1tNYL2O9jfVpszUGfdsEQakZvPpB2TVhbDfLWC3LWG3LWB3LWF3LWD3LWH3LWAPL2O6WsT0sYw0tY3taxhpZxhpbxppYxppaxvayjDWzjDW3jLWwjO1tGdvHMtbSMhaxjGVaxrIsY60sY60tY20sY20tY9mWsXaWsRzLWHvL2L6Wsf0sY/tbxjpYxjpaxqKWMc8ylmsZy7OM5VvGCixjhZaxIstYsWWsxDJ2gGXsQMvYQZaxTpaxzpaxLpaxrpaxbpax7paxHpaxnpaxXpax3paxPpYxf0OMZGx/xQ6PrsFrXrQwP7+yKLfSy/NKo7klZcUF0fyCssJir9grKC6oyC3Oy6sszi8uKikrKYqWePl5lV5VQUleVXAeCT/s2PP3a9FcUZc+Cz882dsN4rPww5i9WhCfhR/u7NWG+Cz8sGivDsRn4YdPe3UhPgs/zNqrB/FZ+OHYXn2Iz8IP2/YaQHwWfni3tzvEZ+GHgXt7QHwWfri41xDis/DDyr09IT4LP/zcawTxWfhh6l5jiM/CD2f3mkB8Fn7Yu9cU4rPww+O9vSA+Cz+M3msG8Vn44fZec4jPwg/L91pAfBZ++L63N8Rn4Yf5e/tAfBZ+OYDXEuKz8MsGvAjEZ+GXF3iZEJ+FX4bgZUF8Fn65gtcK4rPwyxq81hCfhV/+4LWB+Cz8MgmvLcRn4ZdTeNkQn4VfduG1g/gs/PIMLwfis/DLOLz2EJ+FX+7h7QvxWfhlId5+EJ+FXz7i7Q/xWfhlJl4HiM/CL0fxOkJ8Fn7ZiheF+Cz88hbPg/gs/DIYLxfis/DLZbw8iM/CL6vx8iE+C7/8xiuA+Cz8Mh2vEOKz8Mt5vCKIz8Iv+/GKIT4LvzzIK4H4LPwyIu8AiM/CLzfyDoT4LPyyJO8giM/CL1/yOkF8Fn6Zk9cZ4rPwy6G8LhCfhV825XWF+Cz88iqvG8Rn4Zdhed0hPgu/XMvrAfFZ+GVdXk+Iz8Iv//J6QXwWfpmY1xvis/DLybw+Qp93MnPUjfM3/toxIQbR33t5W19E6/u32WTrxtPWo4svoYu/kpzbi93E57tfm62v/f3X+Ifk/R9sSRjrb3lw/o9YKMluCH8f4qZQZLnYem1X0L/T59zAZ69fG138+us2Qc9VLmqIc6GM3wDLXGXR8ooCr6ywosirLC0oLi8vyfO83NLC0sKy3OKqyrICr7ig2MxZXppbbP5zuaXlXmW0tLDSP0TqZGzdHxKvHcQxGCA8/OJ5B7ZxCOxPrp53kLAYXPk9qM22AIvmtbIqNhOfVbVgY/MqczRYXPixA92fN9O8plIJXiQ84C8WHvDK3zRcClSCQ4L1OjRRCQ6xKMGhKVCChEJJdmH/AlGClwqV4BDhxjhUqAR/gShBZfyGQZXgMEdKcHgbh8DDHSjBESFXgr7fIyBKcGjAqlaCyhyNdKQER1aDEjxPeMCfLzzglX9DvhCoBEcF63V0ohIcZVGCo1OgBAmFkvTmO5ShBC8UKsFRwo1xtFAJusqFWgkq4zcGqgTHOFKCY9s4BB7rQAmOC7kS9P0eB1GCowNWtRJU5mi8IyU4vhqU4FnCA/5s4QGvfHfwuUAlOCFYrxMTleAEixKcmAIlSCiUZBd2DYgSPFeoBCcIN8aJQiVYA6IElfGbBFWCkxwpwcltHAJPdqAEp4RcCfp+T4EowYkBq1oJKnM01ZESnFoNSvA04QF/uvCAVz73eSZQCZYG67UsUQmWWpRgWQqUIKFQkl3YO0KU4JlCJVgq3BjLhEpwR4gSVMavHKoEyx0pwYo2DoErHCjBypArQd/vSogSLAtY1UpQmaMqR0qwqhqU4CbhAX+K8IBXfqLPZqASnBas1+mJSnCaRQlOT4ESJBRKsgt7Z4gS3CxUgtOEG+N0oRLcGaIElfGbAVWCMxwpwZltHALPdKAEZ4VcCfp+z4IowekBq1oJKnM025ESnF0NSnCj8IA/UXjAKz+r9WSgEpwTrNe5iUpwjkUJzk2BEiQUSrILe1eIEjxZqATnCDfGuUIluCtECSrjNw+qBOc5UoLz2zgEnu9ACS4IuRL0/V4AUYJzA1a1ElTm6GBHSvDgalCCxwkP+OOFB7zyWzg2AJXgwmC9HpKoBBdalOAhKVCChEJJdmHXgijBDUIluFC4MR4iVIK1IEpQGb9FUCW4yJESPLSNQ+BDHSjBxSFXgr7fiyFK8JCAVa0ElTla4kgJLqkGJbhWeMAfKzzgld+vuB6oBJcG6/WwRCW41KIED0uBEiQUSrILuw5ECa4XKsGlwo3xMKESrANRgsr4LYMqwWWOlODyNg6BlztQgoeHXAn6fh8OUYKHBaxqJajM0RGOlOAR1aAEjxIe8EcLD/g1QiV4DFAJrgjW68pEJbjCogRXpkAJEgol2YVdD6IEjxEqwRXCjXGlUAnWgyhBZfxWQZXgKkdK8Mg2DoGPdKAEV4dcCfp+r4YowZUBq1oJKnN0lCMleFQ1KMGVwgN+lfCAP1KoBFcDleDRwXpdk6gEj7YowTUpUIKEQkl2YTeAKMHVQiV4tHBjXCNUgg0gSlAZv2OgSvAYR0pwbRuHwGsdKMFjQ64Efb+PhSjBNQGrWgkqc7TOkRJcVw1KcLnwgD9ceMAfIVSCK4BKcH2wXo9LVILrLUrwuBQoQUKhJLuw94AowRVCJbheuDEeJ1SCe0CUoDJ+x0OV4PGOlOAJbRwCn+BACW4IuRL0/d4AUYLHBaxqJajM0UZHSnBjNSjBJcIDfqnwgD9MqASXAZXgicF6PSlRCZ5oUYInpUAJEgol2YW9J0QJLhMqwROFG+NJQiW4J0QJKuN3MlQJnuxICW5q4xB4kwMleErIlaDv9ykQJXhSwKpWgsocnepICZ5aDUrwEOEBv0h4wB8qVIKLgUpwc7BeT0tUgpstSvC0FChBQqEku7AbQ5TgYqES3CzcGE8TKsHGECWojN/pUCV4uiMleEYbh8BnOFCCZ4ZcCfp+nwlRgqcFrGolqMzRWY6U4FnVoATnCw/4BcID/mChElwIVIJnB+v1nEQleLZFCZ6TAiVIKJRkF3ZTiBJcKFSCZws3xnOESrApRAkq43cuVAme60gJntfGIfB5DpTg+SFXgr7f50OU4DkBq1oJKnN0gSMleEE1KMHZwgN+jvCAnytUgvOASvDCYL1elKgEL7QowYtSoAQJhZLswm4GUYLzhErwQuHGeJFQCTaDKEFl/C6GKsGLHSnBS9o4BL7EgRK8NORK0Pf7UogSvChgVStBZY4uc6QELwuUoH/fJGP7Qz7+Vz/xfxCMf5tY/MMD8Y+Uxn/QiH9/WNz9IXH3c+Pup8fdl8XdT4y7Hx13PzTuvn/cfUbc/Q5x9zXi7mvG3e8Yd79T3P3Ocfe7BPeXm9crjF1p7CpjVxu7xti1xq5rs1VR1wri+89atcnrDDeHTnre9LzpedPzpudNz5ueNz1vet70vOl50/Om503Pm543PW963vS86XnT86bnrb551X9ruTMz/IwjAIwjAYyjAIyjAYxjAIxjAYzjAIzjAYwTAIwTAYyTAIyTAYxTAIxTAYylAMYyAGM5gLECwFgJYKwCME4DME4HMM4AMM4EMM4CMM4GMM4BMM4FMM4DMM4HMC4AMHauF37GLgDGrgDGbgDG7gDGHgDGngDGXgDG3gDGPgDGvgDGfgDG/gDGAQDGgQDGQQDGwQDGIQDGoQDGYQDG4QDGEQDGkQDGUQDG0QDGMQDGsQDGcQDG8QDGCQDGiQDGSQDGyQDGKQDGqQDGUgBjGYCxHMBYAWCsBDBWARinARinAxhnABhnAhhnARhnAxjnABhrNgw/444Axp0AjDsDGHcBMO4KYNwNwFgLwFgbwFgHwFgXwFgPwFgfwNgAwLg7gHEPAGNDAOOeAMZGAMbGAMYmAMamAMa9AIzNAIzNAYwtAIx7Axj3ATC2BDBGAIyZAMYsAGMrAGNrAGMbAGNbAGM2gLEdgDEHwNgewLgvgHE/AOP+AMYOAMaOAMYogNEDMOYS/hbXEvC3OABjLQBjbQBjHQBjXQBjPQBjfQBjAwDj7gDGPQCMDQGMewIYGwEYGwMYmwAYmwIY9wIwNgMwNgcwtgAw7g1g3AfA2BLAGAEwZgIYswCMrQCMrQGMbQCMbQGM2QDGdgDGHABjewDjvgDG/QCM+wMYOwAYOwIYowBGD8CYC2DMAzDmAxgLAIyFAMYiAGMxgLEEwHgAgPFAAONBAMZOAMbOAMYuAMauAMZuAMbuAMYeAMaeAMZeAMbeAMY+AMa+AMZ+AMb+AMYBAMaBAMZBAMbBAMYhAMahAMZhAMbhAMYRAMaRAMZRAMbRAMYxAMaxAMZxAMbxAMYJAMaJAMZJAMbJAMYpAMapAMZSAGMZgLEcwFgBYKwEMFYBGKcBGKcDGGcAGGcCGGcBGGcDGOcAGOcCGOcBGOcDGBcAGA8GMC4EMB4CYFwEYDwUwLgYwLgEwLgUwHgYgHEZgHE5gPFwAOMRAMYVAMaVAMZVAMYjAYyrAYxHARiPBjCuATAeA2BcC2A8FsC4DsC4HsB4HIDxeADjCQDGDQDGjQDGEwGMJwEYTwYwbgIwngJgPBXAuJnwvGvj8DN2AjB2BjB2ATB2BTB2AzB2BzD2ADD2BDD2AjD2BjD2ATD2BTD2AzD2BzAOADAOBDAOAjAOBjAOATAOBTAOAzAOBzCOADCOBDCOAjCOBjCOATCOBTCOAzCOBzBOADBOBDBOAjBOBjBOATBOBTCWAhjLAIzlAMYKAGMlgLEKwDgNwDgdwDgDwDgTwDgLwDgbwDgHwDgXwDgPwDgfwLgAwHgwgHEhgPEQAOMiAOOhAMbFAMYlAMalAMbDAIzLAIzLAYyHAxiPADCuADCuBDCuAjAeCWBcDWA8CsB4NIBxDYDxGADjWgDjsQDGdQDG9QDG4wCMxwMYTwAwbgAwbgQwnghgPAnAeDKAcROA8RQA46kAxs0AxtMAjKcDGM8AMJ4JYDwLwHg2gPEcAOO5AMbzAIznAxgvADBeCGC8CMB4MYDxEgDjpQDGywCMlwMYrwAwXglgvArAeDWA8RoA47UAxusAjNcDGG8AMN4IYLwJwHgzgPEWAOOtAMbbAIy3AxjvADDeCWC8C8B4N4DxHgDjvQDG+wCM9wMYHwAwPghgfAjA+DCA8REA46MAxscAjI8DGJ8AMD4JYHwKwPg0gPEZAOOzAMbnAIzPAxhfADC+CGB8CcD4MoDxFQDjqwDG1wCMrwMY3wAwvglgfAvA+DaAcQuA8R0A47sAxvcAjO8DGD8AMH4IYPwIwPgxgPETAOOnAMbPAIyfAxi/cMAYf0nmznU4t1cerREX29ic17fJyLjB2I3GbjJ2s7FbjN1q7DZjtxu7w9idxu4ydrexe4zda+w+Y/cbe8DYg8YeMvawsUeMPWrsMWOPG3vC2JPGnjL2tLFnjD1r7Dljzxt7wdiLxl4y9rKxV4y9auw1Y68be8PYm8beMva2sS3G3jH2rrH3jL1v7ANjHxr7yNjHxj4x9qmxz4x9buwLY18a+5Oxr4x9beybNltj8Oc2QVBqBq9+UHZNGLvBMnajZewmy9jNlrFbLGO3WsZus4zdbhm7wzJ2p2XsLsvY3Zaxeyxj91rG7rOM3W8Ze8Ay9qBl7CHL2MOWsUcsY49axh6zjD1uGXvCMvakZewpy9jTlrFnLGPPWsaes4w9bxl7wTL2omXsJcvYy5axVyxjr1rGXrOMvW4Ze8My9qZl7C3L2NuWsS2WsXcsY+9axt6zjL1vGfvAMvahZewjy9jHlrFPLGOfWsY+s4x9bhn7wjL2pWXsT5axryxjX1vGvrGM+RtiJGP7K3Z4dA1e86KF+fmVRbmVXp5XGs0tKSsuiOYXlBUWe8VeQXFBRW5xXl5lcX5xUUlZSVG0xMvPq/SqCkryqoLzSPhmf8/fr0VzRV36LHx4wLsB4rPwYQTvRojPwocbvJsgPgsflvBuhvgsfPjCuwXis/BhDu9WiM/Ch0O82yA+Cx828W6H+Cx8eMW7A+Kz8GEY706Iz8KHa7y7ID4LH9bx7ob4LHz4x7sH4rPwYSLvXojPwoeTvPsgPgsfdvLuh/gsfHjKewDis/BhLO9BiM/Ch7u8hyA+Cx8W8x6G+Cx8+Mx7BOKz8GE271GIz8KH47zHID4LH7bzHof4LHx4z3sC4rPwYUDvSYjPwocLvacgPgsfVvSehvgsfPjRewbis/BhSu9ZiM/ChzO95yA+Cx/29J6H+Cx8eNR7AeKz8GFU70WIz8KHW72XID4LH5b1Xob4LHz41nsF4rPwYV7vVYjPwoeDvdcgPgsfNvZeh/gsfHjZewPis/BhaO9NiM/Ch6u9tyA+Cx/W9t6G+Cx8+NvbAvFZ+DC59w7EZ+HD6d67EJ+FD7t770F8Fj48770P8Vn4ML73AcRn4cP93ocQn4UfFuB9BPFZ+OED3scQn4UfZuB9AvFZ+OEI3qcQn4UftuB9BvFZ+OEN3ucQn4UfBuF9AfFZ+OES3pcQn4UfVuH9CeKz8MMvvK8gPgs/TMP7GuKz8MM5vG+EPu9k5qgb52/8tWNCDKK/9/K2vojW92+zydaNp63HkH8Iixe7ic/3t222vn7nv8Y/JO//YEvC2HeWB+f/iIWS7IbQYqibQpHlYuu1XUH/Tp9zA5+9b9vo4vedbhP0XOWihjgXyvh9b5mrLFpeUeCVFVYUeZWlBcXl5SV5npdbWlhaWJZbXFVZVuAVFxSbOctLc4vNfy63tNyrjJYWVvqHSJ2MrftD4rWDOAbfCw+/eN6/tHEI7E+unvcHYTG48vuHNtsCLJrXyqrYTHxW1YKNzavM0V/FhR870P15M81rKpXgh8ID/iPhAa/8TcMnQCX4Y7Bef0pUgj9alOBPKVCChEJJdmHvA1GCnwiV4I/CjfEnoRLcB6IElfH7GaoEf3akBP/WxiHw3xwowb+HXAn6fv8dogR/CljVSlCZo384UoL/qAYl+K7wgH9PeMAr/4b8AVAJ/hKs118TleAvFiX4awqUIKFQkl3YEYgS/ECoBH8Rboy/CpVgBKIElfHLaMtUgvHc0SSveN4d2joE9idXz1ujbbiVoO93jbbbAiya14kS9DcTn1WtBJU5qtnWjRL05021EnxLeMC/LTzgle8OfgeoBHcM1utObTO2V33+DxKVoP+PIhnpQkl2YWdBlOA7QiW4o3Bj3Em3MXpZECWojN/OUCW4syMluEtbh8C7OFCCu4ZcCfp+7wpRgjsFrGolqMzRbo6U4G7VoARfEx7wrwsPeOVzn28ClWCtYL3WTlSCtSxKsHYKlCChUJJd2K0hSvBNoRKsJdwYawuVYGuIElTGrw5UCdZxpATrtnUIXNeBEqwXciXo+10PogRrB6xqJajMUX1HSrB+NSjBl4QH/MvCA175iT6vApVgg2C97p6oBBtYlODuKVCChEJJdmG3hSjBV4VKsIFwY9xdqATbQpSgMn57QJXgHo6UYMO2DoEbOlCCe4ZcCfp+7wlRgrsHrGolqMxRI0dKsFE1KMHnhAf888IDXvlZrS8ClWDjYL02SVSCjS1KsEkKlCChUJJd2O0gSvBFoRJsLNwYmwiVYDuIElTGrylUCTZ1pAT3ausQeC8HSrBZyJWg73cziBJsErCqlaAyR80dKcHm1aAEnxIe8E8LD3jlt3A8C1SCLYL1uneiEmxhUYJ7p0AJEgol2YXdHqIEnxUqwRbCjXFvoRJsD1GCyvjtA1WC+zhSgi3bOgRu6UAJRkKuBH2/IxAluHfAqlaCyhxlOlKCmdWgBB8THvCPCw945fcrPglUglnBem2VqASzLEqwVQqUIKFQkl3Y+0GU4JNCJZgl3BhbCZXgfhAlqIxfa6gSbO1ICbZp6xC4jQMl2DbkStD3uy1ECbYKWNVKUJmjbEdKMLsalOBDwgP+YeEB/4hQCT4KVILtgvWak6gE21mUYE4KlCChUJJd2B0gSvBRoRJsJ9wYc4RKsANECSrj1x6qBNs7UoL7tnUIvK8DJbhfyJWg7/d+ECWYE7CqlaAyR/s7UoL7V4MSvE94wN8vPOAfECrBB4FKsEOwXjsmKsEOFiXYMQVKkFAoyS7sKEQJPihUgh2EG2NHoRKMQpSgMn5RqBKMOlKCXluHwJ4DJZgbciXo+50LUYIdA1a1ElTmKM+REsyrBiV4l/CAv1t4wN8jVIL3ApVgfrBeCxKVYL5FCRakQAkSCiXZhZ0LUYL3CpVgvnBjLBAqwVyIElTGrxCqBAsdKcGitg6BixwoweKQK0Hf72KIEiwIWNVKUJmjEkdKsKQalOBtwgP+duEBf4dQCd4JVIIHBOv1wEQleIBFCR6YAiVIKJRkF3Y+RAneKVSCBwg3xgOFSjAfogSV8TsIqgQPcqQEO7V1CNzJgRLsHHIl6PvdGaIEDwxY1UpQmaMujpRgl2pQgjcJD/ibhQf8LUIleCtQCXYN1mu3RCXY1aIEu6VACRIKJenfyUCU4K1CJdhVuDF2EyrBQogSVMavO1QJdnekBHu0dQjcw4ES7BlyJej73ROiBLsFrGolqMxRL0dKsFc1KMHrhAf89cID/gahErwRqAR7B+u1T6IS7G1Rgn1SoAQJhZLswi6GKMEbhUqwt3Bj7CNUgsUQJaiMX1+oEuzrSAn2a+sQuJ8DJdg/5ErQ97s/RAn2CVjVSlCZowGOlOCAalCCVwkP+KuFB/w1QiV4LVAJDgzW66BEJTjQogQHpUAJEgol2YV9AEQJXitUggOFG+MgoRI8AKIElfEbDFWCgx0pwSFtHQIPcaAEh4ZcCfp+D4UowUEBq1oJKnM0zJESHBYoQf++Scb2h3z8r37i/yAY/zax+IcH4h8pjf+gEf++Vdz93nH3TeLud4+7rx13v1Pc/a9ttt3/FHf/Xdz95XH3V8TdXxl3f1Xc/dVx99fE3V8bd39dcD/csIwwNtLYKGOjjY0xNtbYuLZbFfWuGdtq6bc/rmbYr66SfBb/89BRr+GrHahZNeM1AMZrAYzXARivBzDeAGC8EcB4E4DxZgDjLQDGWwGMtwEYbwcw3gFgvBPAeBeA8W4A4z0AxnsBjPcBGO8HMD4AYHwQwPgQgPFhAOMjAMZHAYyPARgfBzA+AWB8EsD4FIDxaQDjMwDGZwGMzwEYnwcwvgBgfBHA+BKA8WUA4ysAxlcBjK8BGF8HML4BYHwTwPgWgPFtAOMWAOM7AMZ3AYzvARjfBzB+AGD8EMD4EYDxYwDjJwDGTwGMnwEYPwcwfhHup1D+yVkjzv/YnOPbZmRMMDbR2CRjk41NMTbVWKmxMmPlxiqMVRqrMjbN2HRjM4zNNDbL2Gxjc4zNNTbP2HxjC4wdbGyhsUOMLTJ2qLHFxpYYW2rsMGPLjC03drixI4ytMLbS2CpjRxpbbewoY0cbW2PsGGNrjR1rbJ2x9caOM3a8sROMbTC20diJxk4ydrKxTcZOMXaqsc3GTjN2evB+6TMSn8TxA7JrwthEy9gky9hky9gUy9hUy1ipZazMMlZuGauwjFVaxqosY9MsY9MtYzMsYzMtY7MsY7MtY3MsY3MtY/MsY/MtYwssYwdbxhZaxg6xjC2yjB1qGVtsGVtiGVtqGTvMMrbMMrbcMna4ZewIy9gKy9hKy9gqy9iRlrHVlrGjLGNHW8bWWMaOsYyttYwdaxlbZxlbbxk7zjJ2vGXsBMvYBsvYRsvYiZaxkyxjJ1vGNlnGTrGMnWoZ22wZO80ydrplzN/8IhnbXzsEr12D12hyl+cfMrG5fu+DGZVV/lXsxXPWSOBM9qEP4RvwvQlt3YgCtc/Kx3EnQnwWPiDgTYL4LHzgwJsM8Vn4AIM3BeKz8oOWpkJ8Fj5g4ZVCfBY+sOGVQXwWPgDilUN8Vn6EbgXEZ+EDKl4lxGfhAy9eFcRn4QM03jSIz8ovR5kO8Vn4gI83A+Kz8IEhbybEZ+EDSN4siM/Kr72cDfFZ+ICUNwfis/CBK28uxGfhA1zePIjPwgfCvPkQn4UPmHkLID4LH1jzDob4LHwAzlsI8Vn4QJ13CMRn4QN63iKIz8IH/rxDIT4LHyD0FkN8Fj6Q6C2B+Cx8wNFbCvFZ+MCkdxjEZ+EDmN4yiM/CBzq95RCfhQ+IeodDfBY+cOodAfFZ+ACrtwLis/CBWG8lxGfhA7beKojPwgd2vSMhPgsfAPZWQ3wWPlDsHQXxWfiAsnc0xGfhA8/eGojPwgeovWMgPgsfyPbWQnwWPuDtHQvxWfjAuLcO4rPwAXRvPcRn4QPt3nEQn4UPyHvHQ3wWPnDvnQDxWfgAv7cB4rPwAwG8jRCfhR8w4J0I8Vn4gQXeSRCfhR+A4J0M8Vn4gQreJojPwg9o8E6B+Cz8wAfvVIjPwg+Q8DZDfBZ+IIV3GsRn4QdceKcLffa//Gu3jK3PMvvXDnE+J16a/2b6y7/Czpj+8i8NY/rLvzSM6S//0jCmv/xLw5j+8i8NY/rLvzSM6S//0jCmv/xLw5j+8i8NY/rLvzSM6S//0jCmv/xLw5j+8i8NY/rLvzSM6S//0jCmv/xLw5j+8i8NY/rLvzSM6S//0jCmv/xLw5j+8i8NY/rLvzSM6S//0jCmv/xLw5j+8i8NY/rLvzSM6S//0jCmv/xLw5j+8i8NY/rLvzSMlC//cjZ3bjS6Q1xsY3Oe2TYj4yxjZxs7x9i5xs4zdr6xC4xdaOwiYxcbu8TYpcYuM3a5sSuMXWnsKmNXG7vG2LXGrjN2vbEbjN1o7CZjNxu7xditxm4zdruxO4zdaewuY3cbu8fYvcbuM3a/sQeMPWjsIWMPG3vE2KPGHjP2uLEnjD1p7CljTxt7xtizxp4z9ryxF4y9aOwlYy8be8XYq8ZeM/a6sTfaZmz/JTv+P0784p2XLGMvW8ZesYy9ahl7zTL2umXsjWAs/lIvijPj3uSr/MIfNedZjt6AreY8G8J5DoTzXAjneRDO8yGcF0A4L4RwXgThvBjCeQmE81II52UQzsshnFdAOK+EcF4F4bwawnkNhPNaCOd1EM7rIZw3QDhvhHDeBOG8GcJ5C4TzVgjnbRDO2yGcd0A474Rw3gXhvBvCeQ+E814I530QzvshnA9AOB+EcD4E4XwYwvkIhPNRCOdjEM7HIZxPQDifhHA+BeF8GsL5DITzWQjncxDO5yGcLzji3DFZTm/7//licpzbzfZSsj7Hzfay4H1VsQ91PGhoSHMR3d7rVxQ1E8z2qqb+fpvtNWEuOoU7F9GY16/r1q/3hnAuYS178blI6r2LZi7/A0rrZmz7QFYnuXFc29FkrvDWjIs3W/9zz4rP95ttt76+lfimYP8HWxLG/H8UyUgXSrIbalfChppQ0L/T59zAZ+9NYfzeEi5aV7moIc6FMn5vW+Yqi5ZXFHhlhRVFXmVpQXF5eUme5+WWFpYWluUWV1WWFXjFBcVmzvLS3GLzn8stLfcqo6WFlf4hUidjmxiPv+RP8Qo32HjeLW0dAvuTyx/DFRaDK7/fabstwKJ5rayKzcRnVS3Yf34NlDBH74oLP3ag+/NmmtdUKsEXhQf8S8ID/mXhofJKWzeHimg9WZXge8F6fT9RCb5nUYLvu1SCAeQrQvXxnnAxvh83V25FQWW0pLisOLesNK+oLD+vrKSk1Mxb6HnFVRW50Yr83KoCr7CwvKSypMrLqyorqCwtLCgtKaz47fSsOAiiPpTx+wCqPj5wpD4+bOsQ+EMH6uOjkKsP3++PIOrj/YBVrT6UOfrYkfr4OFAf8Zc6vp8I2Ivj2JsEjJ8EB6B/P6ZGeO/fj+N8K+5+eNz9iLj7kXH3o+LuR8f7G3c/Nu5+XHD/qXn9zNjnxr4w9qWxPxn7ytjXbf9VZarX/9fCeo2Jmm/MnH829q2x7wKFFF/L/s8Tn2X/s2XsW8vYd23/9Zl3tZj6WrgffCOYa+vz81Hvz0Ku7o7EVM2EXCTjs5+LbyXx25rX74RdizJ+rtf4Vw7W+Pdmzr8Y+8HYXy1r/HvL2v2LZewHy9hfU7DGvxKupe+Fa/wvQq6ekDX+g3CN/1W4xnuC1vifHKzxH82cPxn72djfLGv8R8va/cky9rNl7G8pWON/Eq6lH4Vr/CchV2/IGv9ZuMb/JlzjvUFr/EsHa/zvZs5/GPvF2K+WNf53y9r9h2XsF8vYrylY418K19LfhWv8H0KuvpA1/otwjf8qXON9QWv8CwdrPCPbcBqrYaxmdsa/rHH/54lrdwfLWA3LWM1s92v8C+XvULN1a3yHbB1Xf8gar5GtW+M1s3U10h+0xj93sMZ3NLHcydjOxnaxrPEdLWt3J8vYzpaxXVKwxj8XrvEdhWt8J+EaHwhZ4zsL1/guwjU+ELTGP3Owxnc1sdzNWC1jtS1rfFfL2t3NMlbLMlY7BWv8M+Ea31W4xncTrvHBkDVeS7jGawvX+GDQGv/UwRqvY2JZ11g9Y/Uta7yOZe3WtYzVs4zVT8Ea/1S4xusI13hd4RofClnj9YRrvL5wjQ+FvJGrZ01dzTQQxi9+TfvzRjK2viu1dlwNxV/qfW90DfGbu2pkWC/VfyM9b3re9LzpedPzpudNz5ueNz1vet70vOl50/Om503Pm543PW963vS86XnT84ZjXvXvq+/MDD/jCADjSADjKADjaADjGADjWADjOADjeADjBADjRADjJADjZADjFADjVABjKYCxDMBYDmCsADBWAhirAIzTAIzTAYwzAIwzAYyzAIyzAYxzAIxzAYzzAIzzAYwLAIyd64WfsQuAsSuAsRuAsTuAsQeAsSeAsReAsTeAsQ+AsS+AsR+AsT+AcQCAcSCAcRCAcTCAcQiAcSiAcRiAcTiAcQSAcSSAcRSAcTSAcQyAcSyAcRyAcTyAcQKAcSKAcRKAcTKAcQqAcSqAsRTAWAZgLAcwVgAYKwGMVQDGaQDG6QDGGQDGmQDGWQDG2QDGOQDGmg3Dz7gjgHEnAOPOAMZdAIy7Ahh3AzDWAjDWBjDWATDWBTDWAzDWBzA2ADDuDmDcA8DYEMC4J4CxEYCxMYCxCYCxKYBxLwBjMwBjcwBjCwDj3gDGfQCMLQGMEQBjJoAxC8DYCsDYGsDYBsDYFsCYDWBsB2DMATC2BzDuC2DcD8C4P4CxA4CxI4AxCmD0AIy5hL/FtQT8LQ7AWAvAWBvAWAfAWBfAWA/AWB/A2ADAuDuAcQ8AY0MA454AxkYAxsYAxiYAxqYAxr0AjM0AjM0BjC0AjHsDGPcBMLYEMEYAjJkAxiwAYysAY2sAYxsAY1sAYzaAsR2AMQfA2B7AuC+AcT8A4/4Axg4Axo4AxiiA0QMw5gIY8wCM+QDGAgBjIYCxCMBYDGAsATAeAGA8EMB4EICxE4CxM4CxC4CxK4CxG4CxO4CxB4CxJ4CxF4CxN4CxD4CxL4CxH4CxP4BxAIBxIIBxEIBxMIBxCIBxKIBxGIBxOIBxBIBxJIBxFIBxNIBxDIBxLIBxHIBxPIBxAoBxIoBxEoBxMoBxCoBxKoCxFMBYBmAsBzBWABgrAYxVAMZpAMbpAMYZAMaZAMZZAMbZAMY5AMa5AMZ5AMb5AMYFAMaDAYwLAYyHABgXARgPBTAuBjAuATAuBTAeBmBcBmBcDmA8HMB4BIBxBYBxJYBxFYDxSADjagDjUQDGowGMawCMxwAY1wIYjwUwrgMwrgcwHgdgPB7AeAKAcQOAcSOA8UQA40kAxpMBjJsAjKcAGE8FMG4mPO/aOPyMnQCMnQGMXQCMXQGM3QCM3QGMPQCMPQGMvQCMvQGMfQCMfQGM/QCM/QGMAwCMAwGMgwCMgwGMQwCMQwGMwwCMwwGMIwCMIwGMowCMowGMYwCMYwGM4wCM4wGMEwCMEwGMkwCMkwGMUwCMUwGMpQDGMgBjOYCxAsBYCWCsAjBOAzBOBzDOADDOBDDOAjDOBjDOATDOBTDOAzDOBzAuADAeDGBcCGA8BMC4CMB4KIBxMYBxCYBxKYDxMADjMgDjcgDj4QDGIwCMKwCMKwGMqwCMRwIYVwMYjwIwHg1gXANgPAbAuBbAeCyAcR2AcT2A8TgA4/EAxhMAjBsAjBsBjCcCGE8CMJ4MYNwEYDwFwHgqgHEzgPE0AOPpAMYzAIxnAhjPAjCeDWA8B8B4LoDxPADj+QDGCwCMFwIYLwIwXgxgvATAeCmA8TIA4+UAxisAjFcCGK8CMF4NYLwGwHgtgPE6AOP1AMYbAIw3AhhvAjDeDGC8BcB4K4DxNgDj7QDGOwCMdwIY7wIw3g1gvAfAeC+A8T4A4/0AxgcAjA8CGB8CMD4MYHwEwPgogPExAOPjAMYnAIxPAhifAjA+DWB8BsD4LIDxOQDj8wDGFwCMLwIYXwIwvgxgfAXA+CqA8TUA4+sAxjcAjG8CGN8CML4NYNwCYHwHwPgugPE9AOP7AMYPAIwfAhg/AjB+DGD8BMD4KYDxMwDj5wDGLxwwuuDsWdMBpw9p/M/YMe5/Zxv7JbhvF3c/psa2+7HBfez/b3fz/7SHsYbG9szeOm6bu3/tbXP4/z//zdyNzL9rbKyJsabB3DsZqxMXZJeB9//7ormi8bx7ZTsE9idXz9ssLhB50cL8/Mqi3EovzyuN5paUFRdE8wvKCou9Yq+guKAitzgvr7I4v7iopKykKFri5edVelUFJXlVwWSu/G6WvS3AonmdrupmwuLaKYHRJXe2bq5o3TjO5kH+WgSvewev+wSvLYPXSPCaGbxmBa+tgtfWwWub4LVt8JqdHQSjZvC6d7BQ4sdaWcbaBmOp3HmaO9p52mU7BG7nYOfJCfnO4/ud42DnSWWxtXBUbO2zHQK3d1Bs+4a82Hy/93V0zCWyJuv/3sHCqCGOgXJD2C+buWD3cbRg9892CLy/gwXbIeQL1ve7A/x0aOmo2DpmOwTu6KDYoiEvNt/vKOR0iAQLQ306KDcEL9ttDKPJXb+plf2y9bnJDbnffo17DvzOg6qBTEcbdH62Q+B8Bxt0Qcg3aN/vArgayHJUbIXZDoELHRRbUciLzfe7CKIGWgULQ60GlBtCcchPRf/UznNwKpaE3G+/xosd+H0AVA20drRBH5jtEPhABxv0QSHfoH2/D4KrgTaOiq1TtkPgTg6KrXPIi833uzNEDbQNFoZaDSg3hC4hPxX9U/sAB6di15D77dd4Fwd+dxNvdInvjlkf9y6Y5nHvjmkRd39cwrtjupuf9TDW01iv7G3jsaumOLZ762LgdReuxd7imnQVP+Ffbbwewvj1gcRP+IcIr6cwfn0d7w294/aAPnH3fePue2Vvvzf0M/+7v7EBxgamYG+ICHPTT5ibQZDaFv4O1+svjN9gSPyEv5b0BgjjN8Tx3jAobg8YHHc/JO5+YMLeMNT872HGhhsbkYK9oZUwN0OFuRkJqW3hb3S8YcL4jYLET/hLCm+4MH6jHe8NI+P2gFFx96Pj7kck7A1jzP8ea2ycsfEp2BvaCnMzRpibCY5zMyEuB2Pj7sfF3Y9PyM1E878nGZtsbEr29vPF50TR43dz0ENPFeba5nc0ucvz4zvVgd+ljmvpqrjfHZTG1U923P01Cb87KDM/KzdWYazSss5riGObLYxnmfgvM/G1FH+p66udbq7tHpyoCn6vOy14nR68zgheZwavs4LX2cHrnOB1bvA6L3idH7wuCF4Pzs7Y/oGI6dn/+pDELMvYXMvYguzUP0xRJV6AsWthtkPghQ7+SnFIyP9K4ft9SPa2AIvmTemfxKY5KrZF2Q6BFzkotkNDXmy+34dC/iQ2PVgY6mNZuSEszmYu2BmOFuySbIfASxws2KUhX7C+30vhp8NMR8V2WLZD4MMcFNuykBeb7/cyyOkwK1gY6tNBuSEsz3Ybw2hy129qZbGD5v/wkPvt1/hyB34fAVUDsx1t0CuyHQKvcLBBrwz5Bu37vRKuBuY4KrZV2Q6BVzkotiNDXmy+30dC1MDcYGGo1YByQ1gd8lPRP7WPcHAqHhVyv/0aX+3A76OhamCeow16TbZD4DUONuhjQr5B+34fA1cD8x0V29psh8BrHRTbsSEvNt/vYyFqYEGwMNRqQLkhrAv5qeif2kc7OBXXh9xvv8bXOfD7OMdviIh/mKIq7k0Q07L/74cpjjc/O8HYBmMbs92/8Wm68M0wxwvX4onimnQVP+FfbbwThPE7CRI/4R8ivA3C+J3seG84MW4POCnu/uS4+43Z2+8Nm8z/PsXYqcY2p2BvmCXMzSZhbk6D1Lbwd7jeKcL4nQ6Jn/DXkt6pwvid4XhvOC1uDzg97v6MuPvNCXvDmeZ/n2XsbGPnpGBvmCvMzZnC3JwLqW3hb3S8s4TxOw8SP+EvKbyzhfE73/HecG7cHnBe3P35cffnJOwNF5j/faGxi4xdnIK9YYEwNxcIc3OJ49xcEpeDC+PuL4q7vzghN5ea/32ZscuNXZHt7mEKv8c/zkEPfaUw1za/o8ldnh/fKx34fZXjWop/mOKquPo5OPv/fpjiavOza4xda+y6bPcPU7QTxvNqx/H8vz7MYu9/E8/rzc9uMHajsZuyt33tS/wvtePvb84O/kGNjP/uN/XJBi1Hl8xojTjOW4JfKt+aneBATYcOJDvXLf/9SVH+H+bybhX/nfC/LYhocpd3fbabgrgtKITb/1NBRJO7tnMg2YK4TVgQt0ML4mZHBXFHUAh3ui6Im4UFcYewIO6EFkQjRwVxV1AId7suiEbCgrhLWBB3iwVM7Yytf/HPSIhfXjQ/t7CyML+0sjIvWllSUlzu5ZUXl1dWlleU5pUWFRVHiyrKKksrCnLLynOr8sqqopWllcUFXll+WZEXLfd+SZjPM/4WFJZGC4urCqN50dy83PxoeUlhWX5FaUF+UX5hoZkur6y4yPPKC3K98qL84lwvt9QrKCuP5uVXlhb+os1vNLHgc4tzC8qLSsrLC0sLysvKKiuriioKS4urvLLCUi+3LM/AlOblFefnR0srqyrL8vNKCr384vJik6Gi8mh+yb/4a1JbVeH53pUVRQtzKwrLCvzEV+YVlpVEi/IK8wqiVYVVZaVRLze3uDzfuJwbLSkpiJZUFRRFvUrX/kYrK8q8ytySvPK88soSr6zKOFFpbktLC6IVueUF+V5VaUmFKUDDZdyN5lVWlXnlVaW55WV5eQVFVf/ib16+V1FYVFBVarJbWV6ZZxJuqiOvvDQv38Qhr8wrKSusLCkqzI3mFxaZsXwTvtz88nwT5YrKvALn/uabOOeZZJmlFjVrrqK8OLeyuLSgoLSkILciv6IqN5pbUFhVGTVrraIkv8QMm5yURqNV0dKyKu9f+UqL/cgURiui5v9UFVQUm2WcX1KRX1xllk5+RdSUR7SspLiyosgrKi0pK8jLLa0qzDMroyAvWlTiufB312Au//6WuIbj1rj72+Lub4+7vyPu/s64+7vi7u8O7u8xr/cauy97ax/i772xJ8vjrzAfKhbcpOfOq6gsKs4tLNkhY9t59H/FIkw9mat8XZ8dfsabHdWUmvMeCGcDx2tU/tulBkKhd7/wt5SxTcR/9eeNZGz9zdDyjK33/lXb/IPRNbZ+qXB1WEbAuNySJ1UcXBXqpBrh35yki56aKP+btGVBcMQo3fVsv1eeHSfD5sTdz/03v1d+wPzsQWMPGXv4v/g9fbK7X6Oaurkecfz3HoWvjWvqT6PGwhg+Kj6KXcSwiYMYNhHG8DFADJs6iGFTYQwfB8RwLwcx3EsYwyccxzCa3OX5+/WjDv7+/STA78cc+P0UwO/HHfj9tOO/zz8Zp5eeirt/+t/oqGfMz5419pyx51PwvqYHhB3pM8K5XhD/LSpVDxq+IK6p2PVitkPgF7P1874kLAZXfr8U94c90by/FZu/aGtkuC+2B0L+O+rgyo3fxF4OYv5K8Ppq8PpaXA3Kd/qXHP2u7NUA2rb7vxy3y78Sd//qv9n9Xzc/e8PYm8be+jfvnIwmd/1WOC85OFGHDw23+vZ9ft2B3yOGulmIO4o5hRuG97pwLmHdeMpc+Ju5/3HQqdjMFb+Fqtp6udjMvdhNfCzeDjbvLdlBQGIb49txG2NsbEv2tj8mxC61nH0kedWRG3v3y9tCBbNFnFwXau1tBxvj244UiurXyZW/hbS8Svnr5HdkPuf9ppxWGhsazPdo8CsAvx32f03j/7eq6w9yRItdqjrfWj9V5Y8EgiqxLqPJXQWPCPegd4VrsWZQl4mXav7/K0/R5C7v3ezwM76nZnShol92cFiMdtw9RJO7fjsk33Pg95gUdQ/R5C7vZeFm9L6wexDWjafMheNN0tmbIAib5Pth3SQTFYG4w5EqAuXvaD9w9Cu2D+K6xnSOkpvrQ2GOqArwQ8Dm9hFBAb7iQAmNByjAjxz4PQGiAF8RbkYfCzcjYd14E9IKELFJfpxWgEkzVinVxSe6hOTGK8BP/qAK0EWOPhXmiKoAPwVsbp8RFOCrDpTQZIAC/MyB31MgCvBV4Wb0uVABCuvGm5JWgIhN8vO0AkyasVKpLr7QJSQvXgF+8cdWgNIcfSnMEVUBfgnY3P5EUICvOVBCZQAF+CcHfpdDFOBrws3oK6ECFNaNV55WgIhN8qu0AkyasUKpLr7WJSQ/XgF+/cdWgNIcfSPMEVUBfgPY3P7senOLJnf9poT+nK1/M7ay2L8VvhmbepITiv3bsBf7I8E77tWy/zux42q/789286jg90K/45XC9w6UQvxHrjl4l793v3DD+4ujuP4lLq6xS/30lrAmvL8IY/qDo5j+EMSUqqL8J2rCzvhX5f5KTVQfwMfa/ZhOFOODIn8Ku1R73JFkqQJ8usFPDvyeBvnN9E/CI/9noRQR1o2nzEW8FPk5e9vD+isz/vVS/Tdj86nXPOGDW/+WPuGi3kBAov6eTlTUGwxI1D/SiYp6QwGJ+iWdqKg3HJCoX9OJinojAYnKaJdOlDcakKgd0omKemMBiaqRTlTUGw9IVM10oqLeRECidkwnKupNBiRqp3Siot5UQKJ2Ticq6l0F+CPJLulERb1ywIraNZ2oqFcJSNRu6USZP/8AElUrnaioNwOQqNrpREW9WYBE1UknKurNASSqbjpRUW8eIFH10omKegsAiaqfTlTUW0j4VuJ0oqLeIkCidk8nKuotBiRqj3Siot5SQKIaphMV9ZYBErVnOlFR73BAohqlExX1VgAS1TidqKi3CpCoJu30jFbQZB+8aCoDzcV+S1XTduFn3ItSUM10BYX90otmgIJqTimoFrqCwn6GdgtAQe1NKah9dAWF/UjOfQAF1ZJSUBFdQWE/4SsCKKhMSkFl6QqqgFpQWYCCakUpqNa6giqkFlRrQEG1oRRUW11BFVELqi2goLIpBdVOV1DF1IJqByioHEpBtdcVVAm1oNoDCmpfSkHtpyuoUmpB7QcoqP0pBdVBV1Bl1ILqACiojuk/uka9/jXCzxilrHxPt/IrqAXlAVZ+LqWg8nQFVUktqDxAQeVTCqpAV1BV1IIqABRUIaWgimSgedj3GRUBCqqYUlAluoLCvs+oBFBQB1AK6kBdQWHfZ3QgoKAOohRUJ11BYd9n1AlQUJ3Tv9+JeusBv9/pQln5XXUrH/v+na6Ald+NUlDddQWFff9Od0BB9UgfJVFv3t7hZ+xJWfm9dCsf+76YXoCV35tSUH10BYV9X0wfQEH1pRRUP11BYd8X0w9QUP0pBTVAV1DY98UMABTUQEpBDdIVVDm1oAYBCmowpaCG6AoK+/6dIYCCGkopqGG6gsK+f2cYoKCGUwpqhK6gsO/fGQEoqJGUgholA83Hvn9nFKCgRlMKaoyuoLDv3xkDKKixlIIapyso7Pt3xgEKajyloCboCgr7/p0JgIKaSCmoSbqCwn5O0CRAQU2mFNQUXUFh32c0BVBQUykFVaorKOz7jEoBBVVGKahyXUFhPyeoHFBQFZSCqtQVFPb9UJWAgqqiFNQ0XUFh3w81DVBQ0ykFNUNXUNj3Q80AFNRMSkHN0hUU9v1QswAFNZtSUHN0BYV9P9QcQEHNpRTUPF1BYd8PNQ9QUPMpBbVAV1DY90MtABTUwZSCWqgrKOz7oRYCCuoQ9QOUyzN4ieoD+IK7Ra5Wfk0xaINs3S4S73Sycx0qDOBOZo46cUmOv9SJV3LH8y5u5xDYn1w97xJhMbjye0m7bQEWzRul7qr9Abvq0j/irrpUuJAOg+6qhznaVZe1cwi8zMGuujzku6rv9/L0rhq7vMGAXfXwP+KuerhwIR0B3VWPcLSrrmjnEHiFg111Zch3Vd/vlQ52VRtrsv4vCU4A9eJf0i6cp+iqdulTbjjglDvyj3jKHSks9NXQU261o1PuqHYOgY9ycModHfJTzvf7aMgp55/GqxycciuFp9wqYb7XpE85bzTglDvmj3jKHSMs9LXQU26to1Pu2HYOgY91cMqtC/kp5/u9DnLK+afxGgen3NHCU26NMN/r06ecNx5wyh33RzzljhMW+vHQU+54R6fcCe0cAp/g4JTbEPJTzvd7A+SU80/j9Q5OuXXCU269MN8b06ecNxlwyp34RzzlThQW+knQU+4kR6fcye0cAp/s4JTbFPJTzvd7E+SU80/jjQ5OuQ3CU26jMN+npE8576oa4Wc89Y94yp0qLPTN0FNus6NT7rR2DoFPc3DKnR7yU873+3TIKeefxqc4OOU2CU+5U4T5PiN9ynmVgF7uzD/iKXemsNDPgp5yZzk65c5u5xD4bAen3DkhP+V8v8+BnHL+aXyGg1PudOEpd4Yw3+emTzlvBuCUO++PeMqdJyz086Gn3PmOTrkL2jkEvsDBKXdhyE853+8LIaecfxqf6+CUO0d4yp0rzPdF6VPOmwM45S7+I55yFwsL/RLoKXeJo1Pu0nYOgS91cMpdFvJTzvf7Msgp55/GFzk45S4UnnIXCfN9efqU8xYATrkr/oin3BXCQr8Sespd6eiUu6qdQ+CrHJxyV4f8lPP9vhpyyvmn8eUOTrnLhKfc5cJ8X5M+5bxFgFPu2j/iKXetsNCvg55y1zk65a5v5xD4egen3A0hP+V8v2+AnHL+aXyNg1PuauEpd40w3zemTzlvKeCUu+mPeMrdJCz0m6Gn3M2OTrlb2jkEvsXBKXdryE853+9bIaecfxrf6OCUu0F4yt0ozPdt6VPOOxxwyt3+RzzlbhcW+h3QU+4OR6fcne0cAt/p4JS7K+SnnO/3XZBTzj+Nb3Nwyt0qPOVuE+b77vQp560CnHL3/BFPuXuEhX4v9JS719Epd187h8D3OTjl7g/5Kef7fT/klPNP47sdnHJ3CU+5u4X5fqBduPPh143PWMPhmokmd3kPCPMR8zN2qddio2xdviPBPA8a/x8y9rCxR4w9auwxY48be8LYk8aeMva0sWeMPWvsOWPPG3vB2IvGXjL2srFXjL1q7DVjrxt7w9ibxt4y9raxLcbeMfausfeMvd9ua5D8ONUM4uXz7Jqx/dhDlrGHLWOPWMYetYw9Zhl73DL2hGXsScvYU5axpy1jz1jGnrWMPWcZe94y9oJl7EXL2EuWsZctY69Yxl61jL1mGXvdMvaGZexNy9hblrG3LWNbLGPvWMbetYy9Zxl7PxiLv3YMXrsGr9Hkru3WbLL7y4OCvaqyyr+i3kPCfW/mUDcqPjEXyfjs5+JhSfy25vWR5OfKDeLnPSrMxaww5yL/n5zeY8n5HI3z2Xs8mblyt4uf94QwF7PDmYtoAqf35O/0ubDqX3z2nvp9cxVb4uc9LczFnLDlotjK6T3zv/tc9H/47D37v85V9H/Gz3tOmIu54clF7r/h9J7/X3wu+rc+ey/893OV/4f4eS8KczEvDLko+o+c3kv/nc/R/8Jn7+X/Zq7ofxU/7xVhLuZXby4K/ktO79X/5HP+f+2z99q/nSu/6n+In/e6MBcLqisXRf8Tp/fG/+1z8f/os/fm/zFXSdX/HD/vLWEuDk59LqK/g9N72+Zz9Hf57G3517m83xk/7x1hLhamMhcVv5vTe3d7n/OS8Nl7L26u3Kqk4ue9L8zFISnKRTS5yxP+fsAT9rdefH+WbC4WQXIh7IM8oY735glzcSgkF0K95wn1inewMBeLIbkQnmuecF/2FglzscRRLtR/bxWuX09Yf56r+CX+fTTZPCs1xgftVD7npfQNJjru7d9g8mE7h8D+5Op5PxIWgyu/P2q3LcCieX8rtroZ2xaXy2J7X1ZsFVELrmZub/s3KHwcxPyTdhnb/1X046AI48c+sfylVL3rK3at2F83PxYW/Sfi5LpY4B+307975+N2jNPuPWGuP5X5XJifytPuU0en3WftHAJ/5uC0+zzkp53v9+fw0+49WbGVlFtwnZx2XwQx/zLxtPvCctp9mYLT7j3hafeFsOi/dJRc9a6v9PlPut3Ty8jQn8QfBZtGDXENKluDr8RqQb1p+Tn+yoFKCrvfsdpR+/01RB0qa/wbx/tENLnL83PyjYN94ithDP8MWC9/drBevhUr9JhW+TaO1VUs1PX0jbCevnMU1+/a/Wvnpt6b3hXG4XtZHPIrU9m5fi/OX+z6SzuHwH9x0Ln+EPLO1ff7B3jn+q6s2MpyLbhOOte/BjH/MbFz/aulc/0xBZ2rYteKda5/FRb9j46Sq971lT7/FHJF+l2wadQUx/A7YQyVG+/PIc+HXy8/O1C3Qr+dPIkcq0O1klXWzt9C3hn5Mfybgxj+LIzh3yG/lVDuX/8I+Z7j5+QfDvacXxx1fr847KhjsVCvIWU9/eoorr+moKNWvtM9I0cVh6LcVHbUOu7tO+odchwC+5Or562RE+6O2ve7Rs62AIvmTWlH/Y5ssyiutOA66ahrBjHfMSdj++65Zs6/dtT+P3LdUSt2rVhHXVNY9DvmuEmuetdX+rxTjnCBZ+gXnH+K+puGuqP+VXhyKjfenUOeD79eds7Rq1uh30466lgdqpWssnZ2cRzDaHLXb2t5Fwcx3FkYw13FMYxd6jNAuX/tFvI9x8/Jbg72nFriziGmoWrluOuoY7FQryFlPdV2FNfaOe476i3CONSRxaHSS2VHXUecv9hVN8chcF0HHXW9kHfUvt/14B31FllH7VVZcJ101PWDmDdI7KjrWzrqBinoqLcIO+r6wqJvkOMmuepdX+nz7iFXU7WDTUPdUdcWxlC58e4R8nz49bKHA3W7h7iTUfPF6lCtZJW10zDkHbUfw4YOYriHMIZ7Qjpq5f7VKOR7jp+TRg72nMaOOr/GDjvqWCzUa0hZT00cxbVJCjrqt4UddVNZHPJS2lE3Fecvdu2V4xB4LwcddbOQd9S+383gHfXbso66PGUddfMg5i0SO+rmlo66RQo66reFHXVzYdG3yHGTXPWur/R575CrqSbBpqHuqJsIY6jcePcJeT78etnHgboV+u2ko47VoVrJKmunZcg7aj+GLR3EcB9hDCOQjlq5f2WGfM/xc5LpYM/JctT5ZTnsqGOxUK8hZT21chTXVinoqJWfNd9aFofSlH7eZWtx/mJXmxyHwG0cdNRtQ95R+363hXfUb+k+Ji9ln3eZHcS8XWJHnW3pqNuloKN+S9hRZwuLvl2Om+Sqd32lzzkhV1Otgk1D3VG3EsZQufG2D3k+/Hpp70DdCv120lHH6lCtZJW1s2/IO2o/hvs6iGF7YQz3g3TUyv1r/5DvOX5O9new53Rw1Pl1cNhRx2KhXkPKeuroKK4dU9BRvynsqKOyOOSWpLKjjorzF7u8HIfAnoOOOjfkHbXvdy68o35T9yUDRRZcJx11XhDz/MSOOs/SUeenoKN+U9hR5wmLPj/HTXLVu77S54KQq6mOwaah7qg7CmOo3HgLQ54Pv14KHahbod9OOupYHaqVrLJ2ikLeUfsxLHIQw0JhDIshHbVy/yoJ+Z7j56TEwZ5zgKPO7wCHHXUsFuo1pKynAx3F9cAUdNRvCDvqg2RxKCtOZUd9kDh/satTjkPgTg466s4h76h9vzvDO+o3dB+IX2zBddJRdwli3jWxo+5i6ai7pqCjfkPYUXcRFn3XHDfJVe/6Sp+7hVxNHRhsGuqO+kBhDJUbb/eQ58Ovl+4O1K3QbycddawO1UpWWTs9Qt5R+zHs4SCG3YUx7AnpqJX7V6+Q7zl+Tno52HN6O+r8ejvsqGOxUK8hZT31cRTXPinoqF8XdtR9ZXEoSOm7vvuK8xe7+uU4BO7noKPuH/KO2ve7P7yjfl33BUspe9f3gCDmAxM76gGWjnpgCjrq14Ud9QBh0Q/McZNc9a6v9HlQyNVUn2DTUHfUfYQxVG68g0OeD79eBjtQt0K/nXTUsTpUK1ll7QwJeUftx3CIgxgOFsZwKKSjVu5fw0K+5/g5GeZgzxnuqPMb7rCjjsVCvYaU9TTCUVxHpKCjfk3YUY/U/YWmIJUd9Uhx/mLXqByHwKMcdNSjQ95R+36PhnfUr+k66jILrpOOekwQ87GJHfUYS0c9NgUd9WvCjnqMsOjH5rhJrnrXV/o8LuRqakSwaag76hHCGCo33vEhz4dfL+MdqFuh30466lgdqpWssnYmhLyj9mM4wUEMxwtjOBHSUSv3r0kh33P8nExysOdMdtT5TXbYUcdioV5Dynqa4iiuU1LQUb8q7Kin6vRkYSo76qni/MWu0hyHwKUOOuqykHfUvt9l8I76Vd27vkstuE466vIg5hWJHXW5paOuSEFH/aqwoy4XFn1Fjpvkqnd9pc+VIVdTU4JNQ91RTxHGULnxVoU8H369VDlQt0K/nXTUsTpUK1ll7UwLeUftx3CagxhWCWM4HdJRK/evGSHfc/yczHCw58x01PnNdNhRx2KhXkPKeprlKK6zUtBRvyLsqGfL4lCc0m/Pmi3OX+yak+MQeI6DjnpuyDtq3++58I76FVlHXZSyb8+aF8R8fmJHPc/SUc9PQUf9irCjnics+vk5bpKr3vWVPi8IuZqaFWwa6o56ljCGyo334JDnw6+Xgx2oW6HfTjrqWB2qlayydhaGvKP2Y7jQQQwPFsbwEEhHrdy/FoV8z/FzssjBnnOoo87vUIcddSwW6jWkrKfFjuK6OAUd9cvCjnoJtKNeIs5f7Fqa4xB4qYOO+rCQd9S+34fBO+qXgR31siDmyxM76mWWjnp5Cjrql4Ud9TJh0S+HdNRKnw8PuZpaHGwa6o56sTCGyo33iJDnw6+XIxyoW6HfTjrqWB2qlayydlaEvKP2Y7jCQQyPEMZwJaSjVu5fq0K+5/g5WeVgzznSUed3pMOOOhYL9RpS1tNqR3FdnYKO+iVhR32ULA4FKf2s76PE+YtdR+c4BD7aQUe9JuQdte/3GnhH/ZKsoy5N2Wd9HxPEfG1iR32MpaNem4KO+iVhR32MsOjX5rhJrnrXV/p8bMjV1Opg01B31KuFMVRuvOtCng+/XtY5ULdCv5101LE6VCtZZe2sD3lH7cdwvYMYrhPG8DhIR63cv44P+Z7j5+R4B3vOCY46vxMcdtSxWKjXkLKeNjiK64YUdNQvCjvqjbqOuiKVHfVGcf5i14k5DoFPdNBRnxTyjtr3+yR4R/2irqPOs+A66ahPDmK+KbGjPtnSUW9KQUf9orCjPllY9Jty3CRXvesrfT4l5GpqQ7BpqDvqDcIYKjfeU0OeD79eTnWgboV+O+moY3WoVrLK2tkc8o7aj+FmBzE8VRjD0yAdtXL/Oj3ke46fk9Md7DlnOOr8znDYUcdioV5Dyno601Fcz0xBR/2CsKM+SxaH3JT+jfoscf5i19k5DoHPdtBRnxPyjtr3+xx4R/2CrKOuSNnfqM8NYn5eYkd9rqWjPi8FHfULwo76XGHRn5fjJrnqXV/p8/khV1NnBpuGuqM+UxhD5cZ7Qcjz4dfLBQ7UrdBvJx11rA7VSlZZOxeGvKP2Y3ihgxheIIzhRZCOWrl/XRzyPcfPycUO9pxLHHV+lzjsqGOxUK8hZT1d6iiul6ago35e2FFfJotDXl4qO+rLxPmLXZfnOAS+3EFHfUXIO2rf7yvgHfXzso66vMKC66SjvjKI+VWJHfWVlo76qhR01M8LO+orhUV/VY6b5Kp3faXPV4dcTV0abBrqjvpSYQyVG+81Ic+HXy/XOFC3Qr+ddNSxOlQrWWXtXBvyjtqP4bUOYniNMIbXQTpq5f51fcj3HD8n1zvYc25w1Pnd4LCjjsVCvYaU9XSjo7jemIKO+jlhR32TLA6VKf0b9U3i/MWum3McAt/soKO+JeQdte/3LfCO+jlZR+2l7G/UtwYxvy2xo77V0lHfloKO+jlhR32rsOhvy3GTXPWur/T59pCrqRuDTUPdUd8ojKFy470j5Pnw6+UOB+pW6LeTjjpWh2olq6ydO0PeUfsxvNNBDO8QxvAuSEet3L/uDvme4+fkbgd7zj2OOr97HHbUsVio15Cynu51FNd7U9BRPyvsqO+TxSE/pR31feL8xa77cxwC3++go34g5B217/cD8I76WVlHXZayjvrBIOYPJXbUD1o66odS0FE/K+yoHxQW/UM5bpKr3vWVPj8ccjV1b7BpqDvqe4UxVG68j4Q8H369POJA3Qr9dtJRx+pQrWSVtfNoyDtqP4aPOojhI8IYPgbpqJX71+Mh33P8nDzuYM95wlHn94TDjjoWC/UaUtbTk47i+mQKOupnhB31U7I4FJWksqN+Spy/2PV0jkPgpx101M+EvKP2/X4G3lE/I+uoi4ssuE466meDmD+X2FE/a+mon0tBR/2MsKN+Vlj0z+W4Sa7896hCn58PuZp6Mtg01B31k8IYKjfeF0KeD79eXnCgboV+O+moY3WoVrLK2nkx5B21H8MXHcTwBWEMX4J01Mr96+WQ7zl+Tl52sOe84qjze8VhRx2LhXoNKevpVUdxfTUFHfXTwo76Nd1faFLaUb8mzl/sej3HIfDrDjrqN0LeUft+vwHvqJ+WddT5Keuo3wxi/lZiR/2mpaN+KwUd9dPCjvpNYdG/leMmuepdX+nz2yFXU68Gm4a6o35VGEPlxrsl5Pnw62WLA3Ur9NtJRx2rQ7WSVdbOOyHvqP0YvuMghluEMXwX0lEr96/3Qr7n+Dl5z8Ge876jzu99hx11LBbqNaSspw8cxfWDFHTUTwk76g91f6OOprKj/lCcv9j1UY5D4I8cdNQfh7yj9v3+GN5RPyXrqEuiFlwnHfUnQcw/TeyoP7F01J+moKN+SthRfyIs+k9z3CRXvesrff4s5Grqg2DTUHfUHwhjqNx4Pw95Pvx6+dyBuhX67aSjjtWhWskqa+eLkHfUfgy/cBDDz4Ux/BLSUSv3rz+FfM/xc/InB3vOV446v68cdtSxWKjXkLKevnYU169T0FE/Keyov9HpSS+VHfU34vzFrj/nOAT+s4OO+tuQd9S+39/CO+onZR11YZUF10lH/V0Q8+8TO+rvLB319ynoqJ8UdtTfCYv++xw3yVXv+kqf/xJyNfV1sGmoO+qvhTFUbrw/hDwffr384EDdCv120lHH6lCtZJW189eQd9R+DP/qIIY/CGP4I6SjVu5fP4V8z/Fz8pODPednR53fzw476lgs1GtIWU9/cxTXv6Wgo35C2FH/Xfeex5R+e9bfxfmLXf/IcQj8Dwcd9S8h76h9v3+Bd9RP6D6ZLGXfnvVrLObtM7bvnn+1dNT+P3LdUT8h7Kh/VRZ9ezfJVe/6Sp93aB9uNfW3YNNQd9R/E8ZQufHWCHk+/HrxGdXqVui3k446VodqJausnZqOYxhN7vptLfuM6hjG106yMdxRHMPYpT4DlPvXTiHfc/yc7ORgz9lZmOt4DbVze3cddSwW6jWkrKddHMV1l/buO+rHhR31rrI4VKb0b9S7ivMXu3Zr7xB4t/b6eWsJDxZXftdqvy3AonlT2lE/rvv2rJT9jbp2EPM6iR117fb/2lHXSUFH/biwo64tLPo67d0kV73rK32uG3I1tUuwaag76l2EMVRuvPVCng+/Xuo5ULf1xJ2Mmi9Wh2olq6yd+iHvqP0Y1ncQw3rCGDaAdNTK/Wv3kO85fk52d7Dn7OGo89vDYUcdi4V6DSnrqaGjuDZMQUf9mLCj3lMWh6qCVHbUe4rzF7satXcI3MhBR9045B2173djeEf9mKyjjpZZcJ101E2CmDdN7KibWDrqpinoqB8TdtRNhEXftL2b5Kp3faXPe4VcTTUMNg11R91QGEPlxtss5Pnw66WZA3Ur9NtJRx2rQ7WSVdZO85B31H4MmzuIYTNhDFtAOmrl/rV3yPccPyd7O9hz9nHU+e3jsKOOxUK9hpT11NJRXFumoKN+VNhRR2RxKEnpu74j4vzFrsz2DoEzHXTUWSHvqH2/s+Ad9aO656hT9q7vVkHMWyd21K0sHXXrFHTUjwo76lbCom/d3k1y1bu+0uc2IVdTLYNNQ91RtxTGULnxtg15Pvx6aetA3Qr9dtJRx+pQrWSVtZMd8o7aj2G2gxi2FcawHaSjVu5fOSHfc/yc5DjYc9o76vzaO+yoY7FQryFlPe3rKK77pqCjfkTYUe+n+xt1Sj/rez9x/mLX/u0dAu/voKPuEPKO2ve7A7yjfkT3ru+UfdZ3xyDm0cSOuqOlo46moKN+RNhRdxQWfbS9m+Sqd32lz17I1dS+waah7qj3FcZQufHmhjwffr3kOlC3Qr+ddNSxOlQrWWXt5IW8o/ZjmOcghrnCGOZDOmrl/lUQ8j3Hz0mBgz2n0FHnV+iwo47FQr2GlPVU5CiuRUFcU9ldPtxO60vsKm7vELjYQXdZEvLu0ve7xEF3aWNVLJASB4tYuPCc5zusMVT6fQBETBQJfT4w5GLC9/UAB2LioJCLbz8vBznec5KNYSdHwqFTNQiHhxwJh87tHQJ3diAcuoRcOPh+d4EIB7+QuzhYxMKF5zzfYY2h0u+uEOHQSehzt5ALh998dSAcuodcOPh56e54z0k2hj0cCYceKfgb/oPCv+H3FK6hVIqlnuL8xa5e7R0C93IglnqHXCz5fvdOkViKJnd5PQJW9Z8OewhzpMx3n5AfoP5G18fBAdo35Aeo73NfB373c3To9bO8BUQdE9c5U6zx3g5Ej3K99w953fsx7O8ghn2EMRwAabSUZ87AkJ8Tfk4GOtgvBznaLwc5/HNvLBbqNaSsp8GO1pA6loOFPtfI2P5S12qOzu9oJJhniPF/qLFhxoYbG2FspLFRxkYbG2NsrLFxxsYbm2BsorFJxiYbm2JsqrFSY2XGyo1VGKs0VmVsmrHpxmYYm2lslrHZxuYYm9t+a5Di182QQGfEjw21jA2zjP0/9s4D2qnia/uIqCi9iQoIiIJyL5czSe5NrhUrdsEGKpbbAogIKogKFrChIHaxY2+ogL33hkjvvXcQsGIBvxk98zeEUUqeZ5z53py19iKOrMPez96zz/7lJCenGtZOM6ydblg7w7B2pmGtnWGtvWHtLMPa2Ya1cwxrHQxr5xrWzjOsnW9Yu8CwVmRYKzaslRjWSg1rZYa1pGGto2Gtk2Gts2HtQsNaF8PaRYa1roa1iw0zbYXwz1bhn8g9m+m5TgH0Kv0R6TbAvte/DafXo3KhYpanFm0h+v3ppjg183NFQv3EacBc3OJyLmL/81OcnlnMQUrM4oxMzhXZRD9xJjAXt7qZiyDNT9FuO2MuSG4Ws2i/fedKGPQTZwFzMcC1XCSMfoqztz3m+D/ELM7Z1nPF/1E/0QGYi4Hu5CLyL36Kc7cl5vi/xizO2/pzlWxBP3E+MBe3uZCL+Bb9FBdsXczBVsQsirbmXMFW6SeKgbkY9N/mIn8r/RQlW4o5ttUxi9J/PVcsuQ36iTJgLm7/r3IR3yY/RfKfY05sY8yi4z+cqzC5zfqJTsBc3GE/F8F2+Ck6m2IOtitmceHm5xLbqZ/oAszFnTZzUbrdfoqLNo05mkHMomvKuSLJjPQTFwNzcZelXASZHQL4/oAA8q1I5bNMc3G3J7kAcpAAzvHiNmAu7vEkF8B5TwDnFXEHMBf3epIL4HVNAPuyuBuYi/tIuUA/CgS4fwWw/gRLP/TnApAzRjfYfdyo1QdA4fze9MOj3ZsTHe7eHH/eS4DFwIr7kuZ/Cww6r9UHQF0MK7ZSaw+AujTU/LLwJvz/7opeGhZh6tplzfkPgEJ0LX1381Jg0V8GTi5jg1/aHP9pk0ub+3G16wrMdQ9YzAUxm1e7HqSrXc/mRId7Eq52lzt+tVNxX+751a4rrNgKSwzuUq52vULNr0i/2vUyXO2usHC16wq82vUCFv0VpOSiuz4y5itx3dP42edM/bskbBrlwTWIRIOrwNMCummpHF9FmJJcj1vXDjru3p5Mh8ga70PuE0Fmh1A56UPoE1cBNbzag/1yNWG/XAOe0PWsck2Krywt0PXUB1hP15J0vbY5/0v+FwF1uA6mQ6zMJrleB86fPvo2Jzrcl0Cu/RwnVxV3P8/J9SJYsRVHDO5SyPX6UPMb0sn1egO53mCBXBFdS5Pr9cCiv4GUXHTXR8Z8o+MT6bVh00A/beNaoIbIxnuT4/lQ9XITYboFxk15coOuQ/Qki6ydmx0nI6XhzQQNbwJq2N+TdyWQ/esWx3uOyskthJ5zK4n8biUStdYCvYeQ9TSApOsAC0SN/KT7QJgO8YhNoh4Izp8+bmtOdPg2AlEPcpyoVdyDPCfqLrBiS5QZ3KUQ9e2h5nekE/XtBqK+wwJRI7qWJurbgUV/Bym56K6PjPlOx6epAWHTQBP1AKCGyMZ7l+P5UPVyF2G6BcZNIWpdh+hJFlk7dztO1ErDuwka3gXU8B5PiBrZv+51vOeonNxL6Dn3kcjvPiJRay3QewhZT4NJug62QNQXAnW4H6ZDmdUH0d8Pzp8+HmhOdPgBAlE/6DhRq7gf9JyoL4QVm0ga3KUQ9UOh5g+nE/VDBqJ+2AJRI7qWJuqHgEX/MCm56K6PjPkRx6epwWHTQBP1YKCGyMb7qOP5UPXyKGG6BcZNIWpdh+hJFlk7QxwnaqXhEIKGjwI1fMwTokb2r8cd7zkqJ48Tes4TJPJ7gkjUWgv0HkLW05MkXZ+0QNSdgTo8BdMhapWonwLnTx9PNyc6/DSBqJ9xnKhV3M94TtSdYcVWYo2onw01fy6dqJ81EPVzFoga0bU0UT8LLPrnSMlFd31kzM87Pk09GTYNNFE/CdQQ2XhfcDwfql5eIEy3wLgpRK3rED3JImtnqONErTQcStDwBaCGL3pC1Mj+9ZLjPUfl5CVCz3mZRH4vE4laa4HeQ8h6GkbSdZgFokY+a344TIciq8+7HA7Onz5GNCc6PIJA1K84TtQq7lc8J+pOsGIrsPa8y1dDzV9LJ+pXDUT9mgWiRnQtTdSvAov+NVJy0V0fGfPrjk9Tw8KmgSbqYUANkY33DcfzoerlDcJ0C4ybQtS6DtGTLLJ23nScqJWGbxI0fAOo4VueEDWyf73teM9ROXmb0HPeIZHfO0Si1lqg9xCynt4l6fquBaLuCNThPZgOkUKbRP0eOH/6eL850eH3CUT9geNEreL+wHOi7ggrttK4wV0KUX8Yav5ROlF/aCDqjywQNaJraaL+EFj0H5GSi+76yJg/dnyaejdsGmiifheoIbLxfuJ4PlS9fEKYboFxU4ha1yF6kkXWzqeOE7XS8FOChp8ANfzME6JG9q/PHe85KiefE3rOFyTy+4JI1FoL9B5C1tOXJF2/tEDUSaAOX8F0KE7YJOqvwPnTx8jmRIdHEoj6a8eJWsX9tedEnYQVWyxhcJdC1KNCzb9JJ+pRBqL+xgJRI7qWJupRwKL/hpRcdNdHxjza8Wnqy7BpoIn6S6CGyMY7xvF8qHoZQ5hugXFTiFrXIXqSRdbOWMeJWmk4lqDhGKCG4zwhamT/Gu94z1E5GU/oORNI5DeBSNRaC/QeQtbTRJKuEy0QdRlQh0kwHfKtfup7Ejh/+pjcnOjwZAJRT3GcqFXcUzwn6jLc207WPvU9NdR8WjpRTzUQ9TQLRI3oWpqopwKLfhopueiuj4x5uuPT1MSwaaCJeiJQQ2TjneF4PlS9zCBMt8C4KUSt6xA9ySJrZ6bjRK00nEnQcAZQw1meEDWyf812vOeonMwm9Jw5JPKbQyRqrQV6DyHraS5J17kWiLoUqMM83B2afJtEPQ+cP33Mb050eD6BqBc4TtQq7gWeE3UpDrqKDe5SiHphqPmidKJeaCDqRRaIGtG1NFEvBBb9IlJy0V0fGfNix6epuWHTQBP1XKCGyMa7xPF8qHpZQphugXFTiFrXIXqSRdbOUseJWmm4lKDhEqCGyzwhamT/Wu54z1E5WU7oOStI5LeCSNRaC/QeQtbTSpKuKy0QdQlQh1W4ebLAJlGvAudPH6ubEx1eTSDqbx0nahX3t54TdQnubacig7sUol4Tar42najXGIh6rQWiRnQtTdRrgEW/lpRcdNdHxrzO8WlqZdg00ES9EqghsvF+53g+VL18R5hugXFTiFrXIXqSRdbO944TtdLwe4KG3wE1/METokb2rx8d7zkqJz8Ses5PJPL7iUjUWgv0HkLW088kXX+2QNTFQB3Ww3RIWP31rPXg/Onjl+ZEh38hEPWvjhO1ivtXz4m6GFZscWu/nvVbqPnv6UT9m4Gof7dA1IiupYn6N2DR/05KLrrrI2Pe4Pg09XPYNNBE/TNQQ2Tj3eh4PlS9bCRMt8C4KUSt6xA9ySJr5w/HiVpp+AdBw43IwSfHD6JG9q8dctzuOSonykf0ni4PzHXqDFU+h0fUWgv0HkLW044kXXfM4RN1EVCHCjAd7BJ1BXD+9LFTDtHhnXLw5905x22iVnHvnPO3wKDzWiXqIg+JepdQ84o55Tal511yNidq9ZfYRF0EJOpdgEVfMYeTXHTXR8a8q+PT1I5h00AT9Y5ADZGNdzfH86HqZTfCdLsbmGTQ/uk6RE+yyNqpRNYwyOz4cy9XImi4G1DDyp4QNbJ/VXG856icVCH0nKok8qtKJGqtBXoPIeupGknXahaI+gIgUVeH6ZBv9Vnf1cH500eNHKLDNQhEXdNxolZx1/ScqC+AEXWRtWd91wo1r51O1LUMRF3bAlFfACTqWsCir53DSS666yNjruP4NFUtbBpooq4G1BDZeHd3PB+qXnYnTLfAuClEresQPckia6eu40StNKxL0HB3oIZ7eELUyP61p+M9R+VkT0LP2YtEfnsRiVprgd5DyHqqR9K1ngWiPh9I1PVxRF1qk6jrg/OnjwY5RIcbEIh6b8eJWsW9t+dEfT6OqKMGdylE3TDUvFE6UTc0EHUjC0R9PpCoGwKLvlEOJ7noro+MubHj01S9sGmgiboeUENk493H8XyoetmHMN0C46YQta5D9CSLrJ0mjhO10rAJQcN9gBru6wlRI/vXfo73HJWT/Qg9pymJ/JoSiVprgd5DyHpqRtK1mQWiPg9I1PvDdIhYvUe9Pzh/+jggh+jwAQSibu44Uau4m3tO1OfBiLrU2j3qnFDz3HSizjEQda4Foj4PSNQ5wKLPzeEkF931kTG3cHyaahY2DTRRNwNqiGy8eY7nQ9VLHmG6BcZNIWpdh+hJFlk7LR0naqVhS4KGeUANA0+IGtm/hOM9R+VEEHpOhER+ESJRay3QewhZT1GSrlELRH0ukKhjMB2iUZtEHQPnTx/5OUSH8wlEXeA4Uau4Czwn6nNhRF1SanCXQtTxUPNEOlHHDUSdsEDU5wKJOg4s+kQOJ7noro+MudDxaSoaNg00UUeBGiIb74GO50PVy4GE6RYYN4WodR2iJ1lk7RzkOFErDQ8iaHggUMODPSFqZP86xPGeo3JyCKHnHEoiv0OJRK21QO8hZD0dRtL1MAtE3QFI1K1gOpRZvUfdCpw/fRyeQ3T4cAJRH+E4Uau4j/CcqDvAiFpYu0d9ZKj5UelEfaSBqI+yQNQdgER9JLDoj8rhJBfd9ZExH+34NHVY2DTQRH0YUENk4z3G8XyoejmGMN0C46YQta5D9CSLrJ3WjhO10rA1QcNjgBoe6wlRI/vXcY73HJWT4wg953gS+R1PJGqtBXoPIevpBJKuJ1gg6nOARH0iTIeYVaI+EZw/fZyUQ3T4JAJRn+w4Uau4T/acqM/B/Wi7NaI+JdS8TTpRn2Ig6jYWiPocIFGfAiz6Njmc5KK7PjLmto5PUyeETQNN1CcANUQ23lMdz4eql1MJ0y0wbgpR6zpET7LI2jnNcaJWGp5G0PBUoIane0LUyP51huM9R+XkDELPOZNEfmcSiVprgd5DyHpqR9K1nQWiPhtI1O1hOsQLbRJ1e3D+9HFWDtHhswhEfbbjRK3iPttzoj4b96PtcYO7FKI+J9S8QzpRn2Mg6g4WiPpsIFGfAyz6Djmc5MLfRwXGfK7j01S7sGmgibodUENk4z3P8XyoejmPMN0C46YQta5D9CSLrJ3zHSdqpeH5BA3PA2p4gSdEjexfRY73HJWTIkLPKSaRXzGRqLUW6D2ErKcSkq4lFoj6LCBRl+Lu0Fgl6lJw/vRRlkN0uIxA1EnHiVrFnfScqM+CEXXMGlF3DDXvlE7UHQ1E3ckCUZ8FJOqOwKLvlMNJLrrrI2Pu7Pg0VRI2DTRRlwA1RDbeCx3Ph6qXCwnTLTBuClHrOkRPssja6eI4USsNuxA0vBCo4UWeEDWyf3V1vOeonHQl9JyLSeR3MZGotRboPYSsp24kXbtZIOr2QKLujrtHHdgk6u7g/Onjkhyiw5cQiPpSx4laxX2p50TdHkbUhYHBXQpRXxZq3iOdqC8zEHUPC0TdHkjUlwGLvkcOJ7noro+Muafj01S3sGmgibobUENk473c8XyoermcMN0C46YQta5D9CSLrJ1ejhO10rAXQcPLgRpe4QlRI/vXlY73HJWTKwk95yoS+V1FJGqtBXoPIeupN0nX3haIuh2QqPvg5klhk6j7gPOnj6tziA5fTSDqaxwnahX3NZ4TdTsYURckDe5SiPraUPPr0on6WgNRX2eBqNsBifpaYNFfl8NJLrrrI2Pu6/g01TtsGmii7g3UENl4+zmeD1Uv/QjTLTBuClHrOkRPssjaud5xolYaXk/QsB9Qwxs8IWpk/7rR8Z6jcnIjoefcRCK/m4hErbVA7yFkPd1M0vVmC0R9JpCo++M+82j117P6g/Onj1tYRK0cvoVA1Lc6TtQq7ls9J+ozcU8ms/brWQNCzQemE/UAA1EPtEDUZwKJegCw6AfmcJKL7vrImG9zfJq6OWwaaKK+GaghsvEOcjwfql4GEaZbYNwUotZ1iJ5kkbVzu+NErTS8naDhIKCGd3hC1Mj+dafjPUfl5E5Cz7mLRH53EYlaa4HeQ8h6upuk690WiPoMIFHfA9OhzOo96nvA+dPHvTlEh+8lEPV9jhO1ivs+z4n6DNyvZ1m7Rz041Pz+dKIebCDq+y0Q9RlAoh4MLPr7czjJRXd9ZMwPOD5N3R02DTRR3w3UENl4H3Q8H6peHiRMt8C4KUSt6xA9ySJr5yHHiVpp+BBBwweBGj7sCVEj+9cjjvcclZNHCD3nURL5PUokaq0Feg8h62kISdchFoj6dCBRPwbTIZlvk6gfA+dPH4/nEB1+nEDUTzhO1CruJzwn6tNhRB0UG9ylEPWToeZPpRP1kwaifsoCUZ8OJOongUX/VA4nueiuj4z5acenqSFh00AT9RCghsjG+4zj+VD18gxhugXGTSFqXYfoSRZZO886TtRKw2cJGj4D1PA5T4ga2b+ed7znqJw8T+g5L5DI7wUiUWst0HsIWU9DSboOtUDUpwGJ+kWYDoVWP/X9Ijh/+ngph+jwSwSiftlxolZxv+w5UZ+G+x61tU99Dws1H55O1MMMRD3cAlGfBiTqYcCiH57DSS666yNjHuH4NDU0bBpooh4K1BDZeF9xPB+qXl4hTLfAuClEresQPckia+dVx4laafgqQcNXgBq+5glRI/vX6473HJWT1wk95w0S+b1BJGqtBXoPIevpTZKub1og6lOBRP0W7h611Wd9vwXOnz7eziE6/DaBqN9xnKhV3O94TtSn4j71be1Z3++Gmr+XTtTvGoj6PQtEfSqQqN8FFv17OZzkors+Mub3HZ+m3gybBpqo3wRqiGy8HzieD1UvHxCmW2DcFKLWdYieZJG186HjRK00/JCg4QdADT/yhKiR/etjx3uOysnHhJ7zCYn8PiEStdYCvYeQ9fQpSddPQ11t0mXb5thY9PFZDtHhzwh0+bnjdKni/pxAlyZfERvkc8ImBm48er5d1RAZ9xeeDBOfAmP+0vFhQsX6BWGY+Mrx4Vvl5Styz8lUw5GkwWHkfzA4tCENDl/nEB3+mjA4jHJ8cFBxj/JkcFCFPIqwiYEbj55vVzVExv2NJ4PDSGDMox0fHFSs3xAGhzGODw4qL2PIPSdTDceSBoexFu7hnwK8hz8OuIdsDkvjcjjD0vgcosPjCcPSBMeHJRX3BEvDUpDZIcaGvqJvHY4F5giZ74mOX0BVo5tIuIBOcvwCqmKeRIh7MumiN9nwERC0JuycIfb4BMLQg9zvUxyve6XhFIKGE4EaTvUEtJDXnGmOXydUTqYR+uV0Ur+cTrzdq7VA7yFkPc0g7SG0ljOAMZcvt+kB/+JSM5ymjcLzzJTxz5I2W9ocaXOlzZM2X9oCaQulLZK2WNoSaUulLZO2XNoKaSulrZK2Wtq30tZIWyttnbTvpH0v7QdpP0r7SdrP0tZL+0Xarzl/iZS6b2aGc0bq2izD2mzD2hzD2lzD2jzD2nzD2gLD2kLD2iLD2mLD2hLD2lLD2jLD2nLD2grD2krD2irD2mrD2reGtTWGtbWGtXWGte8Ma98b1n4wrP1oWPvJsPazYW29Ye0Xw9qvhpm2Qvhnq/DPILNjkz2baX+ZCehV+iPSs4B975k2nF6fnotMYla5mA3R76+8zsn8XJFQPzEXmItnXc5F7H9+inmZxRykxCzmZ3KuyCb6iQXAXDznZi6CND/Fwu2MuSC5Wcxi0fadK2HQTywG5uJ513KRMPoplmx7zPF/iFks3dZzxf9RP7EMmIsX3MlF5F/8FMu3Jeb4v8YsVmz9uUq2oJ9YCczFUBdyEd+in2LV1sUcbEXMYvXWnCvYKv3Et8BcvPjf5iJ/K/0Ua7YUc2yrYxZr//VcseQ26CfWAXPx0n+Vi/g2+Sm+++eYE9sYs/j+H85VmNxm/cQPwFy8bD8XwXb4KX40xRxsV8zip83PJbZTP/EzMBfDbOaidLv9FOs3jTmaQczil5RzRZIZ6Sd+BeZiuKVcBJkdAvj+gADyrUjls4wfQuZJLoAcJIBzvBgKzMUrnuQCOO8J4LwiXgbm4lVPcgG8rglgXxYjgLl4jZQL9KNAgPtXAOtPsPRDfy4AOWP8BruPG7X6ACic35t+ePT3HKLDv+fgz7sBWAysuDfk/C0w6LxWHwD1K6zYSq09AGpjqPkf4U34/90V3RgWYeraHzn8B0Ahupa+u7kRWPR/gJPL2OAbc/CfjNqY48fV7hdkg8tFxVwQs3m1w/m96dVuh1yiw+rk6POWz3X7aqfiLp/7t8Cg81q92v0CawyFJQZ3KVe7HUPNK+SW2/TKtmPu5lc79ZfYV7tfgFe7HYFFXyGXk1x010fGvFMucIOXw1+J1RVeNY3y4BpEosHOudhpAd20VI53zsXnxvW4de2g494FHHc5Up9A1nhFcp8IMjuEyklFQp/YGdhrd/Vgv+xK2C+7gSd0PavsluIrSwt0PVUE1lMlkq6Vcvlf8l8P7E2VYTrEymySa2Vw/vRRJZfocBUCuVZ1nFxV3FU9J9f1MHItjhjcpZBrtVDz6unkWs1ArtUtkOt6ILlWAxZ99VxOctFdHxlzDccn0kph00A/baMSUENk463peD5UvdQkTLc1yVM9ol6qEiZZZO3UcpyMlIa1CBrWBGpY25N3JZD9q47jPUflpA6h5+xOIr/diUSttUDvIWQ91SXpWtcCUSM/6b4HTId4xCZR7wHOnz72zCU6vCeBqPdynKhV3Ht5TtQ/w4g6UWZwl0LU9ULN66cTdT0DUde3QNQ/A4m6HrDo6+dykovu+siYGzg+TdUNmwaaqOsCNUQ23r0dz4eql70J0y0wbgpR6zpET7LI2mnoOFErDRsSNNwbqGEjT4ga2b8aO95zVE4aE3rOPiTy24dI1FoL9B5C1lMTkq5NLBD1T0Ci3hemQ5nVB9HvC86fPvbLJTq8H4GomzpO1Crupp4T9U8wohZJg7sUom4War5/OlE3MxD1/haI+icgUTcDFv3+uZzkors+MuYDHJ+mmoRNA03UTYAaIhtvc8fzoeqlOWG6BcZNIWpdh+hJFlk7OY4TtdIwh6Bhc6CGuZ4QNbJ/tXC856ictCD0nDwS+eURiVprgd5DyHpqSdK1pQWi/hFI1AFMh6hVog7A+dOHyCU6LAhEHXGcqFXcEc+J+kcYUZdYI+poqHksnaijBqKOWSDqH4FEHQUWfSyXk1x010fGnO/4NNUybBpoom4J1BDZeAscz4eqlwLCdAuMm0LUug7RkyyyduKOE7XSME7QsACoYcITokb2r0LHe47KSSGh5xxIIr8DiUSttUDvIWQ9HUTS9SALRI181vzBMB2KrD7v8mBw/vRxSC7R4UMIRH2o40St4j7Uc6L+AUbUBdaed3lYqHmrdKI+zEDUrSwQ9Q9Aoj4MWPStcjnJRXd9ZMyHOz5NHRQ2DTRRHwTUENl4j3A8H6pejiBMt8C4KUSt6xA9ySJr50jHiVppeCRBwyOAGh7lCVEj+9fRjvcclZOjCT3nGBL5HUMkaq0Feg8h66k1SdfWFoj6eyBRHwvTIVJok6iPBedPH8flEh0+jkDUxztO1Cru4z0n6u9xPzIQN7hLIeoTQs1PTCfqEwxEfaIFov4eSNQnAIv+xFxOctFdHxnzSY5PU63DpoEm6tZADZGN92TH86Hq5WTCdAuMm0LUug7Rkyyydk5xnKiVhqcQNDwZqGEbT4ga2b/aOt5zVE7aEnrOqSTyO5VI1FoL9B5C1tNpJF1Ps0DU3wGJ+nSYDsUJm0R9Ojh/+jgjl+jwGQSiPtNxolZxn+k5UX8HI+pYwuAuhajbhZq3Tyfqdgaibm+BqL8DEnU7YNG3z+UkF931kTGf5fg0dVrYNNBEfRpQQ2TjPdvxfKh6OZsw3QLjphC1rkP0JIusnXMcJ2ql4TkEDc8GatjBE6JG9q9zHe85KifnEnrOeSTyO49I1FoL9B5C1tP5JF3Pt0DU64BEfQFMh3yrn/q+AJw/fRTlEh0uIhB1seNEreIu9pyo1+F+Pcvap75LQs1L04m6xEDUpRaIeh2QqEuARV+ay0kuuusjYy5zfJo6P2waaKI+H6ghsvEmHc+HqpckYboFxk0hal2H6EkWWTsdHSdqpWFHgoZJoIadPCFqZP/q7HjPUTnpTOg5F5LI70IiUWst0HsIWU9dSLp2sUDUa4FEfRHuDk2+TaK+CJw/fXTNJTrclUDUFztO1Cruiz0n6rU4oi42uEsh6m6h5t3Tibqbgai7WyDqtUCi7gYs+u65nOSiuz4y5kscn6a6hE0DTdRdgBoiG++ljudD1culhOkWGDeFqHUdoidZZO1c5jhRKw0vI2h4KVDDHp4QNbJ/9XS856ic9CT0nMtJ5Hc5kai1Fug9hKynXiRde1kg6jVAor4CN08W2CTqK8D508eVuUSHryQQ9VWOE7WK+yrPiXoN7lPfRQZ3KUTdO9S8TzpR9zYQdR8LRL0GSNS9gUXfJ5eTXHTXR8Z8tePTVK+waaCJuhdQQ2TjvcbxfKh6uYYw3QLjphC1rkP0JIusnWsdJ2ql4bUEDa8BanidJ0SN7F99He85Kid9CT2nH4n8+hGJWmuB3kPIerqepOv1Foj6WyBR3wDTIWH117NuAOdPHzfmEh2+kUDUNzlO1Crumzwn6m9hRB239utZN4ea908n6psNRN3fAlF/CyTqm4FF3z+Xk1x010fGfIvj09T1YdNAE/X1QA2RjfdWx/Oh6uVWwnQLjJtC1LoO0ZMssnYGOE7USsMBBA1vBWo40BOiRvav2xzvOSontxF6ziAS+Q0iErXWAr2HkPV0O0nX2y0Q9WogUd/hKVHfAc6fPu7MJTp8J4Go73KcqFXcd3lO1Ks9JOq7Q83vSSfquw1EfY8Fol4NJOq7gUV/jydEjYz5XsenqdvDpoEm6tuBGiIb732O50PVy32E6RYYN4WodR2iJ1lk7Qx2nKiVhoMJGt4H1PB+T4ga2b8ecLznqJw8QOg5D5LI70EiUWst0HsIWU8PkXR9yAJRrwIS9cMwHfKtPuv7YXD+9PFILtHhRwhE/ajjRK3iftRzol4FI+oia8/6HhJq/lg6UQ8xEPVjFoh6FZCohwCL/rFcTnLRXR8Z8+OOT1MPhU0DTdQPATVENt4nHM+HqpcnCNMtMG4KUes6RE+yyNp50nGiVho+SdDwCaCGT3lC1Mj+9bTjPUfl5GlCz3mGRH7PEIlaa4HeQ8h6epak67MWiHolkKifwxF1qU2ifg6cP308n0t0+HkCUb/gOFGruF/wnKhX4og6anCXQtRDQ81fTCfqoQaiftECUa8EEvVQYNG/mMtJLrrrI2N+yfFp6tmwaaCJ+lmghsjG+7Lj+VD18jJhugXGTSFqXYfoSRZZO8McJ2ql4TCChi8DNRzuCVEj+9cIx3uOyskIQs95hUR+rxCJWmuB3kPIenqVpOurFoh6BZCoX4PpELF6j/o1cP708Xou0eHXCUT9huNEreJ+w3OiXgEj6lJr96jfDDV/K52o3zQQ9VsWiHoFkKjfBBb9W7mc5KK7PjLmtx2fpl4NmwaaqF8FaohsvO84ng9VL+8Qpltg3BSi1nWInmSRtfOu40StNHyXoOE7QA3f84Sokf3rfcd7jsrJ+4Se8wGJ/D4gErXWAr2HkPX0IUnXDy0Q9XIgUX8E0yEatUnUH4Hzp4+Pc4kOf0wg6k8cJ2oV9yeeE/VyGFGXlBrcpRD1p6Hmn6UT9acGov7MAlEvBxL1p8Ci/yyXk1x010fG/Lnj09SHYdNAE/WHQA2RjfcLx/Oh6uULwnQLjJtC1LoO0ZMssna+dJyolYZfEjT8AqjhV54QNbJ/jXS856icjCT0nK9J5Pc1kai1Fug9hKynUSRdR1kg6mVAov4GpkOZ1XvU34Dzp4/RuUSHRxOIeozjRK3iHuM5US+DEbWwdo96bKj5uHSiHmsg6nEWiHoZkKjHAot+XC4nueiuj4x5vOPT1KiwaaCJehRQQ2TjneB4PlS9TCBMt8C4KUSt6xA9ySJrZ6LjRK00nEjQcAJQw0meEDWyf012vOeonEwm9JwpJPKbQiRqrQV6DyHraSpJ16kWiHopkKinwXSIWSXqaeD86WN6LtHh6QSinuE4Uau4Z3hO1EthRF1sjahnhprPSifqmQainmWBqJcCiXomsOhn5XKSi+76yJhnOz5NTQ2bBpqopwI1RDbeOY7nQ9XLHMJ0C4ybQtS6DtGTLLJ25jpO1ErDuQQN5wA1nOcJUSP713zHe47KyXxCz1lAIr8FRKLWWqD3ELKeFpJ0XWiBqJcAiXoRTId4oU2iXgTOnz4W5xIdXkwg6iWOE7WKe4nnRL0ERtSJuMFdClEvDTVflk7USw1EvcwCUS8BEvVSYNEvy+UkF/4+KjDm5Y5PUwvDpoEm6oVADZGNd4Xj+VD1soIw3QLjphC1rkP0JIusnZWOE7XScCVBwxVADVd5QtTI/rXa8Z6jcrKa0HO+JZHft0Si1lqg9xCyntaQdF1jgagXA4l6Le4OjVWiXgvOnz7W5RIdXkcg6u8cJ2oV93eeE/ViGFHHrBH196HmP6QT9fcGov7BAlEvBhL198Ci/yGXk1x010fG/KPj09SasGmgiXoNUENk4/3J8XyoevmJMN0C46YQta5D9CSLrJ2fHSdqpeHPBA1/Amq43hOiRvavXxzvOSonvxB6zq8k8vuVSNRaC/QeQtbTbyRdf7NA1IuARP077h51YJOofwfnTx8bcokObyAQ9UbHiVrFvdFzol4EI+rCwOAuhaj/0Jq3KLcpPf9hIGr1l9hEvQhI1H8gi74FJ7noro+MeYcWbk9Tv4VNA03UvwE1RDbe8o7nQ9WL8hE93QLjphC1rkP0JIusnR3JGgaZHX/uZeUjWsPU2slUwwpgDfWBvgYg+9dOjvcclZOdCD1nZ2CuU2eonVvwiFprgd5DyHrahaTrLi34RL0QSNQVcfOksEnUFcH508euLYgO79oCf97dgBcWVty7tfhbYNB5rRL1QhhRFyQN7lKIulKoeeV0oq7UYnOirmyBqBcCiboSsOgrt+AkF931kTFXcXya2iVsGmii3gWoIbLxVnU8H6peqhKmW2DcFKLWdYieZJG1U81xolYaViNoWBWoYXVPiBrZv2o43nNUTmoQek5NEvnVJBK11gK9h5D1VIukay0LRL0ASNS1YTrErP56Vm1w/vRRpwXR4ToEot7dcaJWce/uOVEvwD2ZzNqvZ9UNNd8jnajrGoh6DwtEvQBI1HWBRb9HC05y0V0fGfOejk9TtcKmgSbqWkANkY13L8fzoeplL8J0C4ybQtS6DtGTLLJ26jlO1ErDegQN9wJqWN8Tokb2rwaO9xyVkwaEnrM3ifz2JhK11gK9h5D11JCka0MLRD0fSNSNYDqUWb1H3QicP300bkF0uDGBqPdxnKhV3Pt4TtTzcb+eZe0edZNQ833TibqJgaj3tUDU84FE3QRY9Pu24CQX3fWRMe/n+DTVMGwaaKJuCNQQ2XibOp4PVS9NCdMtMG4KUes6RE+yyNpp5jhRKw2bETRsCtRwf0+IGtm/DnC856icHEDoOc1J5NecSNRaC/QeQtZTDknXHAtEPQ9I1LkwHZL5Nok6F5w/fbRoQXS4BYGo8xwnahV3nudEPQ9G1EGxwV0KUbcMNQ/SibqlgagDC0Q9D0jULYFFH7TgJBfd9ZExC8enqZywaaCJOgeoIbLxRhzPh6qXCGG6BcZNIWpdh+hJFlk7UceJWmkYJWgYAWoY84Sokf0r3/Geo3KST+g5BSTyKyAStdYCvYeQ9RQn6Rq3QNRzgUSdgOlQaPVT3wlw/vRR2ILocCGBqA90nKhV3Ad6TtRzcd+jtvap74NCzQ9OJ+qDDER9sAWingsk6oOARX9wC05y0V0fGfMhjk9T8bBpoIk6DtQQ2XgPdTwfql4OJUy3wLgpRK3rED3JImvnMMeJWml4GEHDQ4EatvKEqJH963DHe47KyeGEnnMEifyOIBK11gK9h5D1dCRJ1yMtEPUcIFEfhbtHbfVZ30eB86ePo1sQHT6aQNTHOE7UKu5jPCfqObhPfVt71nfrUPNj04m6tYGoj7VA1HOARN0aWPTHtuAkF931kTEf5/g0dWTYNNBEfSRQQ2TjPd7xfKh6OZ4w3QLjphC1rkP0JIusnRMcJ2ql4QkEDY8HaniiJ0SN7F8nOd5zVE5OIvSck0nkdzKRqLUW6D2ErKdTSLqeEupqky5n52Bj0UebFkSH2xDosq3jdKnibkugS5OviA3SlrCJgRuPnm9XNUTGfaonw8QpwJhPc3yYULGeShgmTnd8+FZ5OZ3cczLV8AzS4HDGfzA4zCINDme2IDp8JmFwaOf44KDibufJ4KAKuR1hEwM3Hj3frmqIjLu9J4PDGcCYz3J8cFCxticMDmc7PjiovJxN7jmZangOaXA4x8I9/JnAe/gdgHvI5rDUoQVnWDq3BdHhcwnD0nmOD0sq7vMsDUtBZoc4J/QVfevwHGCOkPk+3/ELqGp05xMuoBc4fgFVMV9AiLuIdNErMnwEBK0JO2eIPX4eYehB7vdix+teaVhM0PB8oIYlnoAW8ppT6vh1QuWklNAvy0j9sox4u1drgd5DyHpKkvYQWsskMOby5TY90L6+3gynaaPwPB1l/J2kdZZ2obQu0i6S1lXaxdK6Sesu7RJpl0q7TFoPaT2lXS6tl7QrpF0p7SppvaX1kXa1tGukXSvtOml9pfWTdr20G6TdKO2mFn+JlLpvOoZzRupaJ8NaZ8PahYa1Loa1iwxrXQ1rFxvWuhnWuhvWLjGsXWpYu8yw1sOw1tOwdrlhrZdh7QrD2pWGtasMa70Na30Ma1cb1q4xrF1rWLvOsNbXsNbPsHa9Ye0Gw9qNhrWbDDNthfDPVuGfQWbHJns20/7SEdCr9EekOwH73mdtOL0+PReZxKxy0Rmi3195vTDzc0VC/UQXYC4+dzkXsf/5KS7KLOYgJWbRNZNzRTbRT1wMzMUXbuYiSPNTdNvOmAuSm8Usum/fuRIG/cQlwFx86VouEkY/xaXbHnP8H2IWl23rueL/qJ/oAczFV+7kIvIvfoqe2xJz/F9jFpdv/blKtqCf6AXMxUgXchHfop/iiq2LOdiKmMWVW3OuYKv0E1cBc/H1f5uL/K30U/TeUsyxrY5Z9PnXc8WS26CfuBqYi1H/VS7i2+SnuOafY05sY8zi2n84V2Fym/UT1wFz8Y39XATb4afoa4o52K6YRb/NzyW2Uz9xPTAXo23monS7/RQ3bBpzNIOYxY0p54okM9JP3ATMxRhLuQgyOwTw/QEB5FuRymeZ5mKsJ7kAcpAAzvFiJDAX4zzJBXDeE8B5RXwDzMV4T3IBvK4JYF8WY4G5mEDKBfpRIMD9K4D1J1j6oT8XgJwxbobdx41afQAUzu9NPzzavwXR4f4t8Oe9BVgMrLhvafG3wKDzWn0A1E2wYiu19gCoW0PNB4Q34f93V/TWsAhT1wa04D8ACtG19N3NW4FFPwCcXMYGv7UF/pNRt7bw42p3IzDXA2ExF8RsXu0Gkq52t7UgOnwb4Wo3yPGrnYp7kOdXuxthxVZYYnCXcrW7PdT8jvSr3e2Gq90dFq52NwKvdrcDi/4OUnLRXR8Z85247mn87HOm/t0SNo3y4BpEosFd4GkB3bRUju8iTEmux61rBx333Z5Mh8gav4fcJ4LMDqFycg+hT9wF1PBeD/bLvYT9ch94Qtezyn0pvrK0QNfTPcB6GkzSdXAL/pf8bwDqcD9Mh1iZTXK9H5w/fTzQgujwAwRyfdBxclVxP+g5ud4AK7biiMFdCrk+FGr+cDq5PmQg14ctkCuia2lyfQhY9A+Tkovu+siYH3F8Ih0cNg300zYGAzVENt5HHc+HqpdHCdMtMG7Kkxt0HaInWWTtDHGcjJSGQwgaPgrU8DFP3pVA9q/HHe85KiePE3rOEyTye4JI1FoL9B5C1tOTJF2ftEDUyE+6PwXTIR6xSdRPgfOnj6dbEB1+mkDUzzhO1CruZzwn6uthxZYoM7hLIepnQ82fSyfqZw1E/ZwFokZ0LU3UzwKL/jlSctFdHxnz845PU0+GTQNN1E8CNUQ23hccz4eqlxcI0y0wbgpR6zpET7LI2hnqOFErDYcSNHwBqOGLnhA1sn+95HjPUTl5idBzXiaR38tEotZaoPcQsp6GkXQdZoGo+wF1GA7Toczqg+iHg/OnjxEtiA6PIBD1K44TtYr7Fc+Juh+s2ETS4C6FqF8NNX8tnahfNRD1axaIGtG1NFG/Ciz610jJRXd9ZMyvOz5NDQubBpqohwE1RDbeNxzPh6qXNwjTLTBuClHrOkRPssjaedNxolYavknQ8A2ghm95QtTI/vW24z1H5eRtQs95h0R+7xCJWmuB3kPIenqXpOu7Foi6L1CH92A6RK0S9Xvg/Onj/RZEh98nEPUHjhO1ivsDz4m6L6zYSqwR9Yeh5h+lE/WHBqL+yAJRI7qWJuoPgUX/ESm56K6PjPljx6epd8OmgSbqd4EaIhvvJ47nQ9XLJ4TpFhg3hah1HaInWWTtfOo4USsNPyVo+AlQw888IWpk//rc8Z6jcvI5oed8QSK/L4hErbVA7yFkPX1J0vVLC0SNfNb8VzAdiqw+7/IrcP70MbIF0eGRBKL+2nGiVnF/7TlRXwcrtgJrz7scFWr+TTpRjzIQ9TcWiBrRtTRRjwIW/Tek5KK7PjLm0Y5PU1+GTQNN1F8CNUQ23jGO50PVyxjCdAuMm0LUug7RkyyydsY6TtRKw7EEDccANRznCVEj+9d4x3uOysl4Qs+ZQCK/CUSi1lqg9xCyniaSdJ1ogaivBeowCaZDpNAmUU8C508fk1sQHZ5MIOopjhO1inuK50R9LazYSuMGdylEPTXUfFo6UU81EPU0C0SN6FqaqKcCi34aKbnoro+Mebrj09TEsGmgiXoiUENk453heD5UvcwgTLfAuClEresQPckia2em40StNJxJ0HAGUMNZnhA1sn/NdrznqJzMJvScOSTym0Mkaq0Feg8h62kuSde5Foj6GqAO82A6FCdsEvU8cP70Mb8F0eH5BKJe4DhRq7gXeE7U18CKLZYwuEsh6oWh5ovSiXqhgagXWSBqRNfSRL0QWPSLSMlFd31kzIsdn6bmhk0DTdRzgRoiG+8Sx/Oh6mUJYboFxk0hal2H6EkWWTtLHSdqpeFSgoZLgBou84Sokf1rueM9R+VkOaHnrCCR3woiUWst0HsIWU8rSbqutEDUVwN1WAXTId/qp75XgfOnj9UtiA6vJhD1t44TtYr7W8+J+mrc207WPvW9JtR8bTpRrzEQ9VoLRI3oWpqo1wCLfi0pueiuj4x5nePT1MqwaaCJeiVQQ2Tj/c7xfKh6+Y4w3QLjphC1rkP0JIusne8dJ2ql4fcEDb8DaviDJ0SN7F8/Ot5zVE5+JPScn0jk9xORqLUW6D2ErKefSbr+bIGo+wB1WI+7Q5Nvk6jXg/Onj19aEB3+hUDUvzpO1CruXz0n6j446Co2uEsh6t9CzX9PJ+rfDET9uwWiRnQtTdS/AYv+d1Jy0V0fGfMGx6epn8OmgSbqn4EaIhvvRsfzoeplI2G6BcZNIWpdh+hJFlk7fzhO1ErDPwgabkQOPnl+EDWyf+2Q53bPUTlRPqL3dHlgrlNnqPJ5PKLWWqD3ELKediTpumMen6h7A3WoANOhuMAmUVcA508fO+URHd4pD3/enfPcJmoV9855fwsMOq9Vou6Ne9upyOAuhah3CTWvmFduU3reJW9zolZ/iU3UvYFEvQuw6CvmcZKL7vrImHd1fJraMWwaaKLeEaghsvHu5ng+VL3sRphudwOTDNo/XYfoSRZZO5XIGgaZHX/u5UoEDXcDaljZE6JG9q8qjvcclZMqhJ5TlUR+VYlErbVA7yFkPVUj6VrNAlFfBSTq6jAdElZ/Pas6OH/6qJFHdLgGgahrOk7UKu6anhP1VTCijlv79axaoea104m6loGoa1sg6quARF0LWPS18zjJRXd9ZMx1HJ+mqoVNA03U1YAaIhvv7o7nQ9XL7oTpFhg3hah1HaInWWTt1HWcqJWGdQka7g7UcA9PiBrZv/Z0vOeonOxJ6Dl7kchvLyJRay3QewhZT/VIutazQNRXAom6vqdEXR+cP300yCM63IBA1Hs7TtQq7r09J+orPSTqhqHmjdKJuqGBqBtZIOorgUTdEFj0jTwhamTMjR2fpuqFTQNN1PWAGiIb7z6O50PVyz6E6RYYN4WodR2iJ1lk7TRxnKiVhk0IGu4D1HBfT4ga2b/2c7znqJzsR+g5TUnk15RI1FoL9B5C1lMzkq7NLBD1FUCi3h+mQ77VZ33vD86fPg7IIzp8AIGomztO1Cru5p4T9RUwoi6y9qzvnFDz3HSizjEQda4For4CSNQ5wKLPzeMkF931kTG3cHyaahY2DTRRNwNqiGy8eY7nQ9VLHmG6BcZNIWpdh+hJFlk7LR0naqVhS4KGeUANA0+IGtm/hOM9R+VEEHpOhER+ESJRay3QewhZT1GSrlELRN0LSNQxHFGX2iTqGDh/+sjPIzqcTyDqAseJWsVd4DlR98IRddTgLoWo46HmiXSijhuIOmGBqHsBiToOLPpEHie56K6PjLnQ8WkqGjYNNFFHgRoiG++BjudD1cuBhOkWGDeFqHUdoidZZO0c5DhRKw0PImh4IFDDgz0hamT/OsTxnqNycgih5xxKIr9DiUSttUDvIWQ9HUbS9TALRH05kKhbwXSIWL1H3QqcP30cnkd0+HACUR/hOFGruI/wnKgvhxF1qbV71EeGmh+VTtRHGoj6KAtEfTmQqI8EFv1ReZzkors+MuajHZ+mDgubBpqoDwNqiGy8xzieD1UvxxCmW2DcFKLWdYieZJG109pxolYatiZoeAxQw2M9IWpk/zrO8Z6jcnIcoeccTyK/44lErbVA7yFkPZ1A0vUEC0TdE0jUJ8J0iEZtEvWJ4Pzp46Q8osMnEYj6ZMeJWsV9sudE3RNG1CWlBncpRH1KqHmbdKI+xUDUbSwQdU8gUZ8CLPo2eZzkors+Mua2jk9TJ4RNA03UJwA1RDbeUx3Ph6qXUwnTLTBuClHrOkRPssjaOc1xolYankbQ8FSghqd7QtTI/nWG4z1H5eQMQs85k0R+ZxKJWmuB3kPIempH0rWdBaLuASTq9jAdyqzeo24Pzp8+zsojOnwWgajPdpyoVdxne07UPWBELazdoz4n1LxDOlGfYyDqDhaIugeQqM8BFn2HPE5y0V0fGfO5jk9T7cKmgSbqdkANkY33PMfzoerlPMJ0C4ybQtS6DtGTLLJ2znecqJWG5xM0PA+o4QWeEDWyfxU53nNUTooIPaeYRH7FRKLWWqD3ELKeSki6llgg6suARF0K0yFmlahLwfnTR1ke0eEyAlEnHSdqFXfSc6K+DEbUxdaIumOoead0ou5oIOpOFoj6MiBRdwQWfac8TnLRXR8Zc2fHp6mSsGmgiboEqCGy8V7oeD5UvVxImG6BcVOIWtchepJF1k4Xx4laadiFoOGFQA0v8oSokf2rq+M9R+WkK6HnXEwiv4uJRK21QO8hZD11I+nazQJRXwok6u4wHeKFNom6Ozh/+rgkj+jwJQSivtRxolZxX+o5UV8KI+pE3OAuhagvCzXvkU7UlxmIuocFor4USNSXAYu+Rx4nufD3UYEx93R8muoWNg00UXcDaohsvJc7ng9VL5cTpltg3BSi1nWInmSRtdPLcaJWGvYiaHg5UMMrPCFqZP+60vGeo3JyJaHnXEUiv6uIRK21QO8hZD31Juna2wJRXwIk6j64OzRWiboPOH/6uDqP6PDVBKK+xnGiVnFf4zlRXwIj6pg1or421Py6dKK+1kDU11kg6kuARH0tsOivy+MkF931kTH3dXya6h02DTRR9wZqiGy8/RzPh6qXfoTpFhg3hah1HaInWWTtXO84USsNrydo2A+o4Q2eEDWyf93oeM9RObmR0HNuIpHfTUSi1lqg9xCynm4m6XqzBaLuDiTq/rh71IFNou4Pzp8+bskjOnwLgahvdZyoVdy3ek7U3WFEXRgY3KUQ9YBQ84HpRD3AQNQDLRB1dyBRDwAW/cA8TnLRXR8Z822OT1M3h00DTdQ3AzVENt5BjudD1csgwnQLjJtC1LoO0ZMssnZud5yolYa3EzQcBNTwDk+IGtm/7nS856ic3EnoOXeRyO8uIlFrLdB7CFlPd5N0vdsCUXcDEvU9uHlS2CTqe8D508e9eUSH7yUQ9X2OE7WK+z7PibobjKgLkgZ3KUQ9ONT8/nSiHmwg6vstEHU3IFEPBhb9/Xmc5KK7PjLmBxyfpu4OmwaaqO8GaohsvA86ng9VLw8Spltg3BSi1nWInmSRtfOQ40StNHyIoOGDQA0f9oSokf3rEcd7jsrJI4Se8yiJ/B4lErXWAr2HkPU0hKTrEAtEfTGQqB/DfebR6q9nPQbOnz4ezyM6/DiBqJ9wnKhV3E94TtQX455MZu3Xs54MNX8qnaifNBD1UxaI+mIgUT8JLPqn8jjJRXd9ZMxPOz5NDQmbBpqohwA1RDbeZxzPh6qXZwjTLTBuClHrOkRPssjaedZxolYaPkvQ8Bmghs95QtTI/vW84z1H5eR5Qs95gUR+LxCJWmuB3kPIehpK0nWoBaLuCiTqF2E6lFm9R/0iOH/6eCmP6PBLBKJ+2XGiVnG/7DlRd8X9epa1e9TDQs2HpxP1MANRD7dA1F2BRD0MWPTD8zjJRXd9ZMwjHJ+mhoZNA03UQ4EaIhvvK47nQ9XLK4TpFhg3hah1HaInWWTtvOo4USsNXyVo+ApQw9c8IWpk/3rd8Z6jcvI6oee8QSK/N4hErbVA7yFkPb1J0vVNC0R9EZCo34LpkMy3SdRvgfOnj7fziA6/TSDqdxwnahX3O54T9UUwog6KDe5SiPrdUPP30on6XQNRv2eBqC8CEvW7wKJ/L4+TXHTXR8b8vuPT1Jth00AT9ZtADZGN9wPH86Hq5QPCdAuMm0LUug7Rkyyydj50nKiVhh8SNPwAqOFHnhA1sn997HjPUTn5mNBzPiGR3ydEotZaoPcQsp4+Jen6qQWi7gIk6s9gOhRa/dT3Z+D86ePzPKLDnxOI+gvHiVrF/YXnRN0F9z1qa5/6/jLU/Kt0ov7SQNRfWSDqLkCi/hJY9F/lcZKL7vrImEc6Pk19GjYNNFF/CtQQ2Xi/djwfql6+Jky3wLgpRK3rED3JImtnlONErTQcRdDwa6CG33hC1Mj+NdrxnqNyMprQc8aQyG8Mkai1Fug9hKynsSRdx1og6guBRD0Od4/a6rO+x4Hzp4/xeUSHxxOIeoLjRK3inuA5UV+I+9S3tWd9Tww1n5RO1BMNRD3JAlFfCCTqicCin5THSS666yNjnuz4NDU2bBpooh4L1BDZeKc4ng9VL1MI0y0wbgpR6zpET7LI2pnqOFErDacSNJwC1HCaJ0SN7F/THe85KifTCT1nBon8ZhCJWmuB3kPIeppJ0nVmqKtNuuzcAhuLPmblER2eRaDL2Y7TpYp7NoEuTb4iNshswiYGbjx6vl3VEBn3HE+GiZnAmOc6PkyoWOcQhol5jg/fKi/zyD0nUw3nkwaH+f/B4NCJNDgsyCM6vIAwOCx0fHBQcS/0ZHBQhbyQsImBG4+eb1c1RMa9yJPBYT4w5sWODw4q1kWEwWGJ44ODyssScs/JVMOlpMFhqYV7+B2B9/CXAfeQzWFpWR5nWFqeR3R4OWFYWuH4sKTiXmFpWAoyO8TS0Ff0rcOlwBwh873S8QuoanQrCRfQVY5fQFXMqwhxryZd9FYbPgKC1oSdM8QeX0EYepD7/VvH615p+C1Bw5VADdd4AlrIa85ax68TKidrCf1yHalfriPe7tVaoPcQsp6+I+0htJbfAWPeqdymYJT6+ns1H6u/UL6cHXr6HpiA8il+/hAO+j/mpQWA/kDo98DM/LD15yrZwrnEj+COUSlFO6R+G//9fJGSpIjml8Xzg4KiWH5pQTRSGokHpbH8pJBCRApjUoZkSSxRmohEk5F4pGQj1r8/Yy+fUvwqRxvD1z+Gr3+Sf/4sbX3eX5vH1ie615O6FzjHkVQtfgk35K955Tb99Lb6HxvSHEBv1vWAzfrXp7eTyV+AG/9XS6NckNkhkDH/lnIukYhGIvGo+nuJ0kDESmV7i0RKi2NBSVBUEikrjInCZCwSi5aUlhTLcxaJZJAsKilMJv7yy+b7fb+R3u/7PY/o8O+E9/s2OP5+n4p7gyc3R38NfUWfdyOJGzbm/T0ipk4G6r/3bvb3FbJhyutGzf76c0tX0z9UzlrKtZZ2r6bq30NpZXCXcjUt3/KvP3dsWW7Tq6n6H+yraapgmV5Ny7fEFf2OLf24miJjrtDSz6tphZacq+lOLYkOq5Ojz7tzS7evpirunVv+LTDovJSr6Y6hr+jz7tKSczVV502/wqHzh2yKbF//AE4tjcLzVJTx7yptN2mVpFWWVkVaVWnVpFWXVkNaTWm1pNWWVkfa7tLqSttD2p7S9pJWT1p9aQ2k7S2tobRG0hpL20daE2n7SttPWlNpzcKrc2rOlT8Vy226tqthbTfDWiXDWmXDWhXDWlXDWjXDWnXDWg3DWk3DWi3DWm3DWh3D2u6GtbqGtT0Ma3sa1vYyrNUzrNU3rDUwrO1tWGtoWGtkWGtsWNvHsNbEsLavYW0/w1pTw1qzlpvfFa0Q/tkq/DPI7Nhkz2baZyvCBstA7Aq8ri5owxks03ORScwqF7tB9Psrr5UyP1dEvyddGZiLhS7nIvb3+/BVMos5SH1Pv2om54psen+gGjAXi9zMRZB+T6T6dsZckNz8/kqN7TtXwnSvpiYwF4tdy0XCfH+q1rbHHP+ne121t/Vc8X++b1YHmIsl7uQi8m/3Cnfflpjj/37fse7Wn2uL9zD3AOZiqQu5iG/RT7Hn1sUcbEXMYq+tOVewVfqJesBcLPtvc5G/lX6K+luKObbVMYsG/3quWHIb9BN7A3Ox/L/KRXyb/BQN/znmxDbGLBr9w7kKk9usn2gMzMUK+7kItsNPsY8p5mC7YhZNNj+X2E79xL7AXKy0mYvS7fZT7LdpzNEMYhZNU84VSWakn2gGzMUqS7kIMjsE8P0BAeRbkcpnGX9y35NcADlIAOd4sRSYi289yQVw3hPAeUWsAOZijSe5AF7XBLAvi9XAXKwl5QL9AQrg/hXA+hNI/VT93iytUXi+ZuE9sf3Ce2RNwntmjcN7aA3De2oNwnts9cJ7bnuG9+Dqhvfk6oT36GqF9+xqhPfwqoX39KqE9/gqhff8/ry31rLcZkf6hzoyrT3k3LN/S1QeolYfa47ze9MPdRzQkuiwOjn6vM2BxcCKu3nKpgCd1+pjzZvBiq3U2mPNc0LNc8MPBvzvTm1OWISpa7kt+Y81R3Qtfcc1B1j0ueDkMjZ4Tkv8J41yWnImGPTVrikw1y1gMRfEbF7tWpCudnktiQ7nEa52LR2/2qm4W3p+tWsKK7bCEoO7lKtdEGou0q92geFqJyxc7ZoCr3YBsOgFKbnoro+MOYLrnsZv9GfqX/OwaZQH1yASDaLgaQHdtFSOo4QpyfW4de2g4455Mh0iazyf3CeCzA6hcpJP6BNRoIYFHuyXAsJ+iYMndD2rxFN8ZWmBrqd8YD0lSLomWm5ObujetB9Qh0KYDrEym+RaCM6fPg5sSXT4QAK5HuQ4uaq4D/KcXPeDFVtxxOAuhVwPDjU/JJ1cDzaQ6yEWyBXRtTS5Hgws+kNIyUV3fWTMhzo+kSbCpoF+hmwCqCGy8R7meD5UvRxGmG6BcVO+ja3rED3JImunleNk9OeeI2h4GFDDwz15VwLZv45wvOeonBxB6DlHksjvSCJRay3QewhZT0eRdD3KAlEjP31/NEyHeMQmUR8Nzp8+jmlJdPgYAlG3dpyoVdytPSfqfWHFligzuEsh6mNDzY9LJ+pjDUR9nAWiRnQtTdTHAov+OFJy0V0fGfPxjk9TR4VNA03URwE1RDbeExzPh6qXEwjTLTBuClHrOkRPssjaOdFxolYankjQ8ASghid5QtTI/nWy4z1H5eRkQs85hUR+pxCJWmuB3kPIempD0rWNBaJuAtShLUyHMqsPiG0Lzp8+Tm1JdPhUAlGf5jhRq7hP85yom8CKTSQN7lKI+vRQ8zPSifp0A1GfYYGoEV1LE/XpwKI/g5RcdNdHxnym49NUm7BpoIm6DVBDZONt53g+VL20I0y3wLgpRK3rED3JImunveNErTRsT9CwHVDDszwhamT/OtvxnqNycjah55xDIr9ziESttUDvIWQ9dSDp2sECUe8D1OFcmA5Rq0R9Ljh/+jivJdHh8whEfb7jRK3iPt9zot4HVmwl1oj6glDzonSivsBA1EUWiBrRtTRRXwAs+iJSctFdHxlzsePTVIewaaCJugNQQ2TjLXE8H6peSgjTLTBuClHrOkRPssjaKXWcqJWGpQQNS4AalnlC1Mj+lXS856icJAk9pyOJ/DoSiVprgd5DyHrqRNK1kwWiRj7/vjNMhyKrz7vsDM6fPi5sSXT4QgJRd3GcqFXcXTwn6sawYiuw9rzLi0LNu6YT9UUGou5qgagRXUsT9UXAou9KSi666yNjvtjxaapT2DTQRN0JqCGy8XZzPB+qXroRpltg3BSi1nWInmSRtdPdcaJWGnYnaNgNqOElnhA1sn9d6njPUTm5lNBzLiOR32VEotZaoPcQsp56kHTtYYGoGwF16AnTIVJok6h7gvOnj8tbEh2+nEDUvRwnahV3L8+JuhGs2ErjBncpRH1FqPmV6UR9hYGor7RA1IiupYn6CmDRX0lKLrrrI2O+yvFpqkfYNNBE3QOoIbLx9nY8H6peehOmW2DcFKLWdYieZJG108dxolYa9iFo2Buo4dWeEDWyf13jeM9RObmG0HOuJZHftUSi1lqg9xCynq4j6XqdBaJuCNShL0yH4oRNou4Lzp8++rUkOtyPQNTXO07UKu7rPSfqhrBiiyUM7lKI+oZQ8xvTifoGA1HfaIGoEV1LE/UNwKK/kZRcdNdHxnyT49PUdWHTQBP1dUANkY33ZsfzoerlZsJ0C4ybQtS6DtGTLLJ2+jtO1ErD/gQNbwZqeIsnRI3sX7c63nNUTm4l9JwBJPIbQCRqrQV6DyHraSBJ14EWiHpvoA63wXTIt/qp79vA+dPHoJZEhwcRiPp2x4laxX2750S9N+5tJ2uf+r4j1PzOdKK+w0DUd1ogakTX0kR9B7Do7yQlF931kTHf5fg0NTBsGmiiHgjUENl473Y8H6pe7iZMt8C4KUSt6xA9ySJr5x7HiVppeA9Bw7uBGt7rCVEj+9d9jvcclZP7CD1nMIn8BhOJWmuB3kPIerqfpOv9Foi6AVCHB3B3aPJtEvUD4Pzp48GWRIcfJBD1Q44TtYr7Ic+JugEOuooN7lKI+uFQ80fSifphA1E/YoGoEV1LE/XDwKJ/hJRcdNdHxvyo49PU/WHTQBP1/UANkY13iOP5UPUyhDDdAuOmELWuQ/Qki6ydxxwnaqXhYwQNhwA1fNwTokb2rycc7zkqJ08Qes6TJPJ7kkjUWgv0HkLW01MkXZ+yQNT1gTo8jZsnC2wS9dPg/OnjmZZEh58hEPWzjhO1ivtZz4m6Pu5tpyKDuxSifi7U/Pl0on7OQNTPWyBqRNfSRP0csOifJyUX3fWRMb/g+DT1VNg00ET9FFBDZOMd6ng+VL0MJUy3wLgpRK3rED3JImvnRceJWmn4IkHDoUANX/KEqJH962XHe47KycuEnjOMRH7DiESttUDvIWQ9DSfpOtwCUdcD6jACpkPC6q9njQDnTx+vtCQ6/AqBqF91nKhV3K96TtT1YMUWt/brWa+Fmr+eTtSvGYj6dQtEjehamqhfAxb966Tkors+MuY3HJ+mhodNA03Uw4EaIhvvm47nQ9XLm4TpFhg3hah1HaInWWTtvOU4USsN3yJo+CZQw7c9IWpk/3rH8Z6jcvIOoee8SyK/d4lErbVA7yFkPb1H0vU9C0S9F1CH9z0l6vfB+dPHBy2JDn9AIOoPHSdqFfeHnhP1Xh4S9Ueh5h+nE/VHBqL+2AJRI7qWJuqPgEX/sSdEjYz5E8enqffCpoEm6veAGiIb76eO50PVy6eE6RYYN4WodR2iJ1lk7XzmOFErDT8jaPgpUMPPPSFqZP/6wvGeo3LyBaHnfEkivy+JRK21QO8hZD19RdL1KwtEvSdQh5EwHfKtPut7JDh/+vi6JdHhrwlEPcpxolZxj/KcqPeEFVuRtWd9fxNqPjqdqL8xEPVoC0SN6FqaqL8BFv1oUnLRXR8Z8xjHp6mvwqaBJuqvgBoiG+9Yx/Oh6mUsYboFxk0hal2H6EkWWTvjHCdqpeE4goZjgRqO94Sokf1rguM9R+VkAqHnTCSR30QiUWst0HsIWU+TSLpOskDUewB1mIwj6lKbRD0ZnD99TGlJdHgKgainOk7UKu6pnhP1HjjoihrcpRD1tFDz6elEPc1A1NMtEDWia2mingYs+umk5KK7PjLmGY5PU5PCpoEm6klADZGNd6bj+VD1MpMw3QLjphC1rkP0JIusnVmOE7XScBZBw5lADWd7QtTI/jXH8Z6jcjKH0HPmkshvLpGotRboPYSsp3kkXedZIOq6QB3mw3SIWL1HPR+cP30saEl0eAGBqBc6TtQq7oWeE3VdWLGVWrtHvSjUfHE6US8yEPViC0SN6FqaqBcBi34xKbnoro+MeYnj09S8sGmgiXoeUENk413qeD5UvSwlTLfAuClEresQPckia2eZ40StNFxG0HApUMPlnhA1sn+tcLznqJysIPSclSTyW0kkaq0Feg8h62kVSddVFoh6d6AOq2E6RKM2iXo1OH/6+LYl0eFvCUS9xnGiVnGv8Zyod4cVW0mpwV0KUa8NNV+XTtRrDUS9zgJRI7qWJuq1wKJfR0ouuusjY/7O8WlqVdg00ES9CqghsvF+73g+VL18T5hugXFTiFrXIXqSRdbOD44TtdLwB4KG3wM1/NETokb2r58c7zkqJz8Res7PJPL7mUjUWgv0HkLW03qSrustEHUdoA6/wHQos3qP+hdw/vTxa0uiw78SiPo3x4laxf2b50RdB1Zswto96t9DzTekE/XvBqLeYIGoEV1LE/XvwKLfQEouuusjY97o+DS1PmwaaKJeD9QQ2Xj/cDwfql7+IEy3wLgpRK3rED3JQi/agdtErTRUPqI1/AOo4Q5gDfWBvgYg+1f5wO2eo3KifETv6R2BuU6doXYMeESttUDvIWQ9VSDpWiHgE3VtoA47wXSIWSXqncD508fOAdHhnQP8eXcJ3CZqFfcuKZcZ0HmtEnVt2OBXbI2oK4aa7xqU25SeKwabE7X6S2yirg0k6orAot814CQX3fWRMe/m+DRVIWwaaKKuANQQ2XgrOZ4PVS+VCNMtMG4KUes6RE+yyNqp7DhRKw0rEzSsBNSwiidEjexfVR3vOSonVQk9pxqJ/KoRiVprgd5DyHqqTtK1ugWirgUk6howHeKFNom6Bjh/+qgZEB2uSSDqWo4TtYq7ludEXQtG1Im4wV0KUdcONa+TTtS1DURdxwJR1wISdW1g0dcJOMmFv48KjHl3x6ep6mHTQBN1daCGyMZb1/F8qHqpS5hugXFTiFrXIXqSRdbOHo4TtdJwD4KGdYEa7ukJUSP7116O9xyVk70IPaceifzqEYlaa4HeQ8h6qk/Stb4Foq4JJOoGuDs0Vom6ATh/+tg7IDq8N4GoGzpO1Cruhp4TdU0YUcesEXWjUPPG6UTdyEDUjS0QdU0gUTcCFn3jgJNcdNdHxryP49NU/bBpoIm6PlBDZONt4ng+VL00IUy3wLgpRK3rED3JImtnX8eJWmm4L0HDJkAN9/OEqJH9q6njPUflpCmh5zQjkV8zIlFrLdB7CFlP+5N03d8CUdcAEvUBuHvUgU2iPgCcP300D4gONycQdY7jRK3izvGcqGvAiLowMLhLIerc8F9qkU7UuQaibmGBqGsAiToXWPQtAk5y0V0fGXOe49PU/mHTQBP1/kANkY23peP5UPXSkjDdAuOmELWuQ/Qki6ydwHGiVhoGBA1bAjUUnhA1sn9FHO85KicRQs+JksgvSiRqrQV6DyHrKUbSNWaBqKsDiTofN08Km0SdD86fPgoCosMFBKKOO07UKu6450RdHUbUBUmDuxSiToSaF6YTdcJA1IUWiLo6kKgTwKIvDDjJRXd9ZMwHOj5NxcKmgSbqGFBDZOM9yPF8qHo5iDDdAuOmELWuQ/Qki6ydgx0naqXhwQQNDwJqeIgnRI3sX4c63nNUTg4l9JzDSOR3GJGotRboPYSsp1YkXVtZIOpqQKI+HKZDzOqvZx0Ozp8+jgiIDh9BIOojHSdqFfeRnhN1NdyTyaz9etZRoeZHpxP1UQaiPtoCUVcDEvVRwKI/OuAkF931kTEf4/g01SpsGmiibgXUENl4WzueD1UvrQnTLTBuClHrOkRPssjaOdZxolYaHkvQsDVQw+M8IWpk/zre8Z6jcnI8oeecQCK/E4hErbVA7yFkPZ1I0vVEC0RdFUjUJ8F0KLN6j/okcP70cXJAdPhkAlGf4jhRq7hP8Zyoq+J+YMnaPeo2oeZt04m6jYGo21og6qpAom4DLPq2ASe56K6PjPlUx6epE8OmgSbqE4EaIhvvaY7nQ9XLaYTpFhg3hah1HaInWWTtnO44USsNTydoeBpQwzM8IWpk/zrT8Z6jcnImoee0I5FfOyJRay3QewhZT+1Jura3QNRVgER9FkyHZL5Noj4LnD99nB0QHT6bQNTnOE7UKu5zPCfqKrifTS02uEsh6g6h5uemE3UHA1Gfa4GoqwCJugOw6M8NOMlFd31kzOc5Pk21D5sGmqjbAzVENt7zHc+HqpfzCdMtMG4KUes6RE+yyNq5wHGiVhpeQNDwfKCGRZ4QNbJ/FTvec1ROigk9p4REfiVEotZaoPcQsp5KSbqWWiDqykCiLoPpUGj1U99l4PzpIxkQHU4SiLqj40St4u7oOVFXxn2P2tqnvjuFmndOJ+pOBqLubIGoKwOJuhOw6DsHnOSiuz4y5gsdn6ZKw6aBJupSoIbIxtvF8XyoeulCmG6BcVOIWtchepJF1s5FjhO10vAigoZdgBp29YSokf3rYsd7jsrJxYSe041Eft2IRK21QO8hZD11J+na3QJRVwIS9SW4e9RWn/V9CTh/+rg0IDp8KYGoL3OcqFXcl3lO1JVwn/oODO5SiLpH+C/1TCfqHgai7mmBqCsBiboHsOh7Bpzkors+MubLHZ+muodNA03U3YEaIhtvL8fzoeqlF2G6BcZNIWpdh+hJFlk7VzhO1ErDKwga9gJqeKUnRI3sX1c53nNUTq4i9JzeJPLrTSRqrQV6DyHrqQ9J1z6hrjbpcreW2Fj0cXVAdPhqAl1e4zhdqrivIdClyVfEBrmGsImBG4+eb1c1RMZ9rSfDRB9gzNc5PkyoWK8lDBN9HR++VV76kntOphr2Iw0O/f6DwWFX0uBwfUB0+HrC4HCD44ODivsGTwYHVcg3EDYxcOPR8+2qhsi4b/RkcOgHjPkmxwcHFeuNhMHhZscHB5WXm8k9J1MN+5MGh/4B/x5+ReA9/FuAe8jmsHRLwBmWbg2IDt9KGJYGOD4sqbgHWBqWgswO0T/0FX3rsD8wR8h8D3T8Aqoa3UDCBfQ2xy+gKubbCHEPIl30Bhk+AoLWhJ0zxB4fQBh6kPv9dsfrXml4O0HDgUAN7/AEtJDXnDsdv06onNxJ6Jd3kfrlXcTbvVoL9B5C1tPdpD2E1vJu8GytD/ReLwcEwntSYhaJaCQSj6q/lygNRKy0JJKIREqLY0FJUFQSKSuMicJkLBKLlpSWFMtzFolkkCwqKUwm/jqXTSC8hwSE9wZEh+8lAOF9jgOhivs+AhCqYlNWvhy/2Mq15DSwdE0y3YCphTw49Z0p9JXyPuCEkHqlHPwvV8ot+FyyBXH+3CiDt+NKuSXRBwM34P2kCUSd97rtrAUhtSsRQTIojARFQbykIF5cWBopThQlo8n8aGl0e3XdUrEjdX2ApOsD26/r/xf1+iBJ1wf/j9frQyRdHwp11RdOG5Ma8uKZerF/OLyUPqKuGYwL3GDCtDbY8be1tndzBNsQd6Y+Pur421qqMB8lvD0xhNQUhvxLsw0yO8QjJC0eI2nxGFEL1QgZWpRr63ZPYe2HHf7buEu24B+t9suD49YH+lu8wLoUwFwLpH5qkNq5nPldiHLbqOeW6in1nIxrFkqT1KHy8X97FyLI7BCPki4Cj2//+/ViS/+O8vlxQlPYmdQUKmxjzrZleMs05icCNxsMMhepdflEynCyvfnZkubI/DyZem8hGpV7ozQukqXJaH68MFIsCqIFBclYMl6QiJUm82NFpfEyESuKRgrL4kFSJMrK4vnRknhBsrC0pCCZ2rRFaTQaKy0sLhH5kYKi4iBRGi0KkrF4VAJ/aTReWhpNFBQURaOlBYlkolBCukT/RJAfjxcGBZFoYYSVnydT6Bp1UdjSuzmp5/TlovCUjxeFp8gXhacIF4WKjlwU/rGI438+pCWJbDpPO3pRqEhqOk8DLgpbemsTmZ9nHL0osPLzzP9Hb7k+G3aB50xvuQaZHf94vwN5rzLTcwHfvqV8MkpriP5EM0vDTM/1vOP5UBvmecKF/QXSkPMC8e3P50haDCVpMZT8VjBDi90cfyuYtR8qOf5WMKv2K3vyVjCwLgUw16Jy9q3g9OPPaxZKk9Rh90Um9T9Pugi8SKR+5fOLhKZQ3ZO3gp8HDoIvBW42mOokqnzJwlvByPy8DKT+ykDqZ+XnZUN+tvUzNVt66xeZn2Gk/jkMoMOW3p1C6jCcpMNwz+phBEmHEZ7VwyskHV7ZiltFLg92BndhdZw6NL7q49D4KnlofJUwNNa0NDRm+Kl4aJN7DXgu5NBYkzSUvLYVQ2Omn65H5uf1ADfoIYdGVn5eB1wct3CIZsDvjr4B658Jygex7wvfdUPfUULW+JuO38FQOX6TcL15i3TtVeetGP73zeU2P1D/pj4fWu925d338W30IOlL0dZ2/PaKivltQtx1HHlHcQvHJoWZaczvABszsG4EMhfkJvm/2xT/F5vkO/9Xm+S7AbdJBpkdQsX8LiHu90gTzXvB309bY3zd0zQhB5kdAjkhv+94PSmiep9QTx94sI8+IMT9IWkfffgv+yjI7KD1lD3a/t+sgT0tfa4lUz8/Ag6JwFyLPUnvUH2UpWu6jx+zB0cEZX5M2PT1PaHMjz3Y9JnmooEnDfgTYC6A9ScaZCndi2b7CbLZ+npVbF3JfR8/zSYqEOd6sKM+yyYqEMd7sKM+zyYqECd6kKgvsokKxMkeJOrLbKIC0caDRH2VTVQgTvUgUSOziQrE6R4k6utsogJxpgeJGpVNVCDae5Cob7KJCsTZHiRqdDZRgejgQaLGZBMViPM8SNTYbKICcYEHiRqXTVQgXvTgTdnx2UQFosSDHTUhm6hAlHmQqInZRAWioweJmpRNVCA6e5CoydlEBaKLB4makk1UILp6kKip2UQFopsHiZqWTVQgLvEgUdOziQrEZR4kakY2UYHo6UGiZmYTFYheHiRqVjZRgbjSg0TNziYqEL09SNScbKICcbUHiZqbTVQgrvUgUfOyiQpEXw8SNR+ZKPUMzV3K/f3dMuVs47SklQcHAHzIhUB/0Z+RsE898PEzD3z83AMfv/DAxy898PErD3wc6YGPX3vg4ygPfPzGAx9He+DjGA98HOuBj+M88HG8Bz5O8MDHiR74OMkDHyd74OMUD3yc6oGP0zzwcboHPs7wwMeZHvg4ywMfZ3vg4xwPfJzrgY/zPPBxPsHHclAfo/FyhgNz7ojgnfvvXybfIeWcC6RKC6UtkrZY2hJpS6Utk7Zc2gppK6WtkrZa2rfS1khbK22dtO+kfS/tB2k/SvtJ2s/S1kv7Rdqv0n6T9ru0DdI2SvtDZUZGuoO08tJ2lFZB2k7Sdpa2i7SK0naVtpu0StIqS6siraq0atKqS6shraa0WtJqS6sjbXdpdaXtIW1PaXtJqyetvrQG0vaW1lBaI2mNQ7X3EaEo+qmNSpSKaWsLDWuLDGuLDWtLDGtLDWvLDGvLDWsrDGsrDWurDGurDWvfGtbWGNbWGtbWGda+M6x9b1j7wbD2o2HtJ8Paz4a19Ya1XwxrvxrWfjOs/W5Y22BY22hY+8Owpoo+fW0Hw9qOhrUKhrWdDGs7G9Z2MaxVNKztaljbzbBWybBW2bBWxbBW1bBWzbBW3bBWw7BW07BWy7BW27BWx7C2u2GtrmFtD8Panoa1vQxr9Qxr9Q1rDQxrexvWGhrWGhnWGhvWVPNrVG7TA/3QydSbfw495VssIA0b5cH6AW8mioWexAy8OSkWeRIz8GanWOxJzMCbp2KJJzEDb8aKpZ7EDLy5K5Z5EjPwZrFY7knMwJvPYoUnMQNvZouVnsQMvDkuVnkSM/Bmu1jtSczAm/fiW09iBn4YQKzxJGbghwvEWk9iBn5YQazzJGbghx/Ed57EDPwwhfjek5iBH84QP3gSM/DDHuJHT2IGfnhE/ORJzMAPo4ifPYkZ+OEWsd6TmIEflhG/eBIz8MM34ldPYgZ+mEf85knMwA8Hid89iRn4YSOxwZOYgR9eEhs9iRn4YSjxhycxAz9cJdTnBHyIGfhhLbEDKeYd0mIOMjtEeZG5fmVJdZQUqS/iVkzJyw4pfrL8Z9zzRvuY/fIsxsfsl2cxPma/PIvxMfvlWYyP2S/PYnzMfnkW42P2y7MYH7NfnsX4mP3yLMbH7JdnMT5mvzyL8TH75VmMj9kvz2J8zH55FuNj9suzGB99/PIs5rwJmqYVhPt538kDH3f2wMddPPCxogc+7uqBj7t54GMlD3ys7IGPVTzwsaoHPlbzwMfqHvhYwwMfa3rgYy0PfKztgY91PPBxdw98rOuBj3t44OOeHvi4lwc+1vPAx/oe+NjAAx/39sDHhh742MgDHxuTPitZDupnJGL6XGMT6fu+0vaT1lRaM2n7SztAWnNpOdJypbWQlietpbRAmpCmHo8XlRaTli+tQFpcWkJaobQDpR0k7WBph0g7VNphSitph0s7QtqR0o6SdrS0Y6S1lnastOOkHS/tBGknSjtJ2snSTpHWRlpbaadKO03a6dLOkHamtHbS2ks7S9rZ0s6R1kHaudLOk3a+tAukFUkrFn9pUCLKbfoQpiaGBzPta1jbz7DW1LDWzLC2v2HtAMNac8NajmEt17DWwrCWZ1hraVgLDGvCsBYxrEUNazHDWr5hrcCwFjesJQxrhYa1Aw1rBxnWDjasHWJYO9SwdphhrZVh7XDD2hGGtaMNa8cY1lob1o41rB1nWDvesHaCYe1Ew9pJhrWTDWunGNbaGNbaGtZONaydZlg73bB2hmHtTMNaO8Nae8PaWYa1sw1r5xjWOhjWzjWsnWdYO9+wdoFhrciwVmxYU42uUblND31RaBX+memXEIAfaBdNSBdWdMzIB8Lt60nMyAfC7edJzMgHwjX1JGbkA+GaeRIz8oFw+3sSM/KBcAd4EjPygXDNPYkZ+UC4HE9iRj4QLteTmJEPhGvhSczIB8LleRIz8oFwLT2JGflAuMCTmMcBYxaexIx8IFzEk5iRD4SLehIz8oFwMU9iRj4QLt+TmJEPhCvwJGbkA+HinsSMfCBcwpOYkQ+EK/QkZuQD4Q70JGbkA+EO8iRm5APhDvYkZuQD4Q7xJGbkA+EO9SRm5APhDvMkZuQD4Vp5EjPygXCHexIz8oFwR5Bi3iEt5iCzQxwpMtdPPxCO6edRMD8TgllDwC9ciqM92TfAL3CKYzyJGfiFUNHak5iBXzAVx3oSM/ALq+I4T2IGfgFWHO9JzMAv1IoTPIkZ+AVdcaInMQO/8CtO8iRm4BeIxcmexAz8QrI4xZOYgV9wFm08iRn4hWnR1pOYgV/AFqd6EjPwC93iNE9iBn5BXJzuSczAL5yLMzyJGfgFdnGmJzEDvxAv2nkSM/AL9qK9JzEDv7AvzvIkZuADAMTZnsQMfKCAOMeTmIEPKBAdPIkZ+MADca4nMQMfoCDO8yRm4AMZxPmexAx8wIO4wJOYgQ+MEEWexAx8AIUoBsasflBr13J/ff9YHTukxFwuZS1ViyCzI/uDWiAfsz+ohfEx+4NaGB+zP6iF8TH7g1oYH7M/qIXxMfuDWhgfx3ngY/YHtTA+Zn9QC+Nj9ge1MD5mf1AL42P2B7UwPmZ/UAvjY/YHtTA+Zn9QC+Nj9ge18Jpmf1AL42P2B7UwPmZ/UAvjY/YHtTA+Zn9QC+Nj9ge1MD5mf1AL42P2B7UwPmZ/UAvjY/YHtTA+Zn9QC+Nj9ge1MD5mf1AL42P2B7UwPmZ/UAt17kiEeG6xQ4q2+pylUpcyaUlpHaV1ktZZ2oXSuki7SFpXaRdL6yatu7RLpF0q7TJpPaT1lHa5tF7SrpB2pbSrpPWW1kfa1dKukXattOuk9ZXWT9r10m6QdqO0m6TdLK2/tFuk3SptgLSB0m6TNkja7dLukHantLuk3S3tHmn3SrtP2mBp90t7QNqD0h6S9rC0R6Q9Km2ItMekPS7tCWlPinKb/piNEiP9B27KDGtJw1pHw1onw1pnw9qFhrUuhrWLDGtdDWsXG9a6Gda6G9YuMaxdali7zLDWw7DW07B2uWGtl2HtCsPalYa1qwxrvQ1rfQxrVxvWrjGsXWtYu86w1tew1s+wdr1h7WHD2iOGtUcNa0MMa48Z1h43rD1hWHsyXEs9yod/tgr/dOmHnUpJDR4dM/KHnco8iRn5w05JT2JG/rBTR09iRv6wUydPYkb+sFNnT2JG/rDThZ7EjPxhpy6exIz8YaeLPIkZ+cNOXT2JGfnDThd7EjPyh526eRIz8oedunsSM/KHnS7xJOZxwJgv9SRm5A87XeZJzMgfdurhSczIH3bq6UnMyB92utyTmJE/7NTLk5iRP+x0hScxI3/Y6UpPYkb+sNNVnsSM/GGn3p7EjPxhpz6exIz8YaerPYkZ+cNO13gSM/KHna71JGbkDztd50nMyB926utJzMgfdurnSczIH3a6nhQz+kNBN4jM9bPxw043wvzc9Ied0H7e5Eneb/bEz/6e+HmLJ37e6omfAzzxc6Anft7miZ+DPPHzdk/8vMMTP+/0xM+7PPHzbk/8vMcTP+/1xM/7PPFzsCd+3u+Jnw944ueDnvj5EMnPCpn6KTb9z4cz83OTsz2SacwpZ3sUwOv/e/h8W0dzEWwa9RBEzYRnewxTf3+e7XFgLhq7nYtAR/0Ebv+KJ4HnAtaySM1FRu+JlSUL1Y8KVCn393uqlNyQazvI5HC3Zhhftvxfz0rN91PhO6NPp38pUP2POWlr6i81KpctlEwb6r4+NNS0gt7OmCNhzOIpoH5PAzctKxflwblA6veM4VzFQUlpviguKI2LsqL8RElJYVSISFFBUUFxJJEsK84XifyEPGdJUSQh/7lIUYkoC4oKytRFpHK5v4fx1AM9oD8DbLCp/j4riA6rk6PP+xywGFhxPyf+Fhh0XqOviGaifEVtWH1eZI6eBxe+vqCr8zaWf9qcBB8GXuAfAV7gHwVeVIYIzkUFtJ+Mk+AL4X4dmj4JvmCYBIcyJ8HQySHA6eMF4GYcmnKuSGl+WVCYKE5Eioui8eJYtLiwsEiet0CIRLI0EpTGIsl8UVBQUlhWmBTRZHF+WVFBflFhQemfV8/SRp5MH0j9XvR0+niRNH28JIgOv0SYPl52fPpQcb/syfQxNPQVPX0gczSMNH0M+w+mD9BnWf88G+wzogL72Uvmw/0BuTBOH8PD/ToiffoYbpg+Rlh4H8qHQsl0Yzf15H2o+QFuEhwObIwjgMjQ1JNJEKnfK55Ogq+QJsFXBdHhVwmT4GuOT4Iq7tc8mQRHhL6iJ0Fkjl4nTYKv/weT4AzgBX4m8AKP/FbdbA8nwTfC/fpm+iT4hmESfNPCJOhDoWS6sff3ZBKcDZwE3wA2xjeBk+D+nkyCSP3e8nQSfIs0Cb4tiA6/TZgE33F8ElRxv+PJJPhm6Ct6EkTm6F3SJPjufzAJTgFe4KcCL/DI56VM93ASfC/cr++nT4LvGSbB9y1Mgj4USqYbu7knk+B04CT4HrAxvg+cBJt7Mgki9fvA00nwA9Ik+KEgOvwhYRL8yPFJUMX9kSeT4Puhr+hJEJmjj0mT4Mf/wSQ4AXiBnwi8wCOfhDnZw0nwk3C/fpo+CX5imAQ/tTAJ+lAomW7sXE8mwcnASfATYGP8FDgJ5noyCSL1+8zTSfAz0iT4uSA6/DlhEvzC8UlQxf2FJ5Pgp6Gv6EkQmaMvSZPgl//BJDgGeIEfC7zAjwNOguM9nAS/CvfryPRJ8CvDJDjSwiToQ6FkurHzPJkExwMnwa+AjXEkcBLM82QSROr3taeT4NekSXCUIDo8ijAJfuP4JKji/saTSXBk6Ct6EkTmaDRpEhz9H0yCXwMv8KOAF3jkr9eN9nASHBPu17Hpk+AYwyQ41sIk6EOhZLqxA08mwdHASXAMsDGOBU6CgSeTIFK/cZ5OguNIk+B4QXR4PGESnOD4JKjinuDJJDg29BU9CSJzNJE0CU78DybBL4AX+C+BF3jk75KP9HASnBTu18npk+AkwyQ42cIk6EOhZLqxI55MgiOBk+AkYGOcDJwEI55Mgkj9png6CU4hTYJTBdHhqYRJcJrjk6CKe5onk+Dk0Ff0JIjM0XTSJDjd5iQYXpQ/BV6UPwNOb58HuCFmgYeT4Ixwv85MnwRnGCbBmcxJ0KNCyXRjx1yfBA0FnekkOAPYGGcCJ8GYJ5MgUr9Znk6Cs0iT4GxBdHg2YRKc4/gkqOKe48kkODP0FT0JInM0lzQJzg0nQfW6brlNL/Kpb/2k3hBM/ZhY6pcHUr9SmvqgEfV6RMrrvpX/ft2u/Pa/HppyzqdTXvdLOf/1Ka9vSHl9Y8rrm1Je35zyun/K61vC1/PkvzNf2gJpC6UtkrZY2hJpS8XmkzR6Xy0F1oEeFpbJcy6XtkLaynAKTK0R9f8rltt0bblhbYVhbWW4lnqg365aCtxnywDn+uv3kwOxHOhXQVvOkLJjWi4yiVnlYgVEv7/yuhI45CH1Y+/xJYQ9vkqec7W0b6WtMezxVYa9u9qw9q1hbY2FPb4EuJdWAff4aqBfCU/2+LfAPb4GuMcTHu3xxYQ9vlaec52076R9b9jjaw17d51h7TvD2vcW9vhi4F5aC9zj64B+HejJHv8OuMe/B+7xAz3a44sIe/wHec4fpf0k7WfDHv/BsHd/NKz9ZFj72cIeXwTcSz8A9/iPQL8O9mSP/wTc4z8D9/jBHu3xhYQ9vl6e8xdpv0r7zbDH1xv27i+GtV8Na79Z2OMLgXtpPXCP/wL061BP9vivwD3+G3CPH+rRHl9A2OO/y3NukLZR2h+GPf67Ye9uMKxtNKz9YWGPLwDupd+Be3wD0K9WnuzxjcA9/gdwj7fyaI/PJ+zxchHpp7Ty0naMlNtsj6v/n753dzCslTes7Rjh7/H5wL2kYkXUu9rjO0Rwfh3hyR4vH8Ht8R0juBo5wqM9Po+wxytILXeStrO0XQx7vIJh7+5kWNvZsLaLhT0+D7jHKwD3+E7APX6UJ3t8Z+Ae3wW4x4/yaI/vgDtX0Cg8T0Wp5a7SdpNWSVplaVWkVZVWTVp1aTWk1ZRWS1ptaXWk7S6trrQ9pO0pbS9p9aTVl9ZA2t7SGkprJK2xtH2kNZG2r7T9pDWV1szQUyoaesWuhrXdDGuVDGuVDWtVDGtVDWvVDGvVDWs1DGs1DWu1DGu1DWt1DGu7G9bqGtb2MKztaVjby7BWz7BW37DWwLC2t2GtoWGtkWGtsWFtH8NaE8Pavoa1/QxrTQ1rzSxcg1L3bKa9viLwGrQr8Bp0DOkalJ6LTK9BuwGvQZUyP9f/PjxcGZiL1i7nIvY/P0WVzGIOUmIWVTM5V2QT/UQ1YC6OdTMXQZqfovp2xlyQ3CxmUWP7zpUw6CdqAnNxnGu5SBj9FLW2Peb4P8Qsam/rueL/qJ+oA8zF8e7kIvIvfordtyXm+L/GLOpu/blKtqCf2AOYixNcyEV8i36KPbcu5mArYhZ7bc25gq3ST9QD5uLE/zYX+Vvpp6i/pZhjWx2zaPCv54olt0E/sTcwFyf9V7mIb5OfouE/x5zYxphFo384V2Fym/UTjYG5ONl+LoLt8FPsY4o52K6YRZPNzyW2Uz+xLzAXp9jMRel2+yn22zTmaAYxi6Yp54okM9JPNAPmoo2lXASZHQL4/oAA8q1I5bNMc9HWk1wAOUgA53hxAjAXp3qSC+C8J4DzijgZmIvTPMkF8LomgH1ZtAXm4nRL9wqDzA4B3L8CWH+CpV/5NP0yzTNyxtgfdq81Gth8mALO700fpnBAhOiwOjn6vM2BxcCKu3nkb4FB5w3+7fFP6BiawYqtlPFopNDLTT+gkBNqnhvehP/fXdGcsAhT13INd0rRXR/RtfTdzRxg0eeCk8vY4DmGxpFp3DkRP652TYG5bgGLuSBm82rXgnS1y4sQHc4jXO1aOn61U3G39Pxq1xRWbIUlBncpV7sg1FykX+0Cw9VOWLjaNQVe7QJg0QtSctFdHxlzBNc91bed4Ffi5mHTKA+uQSQaRMHTArppqRxHCVOS63Hr2kHHHfNkOkTWeD65TwSZHULlJJ/QJ6JADQs82C8FhP0SB0/oelaJp/jK0gJdT/nAekqQdE1ENic3dG/aD6hDIUyHmNWH3haC86ePAyNEhw8kkOtBjpOrivsgz8l1P1ixFUcM7lLI9eDwXzoknVwPNpDrIRbIFdG1NLkeDCz6Q0jJRXd9ZMyHOj6RJsKmgfo2qemqn+m5kI33MMfzoerlMMJ0C4yb8hR0XYfoSRZZO60cJ6M/9xxBw8OAGh7uybsSyP51hOM9R+XkCELPOZJEfkcSiVprgd5DyHo6iqTrURaIGvlJ96NhOsQjNon6aHD+9HFMhOjwMQSibu04Uau4W3tO1PvCii1RZnCXQtTHhpofl07UxxqI+jgLRI3oWpqojwUW/XGk5KK7PjLm4x2fpo4KmwaaqI8CaohsvCc4ng9VLycQpltg3BSi1nWInmSRtXOi40StNDyRoOEJQA1P8oSokf3rZMd7jsrJyYSecwqJ/E4hErXWAr2HkPXUhqRrGwtE3QSoQ1uYDmXCJlG3BedPH6dGiA6fSiDq0xwnahX3aZ4TdRNYsYmkwV0KUZ8ean5GOlGfbiDqMywQNaJraaI+HVj0Z5CSi+76yJjPdHyaahM2DTRRtwFqiGy87RzPh6qXdoTpFhg3hah1HaInWWTttHecqJWG7QkatgNqeJYnRI3sX2c73nNUTs4m9JxzSOR3DpGotRboPYSspw4kXTtYIOp9gDqcC9MhapWozwXnTx/nRYgOn0cg6vMdJ2oV9/meE/U+sGIrsUbUF4SaF6UT9QUGoi6yQNSIrqWJ+gJg0ReRkovu+siYix2fpjqETQNN1B2AGiIbb4nj+VD1UkKYboFxU4ha1yF6kkXWTqnjRK00LCVoWALUsMwTokb2r6TjPUflJEnoOR1J5NeRSNRaC/QeQtZTJ5KunSwQNfJZ851hOhRZfd5lZ3D+9HFhhOjwhQSi7uI4Uau4u3hO1I1hxVZg7XmXF4Wad00n6osMRN3VAlEjupYm6ouARd+VlFx010fGfLHj01SnsGmgiboTUENk4+3meD5UvXQjTLfAuClEresQPckia6e740StNOxO0LAbUMNLPCFqZP+61PGeo3JyKaHnXEYiv8uIRK21QO8hZD31IOnawwJRNwLq0BOmQ6TQJlH3BOdPH5dHiA5fTiDqXo4TtYq7l+dE3QhWbKVxg7sUor4i1PzKdKK+wkDUV1ogakTX0kR9BbDoryQlF931kTFf5fg01SNsGmii7gHUENl4ezueD1UvvQnTLTBuClHrOkRPssja6eM4USsN+xA07A3U8GpPiBrZv65xvOeonFxD6DnXksjvWiJRay3QewhZT9eRdL3OAlE3BOrQF6ZDccImUfcF508f/SJEh/sRiPp6x4laxX2950TdEFZssYTBXQpR3xBqfmM6Ud9gIOobLRA1omtpor4BWPQ3kpKL7vrImG9yfJq6LmwaaKK+DqghsvHe7Hg+VL3cTJhugXFTiFrXIXqSRdZOf8eJWmnYn6DhzUANb/GEqJH961bHe47Kya2EnjOARH4DiESttUDvIWQ9DSTpOtACUe8N1OE2mA75Vj/1fRs4f/oYFCE6PIhA1Lc7TtQq7ts9J+q9cW87WfvU9x2h5nemE/UdBqK+0wJRI7qWJuo7gEV/Jym56K6PjPkux6epgWHTQBP1QKCGyMZ7t+P5UPVyN2G6BcZNIWpdh+hJFlk79zhO1ErDewga3g3U8F5PiBrZv+5zvOeonNxH6DmDSeQ3mEjUWgv0HkLW0/0kXe+3QNQNgDo8gLtDk2+TqB8A508fD0aIDj9IIOqHHCdqFfdDnhN1Axx0FRvcpRD1w6Hmj6QT9cMGon7EAlEjupYm6oeBRf8IKbnoro+M+VHHp6n7w6aBJur7gRoiG+8Qx/Oh6mUIYboFxk0hal2H6EkWWTuPOU7USsPHCBoOAWr4uCdEjexfTzjec1ROniD0nCdJ5Pckkai1Fug9hKynp0i6PmWBqOsDdXgaN08W2CTqp8H508czEaLDzxCI+lnHiVrF/aznRF0f97ZTkcFdClE/F2r+fDpRP2cg6uctEDWia2mifg5Y9M+Tkovu+siYX3B8mnoqbBpoon4KqCGy8Q51PB+qXoYSpltg3BSi1nWInmSRtfOi40StNHyRoOFQoIYveULUyP71suM9R+XkZULPGUYiv2FEotZaoPcQsp6Gk3QdboGo6wF1GAHTIWH117NGgPOnj1ciRIdfIRD1q44TtYr7Vc+Juh6s2OLWfj3rtVDz19OJ+jUDUb9ugagRXUsT9WvAon+dlFx010fG/Ibj09TwsGmgiXo4UENk433T8XyoenmTMN0C46YQta5D9CSLrJ23HCdqpeFbBA3fBGr4tidEjexf7zjec1RO3iH0nHdJ5Pcukai1Fug9hKyn90i6vmeBqPcC6vC+p0T9Pjh/+vggQnT4AwJRf+g4Uau4P/ScqPfykKg/CjX/OJ2oPzIQ9ccWiBrRtTRRfwQs+o89IWpkzJ84Pk29FzYNNFG/B9QQ2Xg/dTwfql4+JUy3wLgpRK3rED3JImvnM8eJWmn4GUHDT4Eafu4JUSP71xeO9xyVky8IPedLEvl9SSRqrQV6DyHr6SuSrl9ZIOo9gTqMhOmQb/VZ3yPB+dPH1xGiw18TiHqU40St4h7lOVHvCSu2ImvP+v4m1Hx0OlF/YyDq0RaIGtG1NFF/Ayz60aTkors+MuYxjk9TX4VNA03UXwE1RDbesY7nQ9XLWMJ0C4ybQtS6DtGTLLJ2xjlO1ErDcQQNxwI1HO8JUSP71wTHe47KyQRCz5lIIr+JRKLWWqD3ELKeJpF0nWSBqPcA6jAZR9SlNol6Mjh/+pgSITo8hUDUUx0nahX3VM+Jeg8cdEUN7lKIelqo+fR0op5mIOrpFoga0bU0UU8DFv10UnLRXR8Z8wzHp6lJYdNAE/UkoIbIxjvT8XyoeplJmG6BcVOIWtchepJF1s4sx4laaTiLoOFMoIazPSFqZP+a43jPUTmZQ+g5c0nkN5dI1FoL9B5C1tM8kq7zLBB1XaAO82E6RKzeo54Pzp8+FkSIDi8gEPVCx4laxb3Qc6KuCyu2Umv3qBeFmi9OJ+pFBqJebIGoEV1LE/UiYNEvJiUX3fWRMS9xfJqaFzYNNFHPA2qIbLxLHc+HqpelhOkWGDeFqHUdoidZZO0sc5yolYbLCBouBWq43BOiRvavFY73HJWTFYSes5JEfiuJRK21QO8hZD2tIum6ygJR7w7UYTVMh2jUJlGvBudPH99GiA5/SyDqNY4TtYp7jedEvTus2EpKDe5SiHptqPm6dKJeayDqdRaIGtG1NFGvBRb9OlJy0V0fGfN3jk9Tq8KmgSbqVUANkY33e8fzoerle8J0C4ybQtS6DtGTLLJ2fnCcqJWGPxA0/B6o4Y+eEDWyf/3keM9ROfmJ0HN+JpHfz0Si1lqg9xCyntaTdF1vgajrAHX4BaZDmdV71L+A86ePXyNEh38lEPVvjhO1ivs3z4m6DqzYhLV71L+Hmm9IJ+rfDUS9wQJRI7qWJurfgUW/gZRcdNdHxrzR8Wlqfdg00ES9HqghsvH+4Xg+VL38QZhugXFTiFrXIXqShV60o24TtdJQ+YjW8A+ghjuANdQH+hqA7F/lo273HJUT5SN6T+8IzHXqDLVjlEfUWgv0HkLWUwWSrhWifKKuDdRhJ5gOMatEvRM4f/rYOUp0eOco/ry7RN0mahX3LilfMAWd1ypR14YNfsXWiLpiqPmu0XKb0nPF6OZErf4Sm6hrA4m6IrDod41ykovu+siYd3N8mqoQNg00UVcAaohsvJUcz4eql0qE6bYSmGTQ/uk6RE+yyNqp7DhRKw0rEzSsBNSwiidEjexfVR3vOSonVQk9pxqJ/KoRiVprgd5DyHqqTtK1ugWirgUk6howHeKFNom6Bjh/+qgZJTpck0DUtRwnahV3Lc+JuhaMqBNxg7sUoq4dal4nnahrG4i6jgWirgUk6trAoq8T5SQX/j4qMObdHZ+mqodNA03U1YEaIhtvXcfzoeqlLmG6BcZNIWpdh+hJFlk7ezhO1ErDPQga1gVquKcnRI3sX3s53nNUTvYi9Jx6JPKrRyRqrQV6DyHrqT5J1/oWiLomkKgb4O7QWCXqBuD86WPvKNHhvQlE3dBxolZxN/ScqGvCiDpmjagbhZo3TifqRgaibmyBqGsCiboRsOgbRznJRXd9ZMz7OD5N1Q+bBpqo6wM1RDbeJo7nQ9VLE8J0C4ybQtS6DtGTLLJ29nWcqJWG+xI0bALUcD9PiBrZv5o63nNUTpoSek4zEvk1IxK11gK9h5D1tD9J1/0tEHUNIFEfgLtHHdgk6gPA+dNH8yjR4eYEos5xnKhV3DmeE3UNGFEXBgZ3KUSdG2reIp2ocw1E3cICUdcAEnUusOhbRDnJRXd9ZMx5jk9T+4dNA03U+wM1RDbelo7nQ9VLS8J0C4ybQtS6DtGTLLJ2AseJWmkYEDRsCdRQeELUyP4VcbznqJxECD0nSiK/KJGotRboPYSspxhJ15gFoq4OJOp83DwpbBJ1Pjh/+iiIEh0uIBB13HGiVnHHPSfq6jCiLkga3KUQdSLUvDCdqBMGoi60QNTVgUSdABZ9YZSTXHTXR8Z8oOPTVCxsGmiijgE1RDbegxzPh6qXgwjTLTBuClHrOkRPssjaOdhxolYaHkzQ8CCghod4QtTI/nWo4z1H5eRQQs85jER+hxGJWmuB3kPIempF0rWVBaKuBiTqw3GfebT661mHg/OnjyOiRIePIBD1kY4TtYr7SM+JuhruyWTWfj3rqFDzo9OJ+igDUR9tgairAYn6KGDRHx3lJBfd9ZExH+P4NNUqbBpoom4F1BDZeFs7ng9VL60J0y0wbgpR6zpET7LI2jnWcaJWGh5L0LA1UMPjPCFqZP863vGeo3JyPKHnnEAivxOIRK21QO8hZD2dSNL1RAtEXRVI1CfBdCizeo/6JHD+9HFylOjwyQSiPsVxolZxn+I5UVfF/cCStXvUbULN26YTdRsDUbe1QNRVgUTdBlj0baOc5KK7PjLmUx2fpk4MmwaaqE8EaohsvKc5ng9VL6cRpltg3BSi1nWInmSRtXO640StNDydoOFpQA3P8ISokf3rTMd7jsrJmYSe045Efu2IRK21QO8hZD21J+na3gJRVwES9VkwHZL5Non6LHD+9HF2lOjw2QSiPsdxolZxn+M5UVfB/WxqscFdClF3CDU/N52oOxiI+lwLRF0FSNQdgEV/bpSTXHTXR8Z8nuPTVPuwaaCJuj1QQ2TjPd/xfKh6OZ8w3QLjphC1rkP0JIusnQscJ2ql4QUEDc8HaljkCVEj+1ex4z1H5aSY0HNKSORXQiRqrQV6DyHrqZSka6kFoq4MJOoymA6FVj/1XQbOnz6SUaLDSQJRd3ScqFXcHT0n6sq471Fb+9R3p1DzzulE3clA1J0tEHVlIFF3AhZ95ygnueiuj4z5QsenqdKwaaCJuhSoIbLxdnE8H6peuhCmW2DcFKLWdYieZJG1c5HjRK00vIigYReghl09IWpk/7rY8Z6jcnIxoed0I5FfNyJRay3QewhZT91Juna3QNSVgER9Ce4etdVnfV8Czp8+Lo0SHb6UQNSXOU7UKu7LPCfqSrhPfVt71nePUPOe6UTdw0DUPS0QdSUgUfcAFn3PKCe56K6PjPlyx6ep7mHTQBN1d6CGyMbby/F8qHrpRZhugXFTiFrXIXqSRdbOFY4TtdLwCoKGvYAaXukJUSP711WO9xyVk6sIPac3ifx6E4laa4HeQ8h66kPStU+oq0263C2CjUUfV0eJDl9NoMtrHKdLFfc1BLo0+YrYINcQNjFw49Hz7aqGyLiv9WSY6AOM+TrHhwkV67WEYaKv48O3yktfcs/JVMN+pMGh338wOOxKGhyujxIdvp4wONzg+OCg4r7Bk8FBFfINhE0M3Hj0fLuqITLuGz0ZHPoBY77J8cFBxXojYXC42fHBQeXlZnLPyVTD/qTBob+Fe/gVgffwbwHuIZvD0i1RzrB0a5To8K2EYWmA48OSinuApWEpyOwQ/UNf0bcO+wNzhMz3QMcvoKrRDSRcQG9z/AKqYr6NEPcg0kVvkOEjIGhN2DlD7PEBhKEHud9vd7zulYa3EzQcCNTwDk9AC3nNudPx64TKyZ2EfnkXqV/eRbzdq7VA7yFkPd1N2kNoLe8Gxqx9a5Tia7PIX9dN9bppyuv9Ul7vm/K6ScrrfVJeN0553SjldcOU13unvG6Q8rp+yut6Ka/3Snm9Z8rrPVJe1015vXvK6zopr2unvK6V8rpmyusaKa+rp7yulvK6asrrKimvK6e8rpTyereU17umvK6Y8vpn8ffrn1Je/5jy+oeU19+nvP4u5fW6lNdrU16vSXn9bcrr1SmvV6W8XpnyekXK6+Upr5elvN4lJZadU17vlPK6QsrrHVNel095vUPK63Ipr/9I+bc2przekPL695TXv6W8/jXl9S8pr9eHr/XGvUfusXul3SdtsLT7pT0g7UFpD0l7WNoj0h6VNkTaY9Iel/aEtCelPSXtaWnPSHtW2nPSnpf2grSh0l6U9pK0l6UNkzZc2ghpr0h7Vdpr0l6X9oa0N6W9Je1tae9Ie1fae9Lel/aBtA+lfSTtY2mfSPs07OOVyv3NjOq/L2om9Qpfd015fXGzUPuUv/tD3t///8fw9WfyvJ9L+yL61x0oW59V/4LUl8th/YykavFl+N7CV9FQEH2RVf9jQ5oD6M+lfwG4QPz1ufRk8kvgxeYrS0NqkNkhkDGPTDmXSEQjkXhU/b1EaSBipSWRRCRSWhwLSoKikkhZYUwUJmORWLSktKRYnrNIJINkUUlhMvGXXzbfyRxJeifz6yjR4a8J72SOcvydTBX3qOjfAoPOS3k34qvQV/R5vyER0TfRza9w6PwhmyLb18+AvjYKzzNannOMtLHSxkkbL22CtInSJkmbLG2KtKnSpkmbLm2GtJnSZkmbLW2OtLnS5kmbL22BtIXSFklbLG2JtKXSlklbLm2FtJXSVoVX59Scj46mTKbhn2MMa2MNa+MMa+MNaxMMaxMNa5MMa5MNa1MMa1MNa9MMa9MNazMMazMNa7MMa7MNa3MMa3MNa/MMa/MNawsMawsNa4sMa4sNa0sMa0sNa8sMa8sNaysMaysNa6uim79DXSH8s1X4Z5DZscmezbTPjoYNloEYA/SrtC1nsEzPRSYxq1yMhej3V17HZX6uSKifGA/MRZnLuYj9z08xIbOYg5SYxcRMzhXZRD8xCZiLpJu5CNL8FJO3M+aC5GYxiynbd66EQT8xFZiLjq7lImH0U0zb9pjj/xCzmL6t54r/o35iBjAXndzJReRf/BQztyXm+L/GLGZt/blKtqCfmA3MRWcXchHfop9iztbFHGxFzGLu1pwr2Cr9xDxgLi78b3ORv5V+ivlbijm21TGLBf96rlhyG/QTC4G56PJf5SK+TX6KRf8cc2IbYxaL/+Fchclt1k8sAebiIvu5CLbDT7HUFHOwXTGLZZufS2ynfmI5MBddbeaidLv9FCs2jTmaQcxiZcq5IsmM9BOrgLm42FIugswOAXx/QAD5VqTyWcaPVfQkF0AOEsA5XnQG5qK7J7kAznsCOK+Ii4C5uMSTXACvawLYl0U3YC4uJeUC/QEK4P4VwPoTSP1U/Q6W1ig836rwntiK8B7ZsvCe2ZLwHtqi8J7agvAe27zwntuc8B7crPCe3IzwHt208J7dlPAe3qTwnt6E8B7fuPCen7oPoO4rpB/oTx4j557VUVQeolYfMYvze9MPdXwbJTqsTo4+7xpgMbDiXpOyKUDntfqI2VWwYiu19ojZtaHm68IPBvzvTu3asAhT19ZF+Y+YRXQtfcd1LbDo14GTy9jga6P4TxqtjXImGPTVbiUw19/BYi6I2bzafUe62n0fJTr8PeFq94PjVzsV9w+eX+1WwoqtsMTgLuVq92Oo+U/pV7sfDVe7nyxc7VYCr3Y/Aov+J1Jy0V0fGfPPuO5p/HZlpv6tCZtGeXANItFgPXhaQDctleP1hCnJ9bh17aDj/sWT6RBZ47+S+0SQ2SFUTn4l9In1QA1/82C//EbYL7+DJ3Q9q/ye4itLC3Q9/Qqspw0kXTdENyc3dG9aAdRhI0yHWJlNct0Izp8+/ogSHf6DQK7lYm6Tq4pb+VgOe16r5LoCVmzFEYO7FHLdIdS8fKzcppSq/kc6uaq/xCZXRNfS5LoDsOjLxzjJRXd9ZMw7xoANqBx+w20Imwb6eX4bkG/zAfNRwfF8qHqpEMNPt8C4Kd/G1nWInmSRtbMTWcMgs+PPvbwTQcMKQA13BmuoD/Q1ANm/dnG856ic7ELoORWBuU6doSrGeESttUDvIWQ97UrSddcYn6iRn77fDaZDPGL158/A+dNHpRjR4Uox/HkrO07UKu7KnhP1chhRJ8oM7lKIukqoedV0oq5iIOqqFoh6OZCoqwCLvmqMk1x010fGXM3xaWrXsGmgiXpXoIbIxlvd8XyoeqlOmG6rg0kG7Z+uQ/Qki6ydGo4TtdKwBkHD6kANa3pC1Mj+VcvxnqNyUovQc2qTyK82kai1Fug9hKynOiRd61gg6mVAot4dpkOZ1QfE7g7Onz7qxogO1yUQ9R6OE7WKew/PiXoZjKhF0uAuhaj3DDXfK52o9zQQ9V4WiHoZkKj3BBb9XjFOctFdHxlzPcenqTph00ATdR2ghsjGW9/xfKh6qU+YboFxU4ha1yF6kkXWTgPHiVpp2ICgYX2ghnt7QtTI/tXQ8Z6jctKQ0HMakcivEZGotRboPYSsp8YkXRtbIOqlQKLeB6ZD1CpR7wPOnz6axIgONyEQ9b6OE7WKe1/PiXopjKhLrBH1fqHmTdOJej8DUTe1QNRLgUS9H7Dom8Y4yUV3fWTMzRyfphqHTQNN1I2BGiIb7/6O50PVy/6E6RYYN4WodR2iJ1lk7RzgOFErDQ8gaLg/UMPmnhA1sn/lON5zVE5yCD0nl0R+uUSi1lqg9xCynlqQdG1hgaiRz7/Pg+lQZPV5l3ng/OmjZYzocEsCUQeOE7WKO/CcqJfgHpNn7XmXItQ8kk7UwkDUEQtEvQRI1AJY9JEYJ7noro+MOer4NNUibBpoom4B1BDZeGOO50PVS4ww3QLjphC1rkP0JIusnXzHiVppmE/QMAbUsMATokb2r7jjPUflJE7oOQkS+SWIRK21QO8hZD0VknQttEDUi4FEfSBMh0ihTaI+EJw/fRwUIzp8EIGoD3acqFXcB3tO1ItxPzIQN7hLIepDQs0PTSfqQwxEfagFol4MJOpDgEV/aIyTXHTXR8Z8mOPTVGHYNNBEXQjUENl4Wzmejz/rhTDdAuOmELWuQ/Qki6ydwx0naqXh4QQNWwE1PMITokb2ryMd7zkqJ0cSes5RJPI7ikjUWgv0HkLW09EkXY+2QNSLgER9DEyH4oRNoj4GnD99tI4RHW5NIOpjHSdqFfexnhP1ItwD8RMGdylEfVyo+fHpRH2cgaiPt0DUi4BEfRyw6I+PcZKL7vrImE9wfJo6OmwaaKI+GqghsvGe6Hg+VL2cSJhugXFTiFrXIXqSRdbOSY4TtdLwJIKGJwI1PNkTokb2r1Mc7zkqJ6cQek4bEvm1IRK11gK9h5D11Jaka1sLRL0QSNSnwnTIt/qp71PB+dPHaTGiw6cRiPp0x4laxX2650S9EPfrWdY+9X1GqPmZ6UR9hoGoz7RA1AuBRH0GsOjPjHGSi+76yJjbOT5NtQ2bBpqo2wI1RDbe9o7nQ9VLe8J0C4ybQtS6DtGTLLJ2znKcqJWGZxE0bA/U8GxPiBrZv85xvOeonJxD6DkdSOTXgUjUWgv0HkLW07kkXc+1QNQLgER9Hu4OTb5Noj4PnD99nB8jOnw+gagvcJyoVdwXeE7UC3BEXWxwl0LURaHmxelEXWQg6mILRL0ASNRFwKIvjnGSi+76yJhLHJ+mzg2bBpqozwVqiGy8pY7nQ9VLKWG6BcZNIWpdh+hJFlk7ZY4TtdKwjKBhKVDDpCdEjexfHR3vOSonHQk9pxOJ/DoRiVprgd5DyHrqTNK1swWing8k6gtx82SBTaK+EJw/fXSJER3uQiDqixwnahX3RZ4T9Xzcp76LDO5SiLprqPnF6UTd1UDUF1sg6vlAou4KLPqLY5zkors+MuZujk9TncOmgSbqzkANkY23u+P5UPXSnTDdAuOmELWuQ/Qki6ydSxwnaqXhJQQNuwM1vNQTokb2r8sc7zkqJ5cRek4PEvn1IBK11gK9h5D11JOka08LRD0PSNSXw3RIWP31rMvB+dNHrxjR4V4Eor7CcaJWcV/hOVHPgxF13NqvZ10Zan5VOlFfaSDqqywQ9TwgUV8JLPqrYpzkors+Mubejk9TPcOmgSbqnkANkY23j+P5UPXShzDdAuOmELWuQ/Qki6ydqx0naqXh1QQN+wA1vMYTokb2r2sd7zkqJ9cSes51JPK7jkjUWgv0HkLWU1+Srn0tEPVcIFH385So+4Hzp4/rY0SHrycQ9Q2OE7WK+wbPiXquh0R9Y6j5TelEfaOBqG+yQNRzgUR9I7Dob/KEqJEx3+z4NNU3bBpoou4L1BDZePs7ng9VL/0J0y0wbgpR6zpET7LI2rnFcaJWGt5C0LA/UMNbPSFqZP8a4HjPUTkZQOg5A0nkN5BI1FoL9B5C1tNtJF1vs0DUc4BEPQimQ77VZ30PAudPH7fHiA7fTiDqOxwnahX3HZ4T9RwYURdZe9b3naHmd6UT9Z0Gor7LAlHPARL1ncCivyvGSS666yNjvtvxaeq2sGmgifo2oIbIxnuP4/lQ9XIPYboFxk0hal2H6EkWWTv3Ok7USsN7CRreA9TwPk+IGtm/Bjvec1ROBhN6zv0k8rufSNRaC/QeQtbTAyRdH7BA1LOBRP0gjqhLbRL1g+D86eOhGNHhhwhE/bDjRK3ifthzop6NI+qowV0KUT8Sav5oOlE/YiDqRy0Q9WwgUT8CLPpHY5zkors+MuYhjk9TD4RNA03UDwA1RDbexxzPh6qXxwjTLTBuClHrOkRPssjaedxxolYaPk7Q8DGghk94QtTI/vWk4z1H5eRJQs95ikR+TxGJWmuB3kPIenqapOvTFoh6FpCon4HpELF6j/oZcP708WyM6PCzBKJ+znGiVnE/5zlRz4IRdam1e9TPh5q/kE7UzxuI+gULRD0LSNTPA4v+hRgnueiuj4x5qOPT1NNh00AT9dNADZGN90XH86Hq5UXCdAuMm0LUug7Rkyyydl5ynKiVhi8RNHwRqOHLnhA1sn8Nc7znqJwMI/Sc4STyG04kaq0Feg8h62kESdcRFoh6JpCoX4HpEI3aJOpXwPnTx6sxosOvEoj6NceJWsX9mudEPRNG1CWlBncpRP16qPkb6UT9uoGo37BA1DOBRP06sOjfiHGSi+76yJjfdHyaGhE2DTRRjwBqiGy8bzmeD1UvbxGmW2DcFKLWdYieZJG187bjRK00fJug4VtADd/xhKiR/etdx3uOysm7hJ7zHon83iMStdYCvYeQ9fQ+Sdf3LRD1DCBRfwDToczqPeoPwPnTx4cxosMfEoj6I8eJWsX9kedEPQNG1MLaPeqPQ80/SSfqjw1E/YkFop4BJOqPgUX/SYyTXHTXR8b8qePT1Pth00AT9ftADZGN9zPH86Hq5TPCdAuMm0LUug7Rkyyydj53nKiVhp8TNPwMqOEXnhA1sn996XjPUTn5ktBzviKR31dEotZaoPcQsp5GknQdaYGopwOJ+muYDjGrRP01OH/6GBUjOjyKQNTfOE7UKu5vPCfq6TCiLrZG1KNDzcekE/VoA1GPsUDU04FEPRpY9GNinOSiuz4y5rGOT1Mjw6aBJuqRQA2RjXec4/lQ9TKOMN0C46YQta5D9CSLrJ3xjhO10nA8QcNxQA0neELUyP410fGeo3IykdBzJpHIbxKRqLUW6D2ErKfJJF0nWyDqaUCingLTIV5ok6ingPOnj6kxosNTCUQ9zXGiVnFP85yop8GIOhE3uEsh6umh5jPSiXq6gahnWCDqaUCing4s+hkxTnLh76MCY57p+DQ1OWwaaKKeDNQQ2XhnOZ4PVS+zCNMtMG4KUes6RE+yyNqZ7ThRKw1nEzScBdRwjidEjexfcx3vOSoncwk9Zx6J/OYRiVprgd5DyHqaT9J1vgWingok6gW4OzRWiXoBOH/6WBgjOryQQNSLHCdqFfciz4l6KoyoY9aIenGo+ZJ0ol5sIOolFoh6KpCoFwOLfkmMk1x010fGvNTxaWp+2DTQRD0fqCGy8S5zPB+qXpYRpltg3BSi1nWInmSRtbPccaJWGi4naLgMqOEKT4ga2b9WOt5zVE5WEnrOKhL5rSIStdYCvYeQ9bSapOtqC0Q9BUjU3+LuUQc2ifpbcP70sSZGdHgNgajXOk7UKu61nhP1FBhRFwYGdylEvS7U/Lt0ol5nIOrvLBD1FCBRrwMW/XcxTnLRXR8Z8/eOT1Orw6aBJurVQA2RjfcHx/Oh6uUHwnQLjJtC1LoO0ZMssnZ+dJyolYY/EjT8AajhT54QNbJ//ex4z1E5+ZnQc9aTyG89kai1Fug9hKynX0i6/mKBqCcDifpX3DwpbBL1r+D86eO3GNHh3whE/bvjRK3i/t1zop4MI+qCpMFdClFvCDXfmE7UGwxEvdECUU8GEvUGYNFvjHGSi+76yJj/cHya+iVsGmii/gWoIbTx5rudD1Uvykf0dAuMm0LUug7RkyyydnYgaxhkdvy5l5WPaA1TaydTDcuDNdQH+hqA7F87Ot5zVE52JPScCsBcp85QFfJ5RK21QO8hZD3tRNJ1p3w+UU8CEvXOMB1iVn89a2dw/vSxSz7R4V3y8eetCLywsOKumP+3wKDzWiXqSbgnk1n79axdQ813yy+3KT3vmr85Uau/xCbqSUCi3hVY9Lvlc5KL7vrImCs5Pk3tFDYNNFHvBNQQ2XgrO54PVS+VCdNtZTDJoP3TdYieZJG1U8VxolYaViFoWBmoYVVPiBrZv6o53nNUTqoRek51EvlVJxK11gK9h5D1VIOkaw0LRD0RSNQ1YTqUWb1HXROcP33Uyic6XItA1LUdJ2oVd23PiXoi7tezrN2jrhNqvns6UdcxEPXuFoh6IpCo6wCLfvd8TnLRXR8Zc13Hp6kaYdNAE3UNoIbIxruH4/lQ9bIHYboFxk0hal2H6EkWWTt7Ok7USsM9CRruAdRwL0+IGtm/6jnec1RO6hF6Tn0S+dUnErXWAr2HkPXUgKRrAwtEPQFI1HvDdEjm2yTqvcH500fDfKLDDQlE3chxolZxN/KcqCfAiDooNrhLIerGoeb7pBN1YwNR72OBqCcAiboxsOj3yeckF931kTE3cXyaahA2DTRRNwBqiGy8+zqeD1Uv+xKmW2DcFKLWdYieZJG1s5/jRK003I+g4b5ADZt6QtTI/tXM8Z6jctKM0HP2J5Hf/kSi1lqg9xCyng4g6XqABaIeDyTq5jAdCq1+6rs5OH/6yMknOpxDIOpcx4laxZ3rOVGPx32P2tqnvluEmuelE3ULA1HnWSDq8UCibgEs+rx8TnLRXR8Zc0vHp6kDwqaBJuoDgBoiG2/geD5UvQSE6RYYN4WodR2iJ1lk7QjHiVppKAgaBkANI54QNbJ/RR3vOSonUULPiZHIL0Ykaq0Feg8h6ymfpGu+BaIeByTqAtw9aqvP+i4A508f8Xyiw3ECUSccJ2oVd8Jzoh6H+9S3tWd9F4aaH5hO1IUGoj7QAlGPAxJ1IbDoD8znJBfd9ZExH+T4NJUfNg00UecDNUQ23oMdz4eql4MJ0y0wbgpR6zpET7LI2jnEcaJWGh5C0PBgoIaHekLUyP51mOM9R+XkMELPaUUiv1ZEotZaoPcQsp4OJ+l6eKirTbocG8XGoo8j8okOH0GgyyMdp0sV95EEujT5itggRxI2MXDj0fPtqobIuI/yZJg4HBjz0Y4PEyrWowjDxDGOD98qL8eQe06mGrYmDQ6t/4PBYQxpcDg2n+jwsYTB4TjHBwcV93GeDA6qkI8jbGLgxqPn21UNkXEf78ng0BoY8wmODw4q1uMJg8OJjg8OKi8nkntOphqeRBocTrJwD3808B7+ycA9ZHNYOjmfMyydkk90+BTCsNTG8WFJxd3G0rAUZHaIk0Jf0bcOTwLmCJnvto5fQFWja0u4gJ7q+AVUxXwqIe7TSBe90wwfAUFrws4ZYo+3IQw9yP1+uuN1rzQ8naBhW6CGZ3gCWshrzpmOXydUTs4k9Mt2pH7Zjni7V2uB3kPIempP2kNoLduDZ2t9oPf650AgPCslZpGIRiLxqPp7idJAxEpLIolIpLQ4FpQERSWRssKYKEzGIrFoSWlJsTxnkUgGyaKSwmTir3PZBMKzSEB4dj7R4bMJQHiO40Co4j6HAISq2JSVL8cvts+jnAaWrkmmGzC1kDukvjOFvlKeA5wQUq+UHf7lSrkFn0u2IM6fG6XDdlwptyR6B+AGPJc0gajzXredtSCkdiUiSAaFkaAoiJcUxIsLSyPFiaJkNJkfLY1ur65bKnakrueRdD1v+3X9/6Jezyfpev7/8Xq9gKTrBaGu+sJpY1JDXjxTL/ZF4VBRrK4ZjAtcB8K01sHxt7W2d3ME2xB3pj6WOP62lirMEsLbE6WkplD6L802yOwQxSQtykhalBG1UI2QoUW/tm73FNZ+uP6/jbtkC/7Rav8GcNz6QH+LF1iXAphrgdRPDVI7lzO/C1FuG/XcUj2lnpNxzUJpkjpUJv/tXYggs0OUkC4Cye1/v15s6d9RPicJTaE/qSlU2MacbcvwlmnMHfPdbDDIXKTWZceU4WR787MlzZH56ZR6byEalXujNC6SpclofrwwUiwKogUFyVgyXpCIlSbzY0Wl8TIRK4pGCsviQVIkysri+dGSeEGysLSkIJnatEVpNBorLSwuEfmRgqLiIFEaLQqSsXhUAn9pNF5aGk0UFBRFo6UFiWSiUEK6RP9EkB+PFwYFkWhhhJWfTil0jboobOndnNRz+nJR6OzjRaEz+aLQmXBRuNWRi8I/FnH8z4e0JJFN50JHLwq3kprOhYCLwpbe2kTmp4ujFwVWfrr8f/SW60XhW65dTW+5Bpkd/3i/A3mvMtNzAd++pXwySmuI/kQzS8NMz3Wx4/lQG+ZiwoW9G2nI6UZ8+7MrSYvuJC26k98KZmgx0PG3gln74TbH3wpm1f4gT94KBtalAOZaDMq+FZx+/HnNQmmSOuxewqT+i0kXgUuI1K98voTQFO7y5K3gi4GD4KX5bjaYu0hUeamFt4KR+bkMSP2DgNTPys9lhvxs62dqtvTWLzI/PUj9swdAhy29O4XUoSdJh56e1cPlJB0u96weepF06LUVt4pcHuwM7sLqOHVovMLHofEK8tB4BWFovMfS0Jjhp+KhTe5K4LmQQ+M9pKHkyq0YGjP9dD0yP1fl4wY95NDIys9VgIvjFg6xCvjd0d6w/pmgfBD7nPBdN/QdJWSN93H8DobKcR/C9eZq0rVXnbdi+N+Dy21+oP5NfT603u3Ku+/jNehB0peivc/x2ysq5msIcQ925B3FLRybFGamMV8LbMzAuhHIXJCb5P9uU/xfbJLX/l9tktc5/vU8FfN1hLj7kiaavvl/P22N8XVP04QcZHYI5ITcz/F6UkTVj/H1Ng/20fWMr7eR9tEN/7KPgswOWk95sO3/zRp4yNLnWjL180bgkAjMtXiI9A7VjVm6pvt4E3twRFDmTYRN/6gnlHmTB5s+01wM8aQB3wzMBbD+xJAspXvRbG9GNltfr4qtK7nvY/9sogJxrgc76pZsogJxvAc76tZsogJxogeJGpBNVCBO9iBRA7OJCkQbDxJ1WzZRgTjVg0QNyiYqEKd7kKjbs4kKxJkeJOqObKIC0d6DRN2ZTVQgzvYgUXdlExWIDh4k6u5sogJxngeJuiebqEBc4EGi7s0mKhAvevCm7H3ZRAWixIMdNTibqECUeZCo+7OJCkRHDxL1QDZRgejsQaIezCYqEF08SNRD2UQFoqsHiXo4m6hAdPMgUY9kExWISzxI1KPZRAXiMg8SNSSbqED09CBRj2UTFYheHiTq8WyiAnGlB4l6IpuoQPT2IFFPZhMViKs9SNRT2UQF4loPEvV0NlGB6OtBop5BJko9Q3OXcn9/t0w52zgtaeXBAQAfciHQX/RnJKy/Bz7e4oGPt3rg4wAPfBzogY+3eeDjIA98vN0DH+/wwMc7PfDxLg98vNsDH+/xwMd7PfDxPg98HOyBj/d74OMDHvj4oAc+PuSBjw974OMjHvj4qAc+DvHAx8c88PFxD3x8wgMfn/TAx6c88PFpD3x8huBjOaiP0Xg5w4E5d0Twzv33L5PvkHLOZ6Xez0l7XtoL0oZKe1HaS9JeljZM2nBpI6S9Iu1Vaa9Je13aG9LelPaWtLelvSPtXWnvSXtf2gfSPpT2kbSPpX0i7VNpn0n7XNoX0r6U9pW0kdK+ljZK2jfSRksbI22stHHSxkubIG2itEnSJkubIm2qtGnSpkubIW2mtFnSZkubI22utHnS5ktbIG2htEXSFktbkv+XBkvzQ1H0UxuVKBXT1p4zrD1vWHvBsDbUsPaiYe0lw9rLhrVhhrXhhrURhrVXDGuvGtZeM6y9blh7w7D2pmHtLcPa24a1dwxr7xrW3jOsvW9Y+8Cw9qFh7SPD2seGtU8Ma58a1j4zrH1uWPvCsPaVYW2kYe1rw9oow9o3hrXRhrUxhrWxhrVxhrXxhrUJhrWJhrVJhrXJhrUphrWphrVphrXphrUZhrWZhrVZhrXZhrU5hrW5hrV5hrX5hrUFhrWFhrVFhrXFhrUlhjXV/BqV2/RAP3Qy9eafQ0/5Fs/mc4aN8mD9gDcTxXOexAy8OSme9yRm4M1O8YInMQNvnoqhnsQMvBkrXvQkZuDNXfGSJzEDbxaLlz2JGXjzWQzzJGbgzWwx3JOYgTfHxQhPYgbebBeveBIz8Oa9eNWTmIEfBhCveRIz8MMF4nVPYgZ+WEG84UnMwA8/iDc9iRn4YQrxlicxAz+cId72JGbghz3EO57EDPzwiHjXk5iBH0YR73kSM/DDLeJ9T2IGflhGfOBJzMAP34gPPYkZ+GEe8ZEnMQM/HCQ+9iRm4IeNxCeexAz88JL41JOYgR+GEp95EjPww1Xic09iBn5YS3xBinmHtJiDzA7xJeBedllSHSVF6ou4FVPyskOKnyz/Gfe80T5mvzyL8TH75VmMj9kvz2J8zH55FuNj9suzGB+zX57F+Jj98izGx+yXZzE+Zr88i/Ex++VZjI/ZL89ifMx+eRbjY/bLsxgfs1+exfiY/fIsxkcfvzyLOW+CpulID/L+tQc+jvLAx2888HG0Bz6O8cDHsR74OM4DH8d74OMED3yc6IGPkzzwcbIHPk7xwMepHvg4zQMfp3vg4wwPfJzpgY+zPPBxtgc+zvHAx7ke+DjPAx/ne+DjAg98XOiBj4s88HGxBz4uIb7Ph/MzEjF9rnGZ9H25tBXSVkpbJW21tG+lrZG2Vto6ad9J+17aD9J+lPaTtJ+lrZf2i7Rfpf0m7XdpG6RtlPaHtHIF8t+TVl7ajtIqSNtJ2s7SdpFWUdqu0naTVklaZWlVpFWVVk1adWk1pNWUVktabWl1pO0ura60PaTtKW0vafWk1ZfWQNre0hpKayStsbR9pDWRtq+0/aQ1ldas4C8N9i8ot+lDmJQo6Q9mWm5YW2FYW2lYW2VYW21Y+9awtsawttawts6w9p1h7XvD2g+GtR8Naz8Z1n42rK03rP1iWPvVsPabYe13w9oGw9pGw9ofhjVVlOlrOxjWyhvWdjSsVTCs7WRY29mwtothbTfDWiXDWmXDWhXDWlXDWjXDWnXDWg3DWk3DWi3DWm3DWh3D2u6GtbqGtT0Ma3sa1vYyrNUzrNU3rDUwrO1tWGtoWGtkWGtsWNvHsNbEsLavYW0/w1pTw1ozw5pqdI3KbXroi0Kr8M9Mv4QA/EC7WObJFy+QD4Rb7knMyAfCrfAkZuQD4VZ6EjPygXCrPIkZ+UC41Z7EjHwg3LeexIx8INwaT2JGPhBurScxIx8It86TmJEPhPvOk5iRD4T73pOYkQ+E+8GTmJEPhPvRk5iRD4T7yZOYkQ+E+9mTmJEPhFvvSczIB8L94knMyAfC/epJzMgHwv3mSczIB8L97knMyAfCbfAkZuQD4TZ6EjPygXB/eBIz8oFw6j6UDzEjHwi3gycxIx8IV96TmJEPhNvRk5iRD4Sr4EnMyAfC7eRJzMgHwu3sSczIB8LtQop5h7SYg8wOUbEgc/30A+GYfu4K8zMhmDUE/MKl2M2TfQP8Aqeo5EnMwC+EisqexAz8gqmo4knMwC+siqqexAz8Aqyo5knMwC/UiuqexAz8gq6o4UnMwC/8ipqexAz8ArGo5UnMwC8ki9qexAz8grOo40nMwC9Mi909iRn4BWxR15OYgV/oFnt4EjPwC+JiT09iBn7hXOzlSczAL7CLep7EDPxCvKjvSczAL9iLBp7EDPzCvtjbk5iBDwAQDT2JGfhAAdHIk5iBDygQjT2JGfjAA7GPJzEDH6AgmngSM/CBDGJfT2IGPuBB7OdJzMAHRoimnsQMfACFaAaMWf2g1q7l/vr+sTp2SIm5XMpaqhZBZkf2B7VAPmZ/UAvjY/YHtTA+Zn9QC+Nj9ge1MD5mf1AL42P2B7UwPmZ/UAvjY/YHtTA+Zn9QC+Nj9ge1MD5mf1AL42P2B7UwPmZ/UAvjY/YHtTA+Zn9QC3He7A9qMXzM/qAWxsfsD2phfMz+oBbGx+wPamF8zP6gFsbH7A9qYXzM/qAWxsfsD2phfMz+oBbGx+wPamF8zP6gFsbH7A9qYXzM/qAWxsfsD2phfPTlB7WI5xY7pGirz3lAQblyzaXlSMuV1kJanrSW0gJpQlpEWlRaTFq+tAJpcWkJaYXSDpR2kLSDpR0i7VBph6nPfEo7XNoR0o6UdpS0o6UdI621tGOlHSfteGknSDtR2knSTpZ2irQ20tpKO1XaadJOl3aGtDOltZPWXtpZ0s6Wdo60DtLOlXaetPOlXSCtSFqxtBJppdLKpCWldZTWqaDcpj9mc4DhB26aG9ZyDGu5hrUWhrU8w1pLw1pgWBOGtYhhLWpYixnW8g1rBYa1uGEtYVgrNKwdaFg7yLB2sGHtEMPaoYa1wwxrrQxrhxvWjjCsHWlYO8qwdrRh7RjDWmvD2rGGtSLDWrFhrcSwVmpYKzOsJQ1rHQ1rncK11KN8+Ger8E+XftjpAE8+WI/8YafmnsSM/GGnHE9iRv6wU64nMSN/2KmFJzEjf9gpz5OYkT/s1NKTmJE/7BR4EjPyh52EJzEjf9gp4knMyB92inoSM/KHnWKexIz8Yad8T2JG/rBTgScxI3/YKe5JzMgfdkp4EjPyh50KPYkZ+cNOB3oSM/KHnQ7yJGbkDzsd7EnMyB92OsSTmJE/7HSoJzEjf9jpME9iRv6wUytPYkb+sNPhnsSM/GGnIzyJGfnDTkd6EjPyh52O8iRm5A87He1JzMgfdjrGk5iRP+zU2pOYkT/sdCwpZvSHgo4ryFw/Gz/sdDzMz01/2Ant5wme5P1ET/w8yRM/T/bEz1M88bONJ3629cTPUz3x8zRP/DzdEz/P8MTPMz3xs50nfrb3xM+zPPHzbE/8PMcTPzt44ue5nvh5nid+nu+JnxeQ/KyQqZ9i0/8syszPTc5WnGnMKWcrAfD6/95nbetoLoJNoy5F1Ex4tjJM/f15tiQwF0+6nYtAR90Rt39FJ+C5gLUsUnOR0XtiZclC9aMCVcr9/Z4qJTfk2g4yOdytGcaXLf/Xs1Lz3bngrz8vTP9SoPofc9LW1F9qVC5bKBnfdPChoaYV9HbGHAljFp2B+l0I3LSsXJQH5wKpXxfDuYqDktJ8UVxQGhdlRfmJkpLCqBCRooKiguJIIllWnC8S+Ql5zpKiSEL+c5GiElEmJ9EydRGpXO7vYTz1QA/oXYANNtXfiwqIDquTo8/bFVgMrLi7FvwtMOi8Rl8RzUT5itqw+rzIHF0MLnx9QVfnbSz/tDkJFgEv8MXAC3wJ8KJSWsC5qID2k3ES7Bbu1+7pk2A3wyTYnTkJhk6WAqePbsDN2D3lXJHS/LKgMFGciBQXRePFsWhxYWGRPG+BEIlkaSQojUWS+aKgoKSwrDAposni/LKigvyiwoLSP6+epU94Mn0g9bvE0+njEtL0cWkB0eFLCdPHZY5PHyruyzyZPrqHvqKnD2SOepCmjx7/wfQB+izrn2eDfUZUYD97yXy4PyAXxumjZ7hfL0+fPnoapo/LLbwP5UOhZLqxn/Pkfahn8nGTYE9gY7wciAzPeTIJIvXr5ekk2Is0CV5RQHT4CsIkeKXjk6CK+0pPJsHLQ1/RkyAyR1eRJsGr/oNJcAjwAv8Y8AKP/FbdEx5Ogr3D/donfRLsbZgE+1iYBH0olEw39gueTIJPACfB3sDG2Ac4Cb7gySSI1O9qTyfBq0mT4DUFRIevIUyC1zo+Caq4r/VkEuwT+oqeBJE5uo40CV73H0yCDwEv8A8DL/DI56U86uEk2Dfcr/3SJ8G+hkmwn4VJ0IdCyXRjv+jJJPgocBLsC2yM/YCT4IueTIJI/a73dBK8njQJ3lBAdPgGwiR4o+OToIr7Rk8mwX6hr+hJEJmjm0iT4E3/wSQ4GHiBvx94gUc+CfNBDyfBm8P92j99ErzZMAn2tzAJ+lAomW7slz2ZBB8EToI3Axtjf+Ak+LInkyBSv1s8nQRvIU2CtxYQHb6VMAkOcHwSVHEP8GQS7B/6ip4EkTkaSJoEB/4Hk+DdwAv8PcALPPI3Du7zcBK8Ldyvg9InwdsMk+AgC5OgD4WS6cYe7skkeB9wErwN2BgHASfB4Z5Mgkj9bvd0ErydNAneUUB0+A7CJHin45OgivtOTybBQaGv6EkQmaO7SJPgXf/BJHg78AJ/B/ACj/z1urs8nATvDvfrPemT4N2GSfAeC5OgD4WS6cZ+xZNJ8C7gJHg3sDHeA5wEX/FkEkTqd6+nk+C9pEnwvgKiw/cRJsHBjk+CKu7BnkyC94S+oidBZI7uJ02C9/8Hk+AA4AV+IPACj/xd8kEeToIPhPv1wfRJ8AHDJPighUnQh0LJdGO/5skkOAg4CT4AbIwPAifB1zyZBJH6PeTpJPgQaRJ8uIDo8MOESfARxydBFfcjnkyCD4a+oidBZI4eJU2Cj9qcBMOLcn/gRfkW4PR2az5uiHnWw0lwSLhfH0ufBIcYJsHHmJOgR4WS6cZ+w/VJ0FDQmU6CQ4CN8THgJPiGJ5MgUr/HPZ0EHydNgk8UEB1+gjAJPun4JKjiftKTSfCx0Ff0JIjM0VOkSfCpcBJUr+uW2/Qin/rWT+oNwdSPiaV+eSD1K6WpDxpRry9Ped238t+v25Xf/tfdU855YaoPKee/PuX1DSmvb0x5fVPK65tTXvdPeX1L+Ppp+e88I+1Zac9Je17aC9KGSnuxYPNJGr2vXgTWgR4WXpLnfFnaMGnDwykwtUbU/69YbtO1lw1rwwxrw8O11AP9dtWLwH32EuBcf/1+ciBeBvr1FmlI2TEtF5nErHIxDKLfX3kdDhzykPqx9/hQwh4fIc/5irRXpb1m2OMjDHv3FcPaq4a11yzs8aHAvTQCuMdfAfr1jid7/FXgHn8NuMff8WiPv0DY46/Lc74h7U1pbxn2+OuGvfuGYe1Nw9pbFvb4C8C99Dpwj78B9Os9T/b4m8A9/hZwj7/n0R5/nrDH35bnfEfau9LeM+zxtw179x3D2ruGtfcs7PHngXvpbeAefwfo1wee7PF3gXv8PeAe/8CjPf4cYY+/L8/5gbQPpX1k2OPvG/buB4a1Dw1rH1nY488B99L7wD3+AdCvjzzZ4x8C9/hHwD3+kUd7/FnCHv9YnvMTaZ9K+8ywxz827N1PDGufGtY+s7DHnwXupY+Be/wToF+feLLHPwXu8c+Ae/wTj/b4M4Q9/rk85xfSvpT2lWGPf27Yu18Y1r40rH1lYY8/A9xLnwP3+BdAvz7zZI9/CdzjXwH3+Gce7fGnCXt8pDzn19JGSfvGsMdHGvbu14a1UYa1byzs8aeBe2kkcI9/DfTrC0/2+CjgHv8GuMe/8GiP74A7V9AoPM9oqeUYaWOljZM2XtoEaROlTZI2WdoUaVOlTZM2XdoMaTOlzZI2W9ocaXOlzZM2X9oCaQulLZK2WNoSaUulLZO2XNoKaSulrTL0lNGGXjHGsDbWsDbOsDbesDbBsDbRsDbJsDbZsDbFsDbVsDbNsDbdsDbDsDbTsDbLsDbbsDbHsDbXsDbPsDbfsLbAsLbQsLbIsLbYsLbEsLbUsLbMsLbcsLbCsLbSsLbKwjUodc9m2utHA69BY4DXoK8sfeA302vQWOA1aFzm5/rfh4fHI+cUl3MR+5+fYkJmMQcpMYuJmZwrsol+YhIwF1+7mYsgzU8xeTtjLkhuFrOYsn3nShj0E1OBuRjlWi4SRj/FtG2POf4PMYvp23qu+D/qJ2YAc/GNO7mI/IufYua2xBz/15jFrK0/V8kW9BOzgbkY7UIu4lv0U8zZupiDrYhZzN2acwVbpZ+YB8zFmP82F/lb6aeYv6WYY1sds1jwr+eKJbdBP7EQmIux/1Uu4tvkp1j0zzEntjFmsfgfzlWY3Gb9xBJgLsbZz0WwHX6KpaaYg+2KWSzb/FxiO/UTy4G5GG8zF6Xb7adYsWnM0QxiFitTzhVJZqSfWAXMxQRPHrkCfH9AAPlWpPJZprmY6EkugBwkgHO8GA3MxSRPcgGc9wRwXhHjgLmY7EkugNc1AezLYiIwF1Ms3SsMMjsEcP8KYP0Jln7l0/TLNM/IGWM17F5rNLD5MAWc35s+TOHbAqLD6uTo864BFgMr7jUFfwsMOm/wb49/QsewClZspYxHI4VebvoBhbWh5uvCm/D/uyu6NizC1LV1hjul6K6P6Fr67uZaYNGvAyeXscHXGhpHpnGvLfDjarcSmOvvYDEXxGxe7b4jXe2+LyA6/D3haveD41c7FfcPnl/tVsKKrbDE4C7lavdjqPlP6Ve7Hw1Xu58sXO1WAq92PwKL/idSctFdHxnzz7juKcqVw1+J14RNozy4BpFosB48LaCblsrxesKU5HrcunbQcf/iyXSIrPFfyX0iyOwQKie/EvrEeqCGv3mwX34j7JffwRO6nlV+T/GVpQW6nn4F1tMGkq4bCjYnN3RvWgHUYSNMh5jVh95uBOdPH38UEB3+g0Cu5eJuk6uKW/lYDnteq+S6AlZsxRGDuxRy3SHUvHy83KaUqv5HOrmqv8QmV0TX0uS6A7Doy8c5yUV3fWTMO8aBDagcfsNtCJsG6tukpqt+xs0SmI8KjudD1UuFOH66BcZNeQq6rkP0JIusnZ3IGgaZHX/u5Z0IGlYAargzWEN9oK8ByP61i+M9R+VkF0LPqQjMdeoMVTHOI2qtBXoPIetpV5Kuu8b5RI38pPtuMB3iEZtEvRs4f/qoFCc6XCmOP29lx4laxV3Zc6JeDiPqRJnBXQpRVwk1r5pO1FUMRF3VAlEvBxJ1FWDRV41zkovu+siYqzk+Te0aNg00Ue8K1BDZeKs7ng9VL9UJ0211MMmg/dN1iJ5kkbVTw3GiVhrWIGhYHahhTU+IGtm/ajnec1ROahF6Tm0S+dUmErXWAr2HkPVUh6RrHQtEvQxI1LvDdCgTNol6d3D+9FE3TnS4LoGo93CcqFXce3hO1MtgRC2SBncpRL1nqPle6US9p4Go97JA1MuARL0nsOj3inOSi+76yJjrOT5N1QmbBpqo6wA1RDbe+o7nQ9VLfcJ0C4ybQtS6DtGTLLJ2GjhO1ErDBgQN6wM13NsTokb2r4aO9xyVk4aEntOIRH6NiESttUDvIWQ9NSbp2tgCUS8FEvU+MB2iVol6H3D+9NEkTnS4CYGo93WcqFXc+3pO1EthRF1ijaj3CzVvmk7U+xmIuqkFol4KJOr9gEXfNM5JLrrrI2Nu5vg01ThsGmiibgzUENl493c8H6pe9idMt8C4KUSt6xA9ySJr5wDHiVppeABBw/2BGjb3hKiR/SvH8Z6jcpJD6Dm5JPLLJRK11gK9h5D11IKkawsLRI181nweTIciq8+7zAPnTx8t40SHWxKIOnCcqFXcgedEvQT3mDxrz7sUoeaRdKIWBqKOWCDqJUCiFsCij8Q5yUV3fWTMUcenqRZh00ATdQughsjGG3M8H6peYoTpFhg3hah1HaInWWTt5DtO1ErDfIKGMaCGBZ4QNbJ/xR3vOSoncULPSZDIL0Ekaq0Feg8h66mQpGuhBaJeDCTqA2E6RAptEvWB4Pzp46A40eGDCER9sONEreI+2HOiXoz7kYG4wV0KUR8S/kuHphP1IQaiPtQCUS8GEvUhwKI/NM5JLrrrI2M+zPFpqjBsGmiiLgRqiGy8rRzPx5/1QphugXFTiFrXIXqSRdbO4Y4TtdLwcIKGrYAaHuEJUSP715GO9xyVkyMJPecoEvkdRSRqrQV6DyHr6WiSrkdbIOpFQKI+BqZDccImUR8Dzp8+WseJDrcmEPWxjhO1ivtYz4l6Ee6B+AmDuxSiPi7U/Ph0oj7OQNTHWyDqRUCiPg5Y9MfHOclFd31kzCc4Pk0dHTYNNFEfDdQQ2XhPdDwfql5OJEy3wLgpRK3rED3JImvnJMeJWml4EkHDE4EanuwJUSP71ymO9xyVk1MIPacNifzaEIlaa4HeQ8h6akvSta0Fol4IJOpTYTrkW/3U96ng/OnjtDjR4dMIRH2640St4j7dc6JeiPv1LGuf+j4j1PzMdKI+w0DUZ1og6oVAoj4DWPRnxjnJRXd9ZMztHJ+m2oZNA03UbYEaIhtve8fzoeqlPWG6BcZNIWpdh+hJFlk7ZzlO1ErDswgatgdqeLYnRI3sX+c43nNUTs4h9JwOJPLrQCRqrQV6DyHr6VySrudaIOoFQKI+D3eHJt8mUZ8Hzp8+zo8THT6fQNQXOE7UKu4LPCfqBTiiLja4SyHqolDz4nSiLjIQdbEFol4AJOoiYNEXxznJRXd9ZMwljk9T54ZNA03U5wI1RDbeUsfzoeqllDDdAuOmELWuQ/Qki6ydMseJWmlYRtCwFKhh0hOiRvavjo73HJWTjoSe04lEfp2IRK21QO8hZD11Juna2QJRzwcS9YW4ebLAJlFfCM6fPrrEiQ53IRD1RY4TtYr7Is+Jej7uU99FBncpRN011PzidKLuaiDqiy0Q9XwgUXcFFv3FcU5y0V0fGXM3x6epzmHTQBN1Z6CGyMbb3fF8qHrpTphugXFTiFrXIXqSRdbOJY4TtdLwEoKG3YEaXuoJUSP712WO9xyVk8sIPacHifx6EIlaa4HeQ8h66knStacFop4HJOrLYTokrP561uXg/OmjV5zocC8CUV/hOFGruK/wnKjnwYg6bu3Xs64MNb8qnaivNBD1VRaIeh6QqK8EFv1VcU5y0V0fGXNvx6epnmHTQBN1T6CGyMbbx/F8qHrpQ5hugXFTiFrXIXqSRdbO1Y4TtdLwaoKGfYAaXuMJUSP717WO9xyVk2sJPec6EvldRyRqrQV6DyHrqS9J174WiHoukKj7eUrU/cD508f1caLD1xOI+gbHiVrFfYPnRD3XQ6K+MdT8pnSivtFA1DdZIOq5QKK+EVj0N3lC1MiYb3Z8muobNg00UfcFaohsvP0dz4eql/6E6RYYN4WodR2iJ1lk7dziOFErDW8haNgfqOGtnhA1sn8NcLznqJwMIPScgSTyG0gkaq0Feg8h6+k2kq63WSDqOUCiHgTTId/qs74HgfOnj9vjRIdvJxD1HY4TtYr7Ds+Jeg6MqIusPev7zlDzu9KJ+k4DUd9lgajnAIn6TmDR3xXnJBfd9ZEx3+34NHVb2DTQRH0bUENk473H8XyoermHMN0C46YQta5D9CSLrJ17HSdqpeG9BA3vAWp4nydEjexfgx3vOSongwk9534S+d1PJGqtBXoPIevpAZKuD1gg6tlAon4QR9SlNon6QXD+9PFQnOjwQwSifthxolZxP+w5Uc/GEXXU4C6FqB8JNX80nagfMRD1oxaIejaQqB8BFv2jcU5y0V0fGfMQx6epB8KmgSbqB4AaIhvvY47nQ9XLY4TpFhg3hah1HaInWWTtPO44USsNHydo+BhQwyc8IWpk/3rS8Z6jcvIkoec8RSK/p4hErbVA7yFkPT1N0vVpC0Q9C0jUz8B0iFi9R/0MOH/6eDZOdPhZAlE/5zhRq7if85yoZ8GIutTaPernQ81fSCfq5w1E/YIFop4FJOrngUX/QpyTXHTXR8Y81PFp6umwaaCJ+mmghsjG+6Lj+VD18iJhugXGTSFqXYfoSRZZOy85TtRKw5cIGr4I1PBlT4ga2b+GOd5zVE6GEXrOcBL5DScStdYCvYeQ9TSCpOsIC0Q9E0jUr8B0iEZtEvUr4Pzp49U40eFXCUT9muNEreJ+zXOingkj6pJSg7sUon491PyNdKJ+3UDUb1gg6plAon4dWPRvxDnJRXd9ZMxvOj5NjQibBpqoRwA1RDbetxzPh6qXtwjTLTBuClHrOkRPssjaedtxolYavk3Q8C2ghu94QtTI/vWu4z1H5eRdQs95j0R+7xGJWmuB3kPIenqfpOv7Foh6BpCoP4DpUGb1HvUH4Pzp48M40eEPCUT9keNEreL+yHOingEjamHtHvXHoeafpBP1xwai/sQCUc8AEvXHwKL/JM5JLrrrI2P+1PFp6v2waaCJ+n2ghsjG+5nj+VD18hlhugXGTSFqXYfoSRZZO587TtRKw88JGn4G1PALT4ga2b++dLznqJx8Seg5X5HI7ysiUWst0HsIWU8jSbqOtEDU04FE/TVMh5hVov4anD99jIoTHR5FIOpvHCdqFfc3nhP1dBhRF1sj6tGh5mPSiXq0gajHWCDq6UCiHg0s+jFxTnLRXR8Z81jHp6mRYdNAE/VIoIbIxjvO8XyoehlHmG6BcVOIWtchepJF1s54x4laaTieoOE4oIYTPCFqZP+a6HjPUTmZSOg5k0jkN4lI1FoL9B5C1tNkkq6TLRD1NCBRT4HpEC+0SdRTwPnTx9Q40eGpBKKe5jhRq7ineU7U02BEnYgb3KUQ9fTwX5qRTtTTDUQ9wwJRTwMS9XRg0c+Ic5ILfx8VGPNMx6epyWHTQBP1ZKCGyMY7y/F8qHqZRZhugXFTiFrXIXqSRdbObMeJWmk4m6DhLKCGczwhamT/mut4z1E5mUvoOfNI5DePSNRaC/QeQtbTfJKu8y0Q9VQgUS/A3aGxStQLwPnTx8I40eGFBKJe5DhRq7gXeU7UU2FEHbNG1IvDf2lJOlEvNhD1EgtEPRVI1IuBRb8kzkkuuusjY17q+DQ1P2waaKKeD9QQ2XiXOZ4PVS/LCNMtMG4KUes6RE+yyNpZ7jhRKw2XEzRcBtRwhSdEjexfKx3vOSonKwk9ZxWJ/FYRiVprgd5DyHpaTdJ1tQWingIk6m9x96gDm0T9LTh/+lgTJzq8hkDUax0nahX3Ws+JegqMqAsDg7sUol4Xav5dOlGvMxD1dxaIegqQqNcBi/67OCe56K6PjPl7x6ep1WHTQBP1aqCGyMb7g+P5UPXyA2G6BcZNIWpdh+hJFlk7PzpO1ErDHwka/gDU8CdPiBrZv352vOeonPxM6DnrSeS3nkjUWgv0HkLW0y8kXX+xQNSTgUT9K26eFDaJ+ldw/vTxW5zo8G8Eov7dcaJWcf/uOVFPhhF1QdLgLoWoN4Sab0wn6g0Got5ogagnA4l6A7DoN8Y5yUV3fWTMfzg+Tf0SNg00Uf8C1BDaeBNu50PVi/IRPd0C46YQta5D9CSLrJ0dyBoGmR1/7mXlI1rD1NrJVMPyYA31gb4GIPvXjo73HJWTHQk9pwIw16kzVIUEj6i1Fug9hKynnUi67pTgE/UkIFHvDNMhZvXXs3YG508fuySIDu+SwJ+3IvDCwoq7Ysojm0DntUrUk3BPJrP261m7hprvlii3KT3vmticqNVfYhP1JCBR7wos+t0SnOSiuz4y5kqOT1M7hU0DTdQ7ATVENt7KjudD1UtlwnRbGUwyaP90HaInWWTtVHGcqJWGVQgaVgZqWNUTokb2r2qO9xyVk2qEnlOdRH7ViUSttUDvIWQ91SDpWsMCUU8EEnVNmA5lVu9R1wTnTx+1EkSHaxGIurbjRK3iru05UU/E/XqWtXvUdULNd08n6joGot7dAlFPBBJ1HWDR757gJBfd9ZEx13V8mqoRNg00UdcAaohsvHs4ng9VL3sQpltg3BSi1nWInmSRtbOn40StNNyToOEeQA338oSokf2rnuM9R+WkHqHn1CeRX30iUWst0HsIWU8NSLo2sEDUE4BEvTdMh2S+TaLeG5w/fTRMEB1uSCDqRo4TtYq7kedEPQFG1EGxwV0KUTcONd8nnagbG4h6HwtEPQFI1I2BRb9PgpNcdNdHxtzE8WmqQdg00ETdAKghsvHu63g+VL3sS5hugXFTiFrXIXqSRdbOfo4TtdJwP4KG+wI1bOoJUSP7VzPHe47KSTNCz9mfRH77E4laa4HeQ8h6OoCk6wEWiHo8kKibw3QotPqp7+bg/OkjJ0F0OIdA1LmOE7WKO9dzoh6P+x61tU99twg1z0sn6hYGos6zQNTjgUTdAlj0eQlOctFdHxlzS8enqQPCpoEm6gOAGiIbb+B4PlS9BITpFhg3hah1HaInWWTtCMeJWmkoCBoGQA0jnhA1sn9FHe85KidRQs+JkcgvRiRqrQV6DyHrKZ+ka74Foh4HJOoC3D1qq8/6LgDnTx/xBNHhOIGoE44TtYo74TlRj8N96tvas74LQ80PTCfqQgNRH2iBqMcBiboQWPQHJjjJRXd9ZMwHOT5N5YdNA03U+UANkY33YMfzoerlYMJ0C4ybQtS6DtGTLLJ2DnGcqJWGhxA0PBio4aGeEDWyfx3meM9ROTmM0HNakcivFZGotRboPYSsp8NJuh4e6mqTLscWYGPRxxEJosNHEOjySMfpUsV9JIEuTb4iNsiRhE0M3Hj0fLuqITLuozwZJg4Hxny048OEivUowjBxjOPDt8rLMeSek6mGrUmDQ+v/YHAYQxocjk0QHT6WMDgc5/jgoOI+zpPBQRXycYRNDNx49Hy7qiEy7uM9GRxaA2M+wfHBQcV6PGFwONHxwUHl5URyz8lUw5NIg8NJFu7hjwbewz8ZuIdsDksnJzjD0ikJosOnEIalNo4PSyruNpaGpSCzQ5wU+oq+dXgSMEfIfLd1/AKqGl1bwgX0VMcvoCrmUwlxn0a66J1m+AgIWhN2zhB7vA1h6EHu99Mdr3ul4ekEDdsCNTzDE9BCXnPOdPw6oXJyJqFftiP1y3bE271aC/QeQtZTe9IeQmvZHhiz9q1Riq+rCv66bqrXK1Ner0h5vTzl9bKU10tTXi9Jeb045fWilNcLU14vSHk9P+X1vJTXc1Nez0l5PTvl9ayU1zNTXs9IeT095fW0lNdTU15PSXk9OeX1pJTXE1NeT0h5PT7l9biU12NTXo9JeT065fV7Ka/fTXn9Tsrrt1Nev5Xy+s2U12+kvH495fVrKa9fTXn9SsrrESmvh6e8Hpby+uWU1y+lvP4m5fWolNdfp7wemfL6q5TXX6a8/iLl9ecprz9Lef1pyutPUl5/nPL6o5TXH6a8/iDl9fvha71xz5J77Gxp50jrIO1caedJO1/aBdKKpBVLK5FWKq1MWlJaR2mdpHWWdqG0LtIuktZV2sXSuknrLu0SaZdKu0xaD2k9pV0urZe0K6RdKe0qab2l9ZF2tbRrpF0r7TppfaX1k3a9tBuk3SjtJmk3S+sf9vFK5f5mRvXfezcrV25j+LphyutGzf76s3zK3/0h7+///2P4+hZ53lulDUj8dQfK1mfVB5D6cjmsn5FULQaG7y3clggF0RdZ9T82pDmA/lz6AMAF4q/PpSeTA4EXm9ssDalBZodAxjwo5VwiEY1E4lH19xKlgYiVlkQSkUhpcSwoCYpKImWFMVGYjEVi0ZLSkmJ5ziKRDJJFJYXJxF9+2XwncxDpnczbE0SHbye8k3mH4+9kqrjvSPwtMOi8lHcjbgt9RZ/3ThIR3ZnY/AqHzh+yKbJ9vQXoa6PwPHfJc94t7R5p90q7T9pgafdLe0Dag9IekvawtEekPSptiLTHpD0u7QlpT0p7StrT0p6R9qy056Q9L+0FaUOlvSjtJWkvSxsmbbi0EeHVOTXndyX+ngr12t2GtXsMa/ca1u4zrA02rN1vWHvAsPagYe0hw9rDhrVHDGuPGtaGGNYeM6w9blh7wrD2pGHtKcPa04a1ZwxrzxrWnjOsPW9Ye8GwNtSw9qJh7SXD2suGtWGGteGGtRGJzd+hrhD+2Sr8M8js2GTPZtpn74INloG4G+jXkracwTI9F5nErHJxD0S/v/J6b+bnioT6ifuAuVjqci5i//NTDM4s5iAlZnF/JueKbKKfeACYi2Vu5iJI81M8uJ0xFyQ3i1k8tH3nShj0Ew8Dc7HctVwkjH6KR7Y95vg/xCwe3dZzxf9RPzEEmIsV7uQi8i9+ise2Jeb4v8YsHt/6c5VsQT/xBDAXK13IRXyLfoonty7mYCtiFk9tzbmCrdJPPA3Mxar/Nhf5W+mneGZLMce2Ombx7L+eK5bcBv3Ec8BcrP6vchHfJj/F8/8cc2IbYxYv/MO5CpPbrJ8YCszFt/ZzEWyHn+JFU8zBdsUsXtr8XGI79RMvA3OxxmYuSrfbTzFs05ijGcQshqecK5LMSD8xApiLtZZyEWR2COD7AwLItyKVzzLNxTpPcgHkIAGc48VKYC6+8yQXwHlPAOcV8S0wF997kgvgdU0A+7JYB8zFD6RcoD9AAdy/Alh/Aqmfqt9npTUKzzcivCc2LLxH9lJ4z2xoeA/t+fCe2rPhPbanw3tuT4b34B4P78kNCe/RPRLes3sovIf3QHhPb3B4j+/e8J6fug+g7iukH+hPHiPnnlcSqDxErT5iFuf3ph/qeDVBdFidHH3e14DFwIr7tZRNATqv1UfMjoAVW6m1R8y+Hmr+RvjBgP/dqX09LMLUtTcS/EfMIrqWvuP6OrDo3wAnl7HBX0/gP2n0eoIzwaCvdsOBuX4TFnNBzObV7k3S1e6tBNHhtwhXu7cdv9qpuN/2/Go3HFZshSUGdylXu3dCzd9Nv9q9Y7javWvhajcceLV7B1j075KSi+76yJjfw3VP47crM/XvtbBplAfXIBIN3gdPC+impXL8PmFKcj1uXTvouD/wZDpE1viH5D4RZHYIlZMPCX3ifaCGH3mwXz4i7JePwRO6nlU+TvGVpQW6nj4E1tMnJF0/SWxObujeNAyow6cwHWJlNsn1U3D+9PFZgujwZwRy/dxxclVxf+45uQ6DFVtxxOAuhVy/CDX/Mp1cvzCQ65cWyBXRtTS5fgEs+i9JyUV3fWTMXzk+kX4SNg308/w+AWqIbLwjHc+HqpeRhOkWGDfl29i6DtGTLLJ2vnacjJSGXxM0HAnUcJQn70og+9c3jvcclZNvCD1nNIn8RhOJWmuB3kPIehpD0nWMBaJGfvp+LEyHeMTqz5+RiHpcgujwOAJRj3ecqFXc4z0n6pdhxZYoM7hLIeoJoeYT04l6goGoJ1ogakTX0kQ9AVj0E0nJRXd9ZMyTHJ+mxoRNA03UY4AaIhvvZMfzoeplMmG6BcZNIWpdh+hJFlk7UxwnaqXhFIKGk4EaTvWEqJH9a5rjPUflZBqh50wnkd90IlFrLdB7CFlPM0i6zrBA1C8BdZgJ06HM6gNiZ4Lzp49ZCaLDswhEPdtxolZxz/acqF+CFZtIGtylEPWcUPO56UQ9x0DUcy0QNaJraaKeAyz6uaTkors+MuZ5jk9TM8KmgSbqGf+PvfMAk6Lo1vAKSBbMOWDEiN2bB9jdYZegoIKAgIDARnJOAgICChhRUVBQQFBQQFBQwYiKGRUk55xzzsKtwi7pHUsJ852yzv2nn6ce+7be/r/znVOnzzszOwP0ENl4V1meD1kvqwimW2DcJESt6hA9ySJrZ7XlRC09XE3g4Sqgh2uYEDWyf621vOfInKwl6DnriMhvHSFRKy/QewhZT+uJfF1vgKjHA33YAPMhxihRbwDnTx0bEwkFbyQg6k2WE7WMexNzoh4PK7ZMY0S92fN8SyhRb9YQ9RYDRI3oWoqoNwOLfgtRctFdHxnzVsunqfVe00AT9Xqgh8jGu83yfMh62UYw3QLjJiFqVYfoSRZZO9stJ2rp4XYCD7cBPdzBhKiR/Wun5T1H5mQnQc/ZRUR+uwiJWnmB3kPIetpN5OtuA0SN/P77PTAf0o1+3+UecP7UsTeRUPBeAqLeZzlRy7j3MSfqcbBiizf2fZf7Pc8PhBL1fg1RHzBA1IiupYh6P7DoDxAlF931kTEftHya2u01DTRR7wZ6iGy8hyzPh6yXQwTTLTBuEqJWdYieZJG1c9hyopYeHibw8BDQwyNMiBrZv45a3nNkTo4S9Jw/iMjvD0KiVl6g9xCyno4R+XrMAFGPBfpwHOZDdMAkUR8H5++vI0AoWN4cfd9zAnYTtYz7nMBJf0H3NUrUY2HFlpWgkUtC1Hk8z/MGonLTc57A34la/kfURI3oWoqo8wCLPm+AJrnoro+MOV/A7mnqmNc00ER9DPjkRDbecy3Ph6yXcwP46RYYNwlRqzpET7LI2slP7KET3nFiL+cn8PBcoIcFwB6qA/0MQPavgpb3HJmTggQ9pxAw1/4ZqlCAjqiVF+g9hKynwkS+Fg7QE/W7QB+KwHzISDRJ1EXA+VNH0QCh4KIERH2e5UQt4z6POVG/CyPq2ESNXBKiLuZ5XjyUqItpiLq4AaJ+F0jUxYBFXzxAk1x010fGfL7l01Rhr2mgibow0ENk473A8nzIermAYLq9AEwyaH2qDtGTLLJ2LrScqKWHFxJ4eAHQw4uYEDWyf11sec+RObmYoOdcQkR+lxAStfICvYeQ9XQpka+XGiDqd4BEfRnMhzijn/q+DJw/dVweIBR8OQFRX2E5Ucu4r2BO1O/AiDrD2Ke+r/Q8vyqUqK/UEPVVBoj6HSBRXwks+qsCNMlFd31kzFdbPk1d6jUNNFFfCvQQ2XivsTwfsl6uIZhugXGTELWqQ/Qki6yday0naunhtQQeXgP08DomRI3sXyUs7zkyJyUIes71ROR3PSFRKy/QewhZTzcQ+XqDAaIeAyTqG3Hv0MSZJOobwflTx00BQsE3ERD1zZYTtYz7ZuZEPQZH1BkauSREfYvneclQor5FQ9QlDRD1GCBR3wIs+pIBmuSiuz4y5lstn6Zu8JoGmqhvAHqIbLy3WZ4PWS+3EUy3wLhJiFrVIXqSRdbO7ZYTtfTwdgIPbwN6eAcTokb2rzst7zkyJ3cS9Jy7iMjvLkKiVl6g9xCynkoR+VrKAFGPBhL13bh5Mt4kUd8Nzp86nAChYIeAqF3LiVrG7TIn6tG4T32na+SSEHW053lMKFFHa4g6xgBRjwYSdTSw6GMCNMlFd31kzLGWT1OlvKaBJupSQA+RjTfO8nzIeokjmG6BcZMQtapD9CSLrJ14y4laehhP4GEc0MMEJkSN7F+JlvccmZNEgp4TICK/ACFRKy/QewhZT6WJfC1tgKjfBhJ1GZgPiUZ/PasMOH/qKBsgFFyWgKiTLCdqGXcSc6J+G0bUCcZ+PSvZ8zwllKiTNUSdYoCo3wYSdTKw6FMCNMlFd31kzEHLp6nSXtNAE3VpoIfIxlvO8nzIeilHMN0C4yYhalWH6EkWWTuplhO19DCVwMNyQA/TmBA1sn+Vt7znyJyUJ+g5FYjIrwIhUSsv0HsIWU8ViXytaICo3wISdSWmRF0JnD913BMgFHwPAVHfazlRy7jvZU7UbzEk6sqe51VCibqyhqirGCDqt4BEXRlY9FWYEDUy5vssn6Yqek0DTdQVgR4iG+/9ludD1sv9BNMtMG4SolZ1iJ5kkbXzgOVELT18gMDD+4EeVmVC1Mj+Vc3yniNzUo2g5zxIRH4PEhK18gK9h5D1VJ3I1+oGiHoUkKhrwHyIM/pd3zXA+VNHzQCh4JoERP2Q5UQt436IOVGPwv1ou7Hv+q7leV47lKhraYi6tgGiHgUk6lrAoq8doEkuuusjY65j+TRV3WsaaKKuDvQQ2Xgftjwfsl4eJphugXGTELWqQ/Qki6ydupYTtfSwLoGHDwM9rMeEqJH9q77lPUfmpD5Bz3mEiPweISRq5QV6DyHrqQGRrw0MEPVIIFE3xBF1lkmibgjOnzoaBQgFNyIg6nTLiVrGnc6cqEfiiDpGI5eEqDM8zzNDiTpDQ9SZBoh6JJCoM4BFnxmgSS666yNjzrJ8mmrgNQ00UTcAeohsvNmW50PWSzbBdAuMm4SoVR2iJ1lk7eRYTtTSwxwCD7OBHjZmQtTI/tXE8p4jc9KEoOc0JSK/poRErbxA7yFkPTUj8rWZAaJ+E0jUzWE+RBt9j7o5OH/qaBEgFNyCgKhbWk7UMu6WzIn6TRhRZxl7j7qV53nrUKJupSHq1gaI+k0gUbcCFn3rAE1y0V0fGXMby6epZl7TQBN1M6CHyMbb1vJ8yHppSzDdAuMmIWpVh+hJFlk77SwnaulhOwIP2wI9bM+EqJH9q4PlPUfmpANBz+lIRH4dCYlaeYHeQ8h66kTkaycDRD0CSNSdYT7ExJgk6s7g/Knj0QCh4EcJiLqL5UQt4+7CnKhHwIg6M0sjl4Sou3qedwsl6q4aou5mgKhHAIm6K7DouwVokovu+siYH7N8murkNQ00UXcCeohsvN0tz4esl+4E0y0wbhKiVnWInmSRtdPDcqKWHvYg8LA70MOeTIga2b8et7znyJw8TtBzehGRXy9ColZeoPcQsp56E/na2wBRDwcSdR+YD9lG36PuA86fOp4IEAp+goCon7ScqGXcTzIn6uEwonaNvUfd1/O8XyhR99UQdT8DRD0cSNR9gUXfL0CTXHTXR8bc3/JpqrfXNNBE3RvoIbLxPmV5PmS9PEUw3QLjJiFqVYfoSRZZO09bTtTSw6cJPHwK6OEzTIga2b+etbznyJw8S9BzniMiv+cIiVp5gd5DyHp6nsjX5w0Q9TAgUQ+A+RBrlKgHgPOnjhcChIJfICDqFy0nahn3i8yJehiMqDOMEfVLnucDQ4n6JQ1RDzRA1MOARP0SsOgHBmiSi+76yJhftnyaet5rGmiifh7oIbLxvmJ5PmS9vEIw3QLjJiFqVYfoSRZZO4MsJ2rp4SACD18BejiYCVEj+9erlvccmZNXCXrOa0Tk9xohUSsv0HsIWU9DiHwdYoCo3wAS9VCYDwkBk0Q9FJw/dbweIBT8OgFRv2E5Ucu432BO1G/AiDoxQSOXhKiHeZ4PDyXqYRqiHm6AqN8AEvUwYNEPD9AkF/46KjDmEZZPU0O8poEm6iFAD5GN903L8yHr5U2C6RYYNwlRqzpET7LI2hlpOVFLD0cSePgm0MNRTIga2b/esrznyJy8RdBz3iYiv7cJiVp5gd5DyHoaTeTraANE/TqQqMfg3qExStRjwPlTxzsBQsHvEBD1u5YTtYz7XeZE/TqMqGONEfVYz/NxoUQ9VkPU4wwQ9etAoh4LLPpxAZrkors+Mubxlk9To72mgSbq0UAPkY33PcvzIevlPYLpFhg3CVGrOkRPssjamWA5UUsPJxB4+B7Qw4lMiBrZv963vOfInLxP0HM+ICK/DwiJWnmB3kPIeppE5OskA0Q9FEjUk3HvUTsmiXoyOH/q+DBAKPhDAqL+yHKilnF/xJyoh8KIOuBo5JIQ9cee51NCifpjDVFPMUDUQ4FE/TGw6KcEaJKL7vrImKdaPk1N8poGmqgnAT1ENt5PLM+HrJdPCKZbYNwkRK3qED3JImvnU8uJWnr4KYGHnwA9/IwJUSP71+eW9xyZk88Jes4XROT3BSFRKy/QewhZT18S+fqlAaIeAiTqabh50jVJ1NPA+VPHVwFCwV8REPXXlhO1jPtr5kQ9BEbU8TkauSRE/Y3n+fRQov5GQ9TTDRD1ECBRfwMs+ukBmuSiuz4y5m8tn6a+9JoGmqi/BHqIbLzfWZ4PWS/fEUy3wLhJiFrVIXqSRdbO95YTtfTwewIPvwN6+AMTokb2rx8t7zkyJz8S9JyfiMjvJ0KiVl6g9xCynn4m8vVnA0T9GpCoZ+A+82j017NmgPOnjl8ChIJ/ISDqXy0nahn3r8yJ+jXcN5MZ+/Ws3zzPZ4YS9W8aop5pgKhfAxL1b8CinxmgSS666yNjnmX5NPWz1zTQRP0z0ENk4/3d8nzIevmdYLoFxk1C1KoO0ZMssnZmW07U0sPZBB7+DvRwDhOiRvavuZb3HJmTuQQ9Zx4R+c0jJGrlBXoPIetpPpGv8w0Q9atAol4A8yHb6HvUC8D5U8fCAKHghQREvchyopZxL2JO1K/ifj3L2HvUiz3Pl4QS9WINUS8xQNSvAol6MbDolwRokovu+siYl1o+Tc33mgaaqOcDPUQ23mWW50PWyzKC6RYYNwlRqzpET7LI2lluOVFLD5cTeLgM6OEKJkSN7F8rLe85MicrCXrOKiLyW0VI1MoL9B5C1tNqIl9XGyDqwUCiXgPzISfOJFGvAedPHWsDhILXEhD1OsuJWsa9jjlRD4YRtZOhkUtC1Os9zzeEEvV6DVFvMEDUg4FEvR5Y9BsCNMlFd31kzBstn6ZWe00DTdSrgR4iG+8my/Mh62UTwXQLjJuEqFUdoidZZO1stpyopYebCTzcBPRwCxOiRvavrZb3HJmTrQQ9ZxsR+W0jJGrlBXoPIetpO5Gv2w0Q9SAgUe+A+RAw+qnvHeD8qWNngFDwTgKi3mU5Ucu4dzEn6kG4v6M29qnv3Z7ne0KJereGqPcYIOpBQKLeDSz6PQGa5KK7PjLmvZZPU9u9poEm6u1AD5GNd5/l+ZD1so9gugXGTULUqg7RkyyydvZbTtTSw/0EHu4DeniACVEj+9dBy3uOzMlBgp5ziIj8DhEStfICvYeQ9XSYyNfDBoj6FSBRH8G9R230u76PgPOnjqMBQsFHCYj6D8uJWsb9B3OifgX3qW9j3/V9zPP8eChRH9MQ9XEDRP0KkKiPAYv+eIAmueiuj4w5qrTd09Rhr2mgifow0ENk4z3H8nzIepEa0dMtMG4SolZ1iJ5kkbWTh9hDJ7zjxF6WGtEe+msnXA/zgj1UB/oZgOxf+SzvOTIn+Qh6zrnAXPtnqHNL0xG18gK9h5D1lJ/I1/yerybp8uVEbCzqKFCaUHCB0vj7FgQ2Waq4C5Y+aTDoviTDhCzkggSbGLjxyPNtq4fIuAsxGSbyA2MubPkwIWMtRDBMFLF8+JZ5KULcc8L1sCjR4FD0PxgcBhINDueVJhR8HsHgUMzywUHGXYzJ4CALuRjBJgZuPPJ82+ohMu7iTAaHosCYz7d8cJCxFicYHC6wfHCQebmAuOeE6+GFRIPDhaXp38N/Cfge/kXAPWRyWLqoNM2wdHFpQsEXEwxLl1g+LMm4LzE0LDnhHe6Fnlb0W4cXAnOEzPellj9AZaO7lOABepnlD1AZ82UEcV9O9NCT9w39CAjaE+qcIfb4JQRDD3K/X2F53UsPryDw8FKgh1cyAS3kM+cqy58TMidXEfTLq4n65dWEb/cqL9B7CFlP1xDtIbSX14Bna3Wg9/rTQCC81hezmxgTHZ0QI/+7xCzHjc3KjE6Mjs7KiHUynfTM6OxArBvIiY2OjcnMyswQ90x3c5yc9MxATuKf9zIJhNcSAeF1pQkFX0cAhCUsB0IZdwkCIJTFJleeKPpiezqRpoGFehLuBvQX8vX+V6bQT8oSwAnB/6S8/l+elKfQnHkKc05slOvP4kl5KtOvB27AG4gmEHnfx8+yFlzhXabr5DiBaCfdSciMT8gIZEVnJKbnxOTExWTFnK2vpyp2pK83Evl649n7+v+iXm8i8vWm//F6vZnI15s9X9WD08Skhnx4+h/2t3hDRUn5zKB4wF1PMK1db/nLWme7OZwziDtcjbda/rKWLMxbCV6euI2oKdz2L83WCe9wSxJ5cTuRF7cTeiEbIYUX+arb3VOo9sO5/23cmafQR1b7+cFxqwP9V7zAunSBuXaR/slBKn+U/lWIqDP081T15L8nxTML5Yl/qLzj316FcMI73FuJHgJ3nP3r9e6p/nek5jsImkJhoqaQ7wxzdibDW7gx31nazgaDzIW/Lu/0DSdnm59TeY7Mz13+9xZiYsTeyEpwc7JyYuISAtEZbnxMfHxObE5CfGJsVk5cbHpWQrYbmx4THchOcHLcxOzshLiYzIT4nEBWZnyOv2m7WTExsVmBjEw3Ljo+PcNJzIpJd3JiE2IE8GfFJGRlxSTGx6fHxGTFJ+YkBgSkC/RPdOISEgJOfHRMIJoqP3f56Br1UDjVqzn+e3J5KJTi+FAoRfxQKEXwUChqyUPhH4s44cSXtOQgm87dlj4UihI1nbsBD4VTvbSJzI9j6UOBKj/O/6OXXF3vJddo3UuuTnjHP77fgXyvMtx7AV++JflklPIQ/YlmKg/DvVeM5fmQGyaG4MEeSzTkxBK+/BlN5EUckRdxxC8FU3hRzPKXgqn2Q3HLXwqmqv3zmbwUDKxLF5hr9/zIS8Ghx4lnFsoT/7AbT0n9MUQPgXhC6pea4wmawsVMXgqOAQ6CCaXtbDAXE1FlgoGXgpH5SQRS//lA6qfKT6ImP2f6mZpTvfSLzE+AqH8GAD6c6tUppA+liXwozaweyhD5UIZZPZQl8qHsabxVZPNgp5ELq2P/0JjEcWhMIh4akwiGxksNDY1hfioe2uSSgfdCDo2XEg0lyacxNIb76XpkflJK4wY95NBIlZ8UwMPxFIf7AfBvR4Ow/plI8kHsEt6rbuh3lJA1Xs7ydzBkjssRPG9SiZ698r4Fvf97TNTfD9T/prof2u/aeezXmIYeJLkU7eWWv70iY04jiPsKS15RPMWRqzDDjbk8sDED68ZF5oK4Sf71NsX/YpMs/7/aJCtY/ud5MuYKBHFXJJpoKpY++W1rFH/uqZuQnfAOFzkhV7K8niRRVSKop3sY7KN7COK+l2gf3fsv+8gJ7yDrKVdX/9+sgWsMfa4lXJ2VgUMiMNfuNUSvUFWO0DW5xirUgyOCMqsQbPoSTCizCoNNH/aHtJk04PuAuQDWn3t9hNJZNNv7kM2W61OxUhH7Nd4fSZTjPsJgRz0QSZTjVmawo6pGEiX6P4NEVYskSrQVBol6MJIoUa0MElU9kihhAoNE1YgkynFrMkhUzUiiHLcWg0Q9FEmU49ZhkKhakUQ5bl0GiaodSZTj1meQqDqRRDluAwaJejiSKMdtxCBRdSOJctzxDF6UrRdJlONmMthR9SOJctxsBol6JJIox23MIFENIoly3KYMEtUwkijHbc4gUY0iiXLclgwSlR5JlOO2ZpCojEiiHLctg0RlRhLluO0ZJCorkijH7cggUdmRRDluZwaJyokkynG7MEhU40iiHLcbg0Q1iSTKcbszSFTTSKIctyeDRDWLJMpxezFIVHNkouR3aBaIOvm3ZVLs9SFJywMOAPglFy76D/0pEnY/A40PMNBYlYHGagw0PshAY3UGGmsw0FiTgcaHGGisxUBjbQYa6zDQ+DADjXUZaKzHQGN9BhofYaCxAQONDRlobMRAYzoDjRkMNGYy0JjFQGM2A405DDQ2ZqCxCQONTRlobMZAY3MCjVFQjTEJUZoDc+9ol+7eJ3+Z/BzfPVsIv1uK1Uqs1mK1EautWO3Eai9WB7E6itVJrM5iPSpWF7G6itVNrMfE6i5WD7F6ivW4WL3E6i1WH7GeEOtJsfqK1U+s/mI9JdbTYj0j1rNiPSfW82INEOsFsV4U6yWxBor1sliviDVIrMFivSrWa2INEWuoWK+L9YZYw8QaLtYIsd4Ua6RYo8R6S6y3xRot1hix3hHrXbHGijWu9J8ejC/tmaK+tVGaUjDkWkvNtVaaa60119porrXVXGunudZec62D5lpHzbVOmmudNdce1VzrornWVXOtm+baY5pr3TXXemiu9dRce1xzrZfmWm/NtT6aa09orj2pudZXc62f5lp/zbWnNNee1lx7RnPtOc215zXXBmiuvaC59qLm2kuaawM1117WXHtFc22Q5tpgzbVXNdde01wbork2VHPtdc21NzTXhmmuDddcG6G59qbm2kjNtVGaa29prr2tuTZac22M5to7mmvvaq6N1Vwbp7kmm1+JqNwH+ksn/W/+WfQt326L0jTDRh6wf8A3E92WTGIGvjnptmISM/DNTrc1k5iBb566bZjEDHwz1m3LJGbgm7tuOyYxA98sdtsziRn45rPbgUnMwDez3Y5MYga+Oe52YhIz8M12tzOTmIFv3ruPMokZ+GEAtwuTmIEfLnC7MokZ+GEFtxuTmIEffnAfYxIz8MMUbncmMQM/nOH2YBIz8MMebk8mMQM/POI+ziRm4IdR3F5MYgZ+uMXtzSRm4Idl3D5MYgZ++MZ9gknMwA/zuE8yiRn44SC3L5OYgR82cvsxiRn44SW3P5OYgR+Gcp9iEjPww1Xu00xiBn5Yy32GKOZzQmJ2wjvcZwHvZWfnyCMzXf4hbkFfXs7x6aTST/GeN1pj5I9n/zyc8I7IH8+CNEb+eBajMfLHsxiNkT+exWiM/PEsRmPkj2cxGiN/PIvRGPnjWYzGyB/PYjRG/ngWozHyx7MYjZE/nsVojPzxLEZj5I9nMRo5/vEs5r6JZJ4+zyDvAxhofIGBxhcZaHyJgcaBDDS+zEDjKww0DmKgcTADja8y0PgaA41DGGgcykDj6ww0vsFA4zAGGocz0DiCgcY3GWgcyUDjKAYa32Kg8W0GGkcz0DiGgcZ3GGh8l4HGsQw0jiN8nQ+nMzpa97nG94T2CWJNFOt9sT4Qa5JYk8X6UKyPxPpYrCliTRXrE7E+FeszsT4X6wuxvhRrmlhfifW1WN+INV2sb8X6TqzvxfpBrB/F+kmsn8WaIdYvYv0q1m9izRRrlli/izVbrDlizRVrnljzxVog1kKxFom1WKwlYi0Va5lYy8VaIdZKsVaJtVqsNWKtFWudWOvF2iDWRrE2ibVZrC1ibS39pwfbSkfl/hImaUroFzNN0FybqLn2vubaB5prkzTXJmuufai59pHm2seaa1M016Zqrn2iufap5tpnmmufa659obn2pebaNM21rzTXvtZc+0Zzbbrm2reaa99prn2vufaD5tqPmms/aa79rLk2Q3PtF821mZprszTXftdcm625Nkdzba7m2jzNtfmaaws01xZqri3SXFusubZEc22p5toyzbXlmmsrNNdWaq6t0lxbrbm2RnNtrebaOs219ZprGzTXNmqubdJc26y5tkVzbavmmmx0JaJyH+qhEPT+Ge4fIQA/0O6+V5rmwYqOGfmFcBOYxIz8QriJTGJGfiHc+0xiRn4h3AdMYkZ+IdwkJjEjvxBuMpOYkV8I9yGTmJFfCPcRk5iRXwj3MZOYkV8IN4VJzMgvhJvKJGbkF8J9wiRm5BfCfcokZuQXwn3GJGbkF8J9ziRm5BfCfcEkZuQXwn3JJGbkF8JNYxIz8gvhvmISM/IL4b5mEjPyC+G+YRIz8gvhpjOJGfmFcN8yiRn5hXDfMYkZ+YVw3zOJGfmFcD8wiRn5hXA/MokZ+YVwPzGJGfmFcD8ziRn5hXAzmMSM/EK4X4hiPickZie8w/21dPj+qS+Eo9T5G0xnoktZQ8A/uHRnMtk3wD/gdGcxiRn4B6Hu70xiBv6BqTubSczAP1h15zCJGfgHsO5cJjED/6DWncckZuAf6LrzmcQM/INfdwGTmIF/QOwuZBIz8A+S3UVMYgb+gbO7mEnMwD+YdpcwiRn4B9juUiYxA/+g213GJGbgH4i7y5nEDPyDc3cFk5iBf8DurmQSM/AP4t1VTGIG/oG9u5pJzMA/2HfXMIkZ+AUA7lomMQO/UMBdxyRm4BcUuOuZxAz8wgN3A5OYgV+g4G5kEjPwCxncTUxiBn7Bg7uZSczAL4xwtzCJGfgFFO5WYMzyB7UKRf3598fyOMcXc5Tvmt8LJ7wj8oNaII2RH9TCaIz8oBZGY+QHtTAaIz+ohdEY+UEtjMbID2phNEZ+UAujMfKDWhiNkR/UwmiM/KAWRmPkB7UwGiM/qIXRGPlBLYzGyA9qYTRGflALcd/ID2pRaIz8oBZGY+QHtTAaIz+ohdEY+UEtjMbID2phNEZ+UAujMfKDWhiNkR/UwmiM/KAWRmPkB7UwGiM/qIXRGPlBLYzGyA9qYTRGflALo5HLD2oR3ts9x+etuud24csOsXaKtUus3WLtEWuvWPvE2i/WAbEOinVIrMNiHRHrqFh/iHVMrONiRZUR9xUrj1h5xcon1rli5RergFgFxSokVmGxiohVVKzzxComVnGxzhfrArEuFOsisS4W6xKxLhXrMrEuF+sKsa4U6yqxrhbrGrGuFes6sUqIdb1YN4h1o1g3iXWzWLeIVVKsW8W6TazbxbpDrDvFuqtMVO4fs5FmhP7AzQ7NtZ2aa7s013Zrru3RXNurubZPc22/5toBzbWDmmuHNNcOa64d0Vw7qrn2h+baMc2145prslhCr52juZZHcy2v5lo+zbVzNdfya64V0FwrqLlWSHOtsOZaEc21oppr52mu3aK5VlJz7VbNtds0127XXLtDc+1OzbW7vGv+I4/3z6D3T5t+2Gk7kw/WI3/YaQeTmJE/7LSTSczIH3baxSRm5A877WYSM/KHnfYwiRn5w057mcSM/GGnfUxiRv6w034mMSN/2OkAk5iRP+x0kEnMyB92OsQkZuQPOx1mEjPyh52OMIkZ+cNOR5nEjPxhpz+YxIz8YadjTGJG/rDTcSYxI3/YSb72xiFm5A87ncMkZuQPO+VhEjPyh53yMokZ+cNO+ZjEjPxhp3OZxIz8Yaf8TGJG/rBTASYxI3/YqSCTmJE/7FSISczIH3YqzCRm5A87FWESM/KHnYoyiRn5w07nEcWM/lBQsTLh+2fih52Kw3Tm/mEntM7zmeT9AiY6L2Si8yImOi9movMSJjovZaLzMiY6L2ei8womOq9kovMqJjqvZqLzGiY6r2Wi8zomOksw0Xk9E503MNF5IxOdNzHReTORznzh6nRz/5+3hKcz191Khhuz7263AnhdvS5zU3VLc+Hkjvo2RM14d7sdU38n7nYHMBc3250LR0V9J27/uncB7wWsZdefi7BeE8vOCcgfFTgv6uRrqiS5Ia5tJ5zD3pqh+GPLv3qWP9+lyvz5z7tD/yhQ/ovlIdfkf1QiKlIo4TbUWzk01JCCPsuYo72Y3VJA/+4GblqqXOQB5wLpn6O5V4aTmRXnZsRnJbjZ6XGJmZmBGNeNTo9Pj8+ITszJzohzE+MSxT0z06MTxf9cdHqmm+2kx2fLh0jRqJPDuP9AD+gOsMH69bplCAXLm6PvGw0sBqq4o8ucNBh0X61WRDORWlEbVt0XmaMYcOGrB7q87/XinyYnwVuAD/iSwAf8rcCHym1laB4qoP2knQRjvf0aFzoJxmomwTjKSdATeRtw+ogFbsY4372is+KynUBiRmJ0RnpMQkZsTEYgkC7uG++6iTlZ0U5WbHROnBsfnxnIDuS4MTkZcdnp8XHpgfisE0/PrJuYTB9I/+KZTh/xRNNHQhlCwQkE00ei5dOHjDuRyfQR52lFTx/IHAWIpo/AfzB9gD7LeuJusM+IutjPXlJ+uT8gF9rpo7S3X8uETh+lNdNHGQOvQ3EolHA39u1MXodqXho3CZYGNsYyQGS4nckkiPSvLNNJsCzRJJhUhlBwEsEkmGz5JCjjTmYyCZbxtKInQWSOUogmwZT/YBLMAj7gs4EPeORf1TVmOAkGvf1aLnQSDGomwXIGJkEOhRLuxr6TySTYGDgJBoGNsRxwEryTySSI9C+V6SSYSjQJppUhFJxGMAmWt3wSlHGXZzIJlvO0oidBZI4qEE2CFf6DSbAR8AGfDnzAI78vJZPhJFjR26+VQifBippJsJKBSZBDoYS7sUsxmQQzgZNgRWBjrAScBEsxmQSR/t3DdBK8h2gSvLcMoeB7CSbBypZPgjLuykwmwUqeVvQkiMxRFaJJsMp/MAnWBz7gHwE+4JHfhNmQ4SR4n7df7w+dBO/TTIL3G5gEORRK2J8SZzIJNgROgvcBG+P9wEnQYTIJIv17gOkk+ADRJFi1DKHgqgSTYDXLJ0EZdzUmk+D9nlb0JIjM0YNEk+CD/8EkWAf4gH8Y+IBH/sZBPYaTYHVvv9YInQSraybBGgYmQQ6FEu7GjmYyCdYDToLVgY2xBnASjGYyCSL9q8l0EqxJNAk+VIZQ8EMEk2AtyydBGXctJpNgDU8rehJE5qg20SRY+z+YBGsCH/APAR/wyF+vq81wEqzj7deHQyfBOppJ8GEDkyCHQgl3Y8cymQRrAyfBOsDG+DBwEoxlMgki/avLdBKsSzQJ1itDKLgewSRY3/JJUMZdn8kk+LCnFT0JInP0CNEk+Mh/MAlWAz7gHwQ+4JG/S16D4STYwNuvDUMnwQaaSbChgUmQQ6GE/S0eTCbBGsBJsAGwMTYEToLxTCZBpH+NmE6CjYgmwfQyhILTCSbBDMsnQRl3BpNJsKGnFT0JInOUSTQJZpqcBL2H8v3Ah/IDwOmtamncENOC4SSY5e3X7NBJMEszCWZTToKMCiXcjZ1o+ySoKehwJ8EsYGPMBk6CiUwmQaR/OUwnwRyiSbBxGULBjQkmwSaWT4Iy7iZMJsFsTyt6EkTmqCnRJNjUmwTl+WVRuR/y/pd+/G8I+j8m5v/jAf+flPq/aESel/Gd9yp68rx2nrM/j/Pd827feW/f/fv4zp/wnT/pO+/rO+/nO+/vO3/KO28m/neai9VCrJZitRKrtVhtxGpb5u+TNHpftQXWgRoW2ol7therg1gdvSnQXyPy3xeMyn2tveZaB821jt41/4F+uaotcJ+1A9zrz99Pdtz2QF2liYaUvCG5CCdmmYsOEP/+zGtH4JCH9I96j7ch2OOdxD07i/WoWF00e7yTZu921lx7VHOti4E93ga4lzoB93hnoK6yTPb4o8A93gW4x8sy2uOtCfZ4V3HPbmI9JlZ3zR7vqtm73TTXHtNc625gj7cG7qWuwD3eDagrmckefwy4x7sD93gyoz3eimCP9xD37CnW42L10uzxHpq921Nz7XHNtV4G9ngr4F7qAdzjPYG6gkz2+OPAPd4LuMeDjPZ4S4I93lvcs49YT4j1pGaP99bs3T6aa09orj1pYI+3BO6l3sA93geoK5XJHn8CuMefBO7xVEZ7vAXBHu8r7tlPrP5iPaXZ4301e7ef5lp/zbWnDOzxFsC91Be4x/sBdZVnssf7A/f4U8A9Xp7RHm9OsMefFvd8RqxnxXpOs8ef1uzdZzTXntVce87AHm8O3EtPA/f4M0BdFZns8WeBe/w54B6vyGiPNyPY48+Lew4Q6wWxXtTs8ec1e3eA5toLmmsvGtjjzYB76XngHh8A1HUPkz3+AnCPvwjc40j/1J4e4f1T/t+rbz1Z+6t85yt95yt858t958t850t950t854t954t85wt95wt85/N95/N853N953N857N957/7zmf5zmf6zn/znf/qO//Fdz7Dd/6z7/wn3/mPvvMffOff+86/851/6zuffuvJ3hIE5TZyv8j9IveL3C9yv8j9IveL3I/X/WKysPfLTsDeLzEae7/4gJoFW91+ci5s6Ttv4Ttv7jtv5jtv6jtv4jtv7DvP8Z1n+86zfOeZvvMM33m677yR77yh77yB7/wR33l933k933ld3/nDvvM6vvPavvNavvOHfOc1fec1fOfVfecP+s6r+c6r+s4P33Hy/JDv/KDv/IDvfL/vfJ/vfK/vfI/vfLfvfJfvfKfvfIfvfLvvfJvvfKvvfIvvfLPvfJPvfKPvfIPvfL3vfJ3vfK3vfI3vfLXvfJXvfKXvfIXvfLnvfJnvfKnvfInvvO9dJ8+f9J0/4Tvv4zvv7Tvv5Tt/3Hfe03few3fe3Xf+mO+8m++8q++8i+/8Ud95Z995J995R995B995e995O995W995G995a995K995S995C995c995M995U995E995Y7+Hvte+/J9L8X9uxf+5lu6+c/9n1fyfZfN/1q2L79z/+VX/51v9n3/t6Dv3f6bd/5l3/2fiX/Sd+1/H87/O538d8Dnfuf+1ff9r//73Bp7ynfvf7/O/H+h/v/BJ37n/MwD+zwiozxC8H/Xn8ZL4vweK9bJYr4g1SKzBYr0q1mtiDRFrqFivi/WGWMPEGi7WCLHeFGukWKPEekust8UaLdYYsd4R612xxoo1TqzxYr0n1gSxJor1vlgfiDVJrMlifSjWR2J9LNYUsaaK9YlYn4r1mVifi/WFWF+KNU2sr8T6WqxvxJou1rdifSfW92L9INaPYv0k1s9izRDrF7F+Fes3sWaKNUus38WaLdYcseaKNU+s+WItEGuhWIvEWizWErGWirVMrOVirRBrpVirxFot1hqx1oq1Tqz1Ym0Qa6NYm8TaLNYWsbaKtU2s7WLtEGunWLvE2i3WHrH2irVPrP1iHRDroFiHxDos1hGxjor1h1jHxDouVlRZkU+x8oiV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",
  "debug_symbols": "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Uc/pseOwY4sd9ZweO+o5PXbUc3rsqOf02FHPabHjVc9p8dzqquf02FHP6bGjntNjx2HHFt9z9JweO+o5PXbUc3rsqOf02FHPabHjTc/psaOe02NHPafHjnpOjx2HHVvsqOf02FHP6bGjntNjRz2nxXOrm57TYse7ntNjRz2nx456TovvOXc9p8eOw44tdtRzeuyo5/TYUc/psaOe02NHPafFjg89p8eOek6PHfWcHjvqOT12HHZssaOe02NHPafFc6uHntNjRz2nx456Tocd7yc9p8P3nPtJz+mxo57TY0c9p8eOw44tdtRzeuyo5/TYUc/psaOe02NHPafFjmc9p8eOek6PHfWcHjvqOT12HHbs8NzqrOf02FHP6bGjntNjRz2nx/ccPafFjpue02NHPafHjnpOjx31nB47Dju22FHP6bGjntNjRz2nx456To8d9ZwWO+56To8d9ZweO+o5LZ5b7XpOjx2HHVvsqOf02FHP6fE9R8/psaOe02NHPafFjkPP6bGjntNjRz2nx456To8dhx1b7Kjn9NhRz+mxo57TY0c9p8eOek6LHS96TovnVhc9p8eOek6PHfWcHjsOO7b4nqPn9NhRz+mxo57TY0c9p8eOek6LHa96To8d9ZweO+o5PXbUc3rsOOzYYkc9p8eOek6PHfWcHjvqOS2eW131nBY73vScHjvqOT121HNafM+56Tk9dhx2bLGjntNjRz2nx456To8d9ZweO+o5LXa86zk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5LZ5b3fWcHjvqOT121HNa7PjQc1p8z3noOT121HN67Kjn9Nhx2LHFjnpOjx31nB476jk9dtRzeuyo53TY8XHSc3rsqOf02FHP6bGjntNjx2HHBs+tHic9p8eOek6PHfWcHjvqOT2+5+g5LXY86zk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5PXbUc3rsqOf02FHPabHjpuf02FHP6bGjntPiudWm5/TYcdixxY56To8d9Zwe33P0nB476jk9dtRzWuy46zk9dtRzeuyo5/TYUc/pseOwY4sd9ZweO+o5PXbUc3rsqOf02FHPabHj0HNaPLcaek6PHfWcHjvqOT12HHZs8T1Hz+mxo57TY0c9p8eOek6PHfWcFjte9JweO+o5PXbUc3rsqOf02HHYscWOek6PHfWcHjvqOT121HNaPLe66DktdrzqOT121HN67KjntPiec9Vzeuw47NhiRz2nx456To8d9ZweO+o5PXbUc1rseNNzeuyo5/TYUc/psaOe02PHYccWO+o5PXbUc1o8t7rpOT121HN67KjntNjxrue0+J5z13N67Kjn9NhRz+mx47Bjix31nB476jk9dtRzeuyo5/TYUc9pseNDz+mxo57TY0c9p8eOek6PHYcdOzy3eug5PXbUc3rsqOf02FHP6fE9R89psON+Ouk5PXbUc3rsqOf02FHP6bHjsGOLHfWcHjvqOT121HN67Kjn9NhRz2mx41nP6bGjntNjRz2nwXOrbzvqOT12HHZssaOe02NHPafH9xw9p8eOek6PHfWcFjtuek6PHfWcHjvqOT121HN67Djs2GJHPafHjnpOjx31nB476jk9dtRzWuy46zktnlvtek6PHfWcHjvqOT12HHZs8T1Hz+mxo57TY0c9p8eOek6PHfWcFjsOPafHjnpOjx31nB476jk9dhx2bLGjntNjRz2nx456To8d9ZwWz62GntNix4ue02NHPafHjnpOi+85Fz2nx47Dji121HN67Kjn9NhRz+mxo57TY0c9p8WOVz2nx456To8d9ZweO+o5PXYcdmyxo57TY0c9p8Vzq6ue02NHPafHjnpOix1vek6L7zk3PafHjnpOjx31nB47Dju22FHP6bGjntNjRz2nx456To8d9ZwWO971nB476jk9dtRzeuyo5/TYcdixw3Oru57TY0c9p8eOek6PHfWcHt9z9JwWOz70nB476jk9dtRzeuyo5/TYcdixxY56To8d9ZweO+o5PXbUc3rsqOd02PF80nN67Kjn9NhRz+nw3Op80nN67Djs2GJHPafHjnpOj+85ek6PHfWcHjvqOS12POs5PXbUc3rsqOf02FHP6bHjsGOLHfWcHjvqOT121HN67Kjn9NhRz2mx46bntHhutek5PXbUc3rsqOf02HHYscX3HD2nx456To8d9ZweO+o5PXbUc1rsuOs5PXbUc3rsqOf02FHP6bHjsGOLHfWcHjvqOT121HN67KjntHhutes5LXYcek6PHfWcHjvqOS2+5ww9p8eOw44tdtRzeuyo5/TYUc/psaOe02NHPafFjhc9p8eOek6PHfWcHjvqOT12HHZssaOe02NHPafFc6uLntNjRz2nx456Tosdr3pOi+85Vz2nx456To8d9ZweOw47tthRz+mxo57TY0c9p8eOek6PHfWcFjve9JweO+o5PXbUc3rsqOf02HHYscNzq5ue02NHPafHjnpOjx31nB7fc/ScFjve9ZweO+o5PXbUc3rsqOf02HHYscWOek6PHfWcHjvqOT121HN67KjntNjxoef02FHP6bGjntPiudVDz+mx47Bjix31nB476jk9vufoOT121HN67KjndNhxO+k5PXbUc3rsqOf02FHP6bHjsGOLHfWcHjvqOT121HN67Kjn9NhRz2mx41nP6fDcajvrOT121HN67Kjn9Nhx2LHF9xw9p8eOek6PHfWcHjvqOT121HNa7LjpOT121HN67Kjn9NhRz+mx47Bjix31nB476jk9dtRzeuyo57R4brXpOS123PWcHjvqOS0+H3c9p8eOek6PHYcdW+yo5/TYUc/psaOe08M79JweO+o5LXYcek6Lz8eh5/TYUc/psaOe02PHYccWO+o5PXbUc3p4h57TY0c9p8eOek6LHS96TovvORc9p8eOek6PHfWcHjsOO7bYUc/psaOe02NHPafHjnpOjx31nBY7XvWcHjvqOV9jx/t2f+54308/76jnvGzH89if7fvbeNdPlrzu2/ntlx7jxyV/Rfn6nP0b8O+/9ParX3nfz4/nD+/b5ccf/uNGtCI38tmNDDfiRj65EY3LjXx2I/qZGxnjyXkfl/vPN6LNuZHPbkT3cyPj9rbJeGwf//D2uL/9yqfT6ZMfHpcnum3c7h//8OX0hnk//yzgwqZD/QqHelNuHepvPNTH81feLtupdKjStEP9EoeqvTvU33eot/2JY7vdLp/88Gk8/wK303WUrtrTAlfd76qHq3bVB7nq2zOhb+fTVrpqT2Rcdb+r9gzJVf+Vq95P23i76v2TX3nb729XPU77jz/8x/V5OuX6ft/1TQy6HpE51C9xqB6ROdSvcKh3j8gc6m881GlPHu4ekTnUL3GoHpE51N93qNe349uuP17fnyp/9yjL9b3u+obrc30vuz6Phlzf667PIxzX9/uu7688mDzf3+Y+P84/P++5e97jVL/IqXri41SPcaoT/9W8u8dDrrrdVT88S3LV/a7agydXfZSrnvYvnD48pXLV/a7a0y9X/Zeu+vz2Z4bu573YKh7D9bm+l12fp1+u77dd30yh8qDMoX6JQ/WYzKF+iUP1kMyh/sZDnefnnns51C9wqPvJoyyHernszx++XD/5r+z+2p8y8fF/j7+fPHJyfb/v+qb916Pfngk4VIf6FQ7VgyGH+iUOdThUh/r7DnXWf+a8nzxucqhf4lA9bnKov+9QP/6vAveTZ0iu73XX58GQ63vd9Xna4/pedn1nj3Bc3++7von/kfN+9rzHqX6RU/XEx6ke41Tn/Qt0+9njIVfd76qHq3bV7a7agydXfZSrnvYvnJ49pXLV/a7a0y9X/Veu+kWvQdnPHpQ51C9xqJ6pOdTfeKjT/rWrzeM3h/olDtXDN4f6+w71RZVs85zOVfe7as/pXPVRrnpaJduGq3bV7a7aczpX/ZeueuKfhrlvnqe5vtddn+deru+3Xd9MofLcy6F+iUP13MuhfoVD3T33cqi/8VCn+fnuuZdD/RKH6lHW6w71/jbN+b6d/+lQ/xjHE5kDjzOMc9xx9PEDjyMfH2Oc8/jFOOrqgcdRFA88jop23HGGcnTgcdSS435bGwrBgcdRCA48zjDOccdRCA48jkJw4HEUggOPoxAceByF4LjjXBSCA4+jEBx4HIXgkP+yyx/jKAQHHmcY57jjKAQHHkchOPA4CsHUcW7j+Vu+n0+fjHM9Pf/V0Ov2/VHb/u33+8c0+sBhp1EHjjrNVRs47DTKwGGn0QUOO40qcNhphmmOOo0icNhp9IDDTqMGHHYaNeCw06gBR53mpgYcdho14LDTqAGHnUYNOOw0wzRHnUYNOOw0asBhp1EDDjuNGnDYadSAo05zVwMOO40acNhp1IDDTqMGHHaaYZqjTqMGHHYaNeCw06gBh51GDTjsNGrAUad5qAGHnUYNOOw0asBhp1EDDjvNMM1Rp1EDDjuNGnDYadSAw06jBhx2GjXgoNOMkxpw2GnUgMNOowYcdho14LDTDNMcdRo14LDTqAGHnUYNOOw0asBhp1EDjjrNWQ047DRqwGGnUQMOO40acNhphmmOOo0acNhp1IDDTqMGTJ3m/tifv+6nL3zYrs9fd/sBxd//n/3it/AkcTnfPvnR0/X5zolv37+vP/7wH4uLDKstrl0stvgmiay2uNKy2uICzmqL60KrLT4svtjiKtZqi4tjqy2uua22uOa22uKa22KL75rbaotrbqstrrmttrjmttriw+KLLa65rba45rba4prbaotrbqstrrkttvjQ3FZbXHNbbXHNbbXFNbfVFh8WX2xxzW21xTW31RbX3FZbXHNbbXHNbbHFL5rbaotrbqstrrmttrjmttriw+KLLa65rba45rba4prbaotrbqstrrkttvhVc1ttcc1ttcU1t9UW19xWW3xYfLHFNbfVFtfcVltcc1ttcc1ttcU1t8UWv2luqy2uua22uOa22uKa22qLD4svtrjmttrimttqi2tuqy2uua22uOa22OJ3zW21xTW31RbX3Lotvt2fv+zYx/bxD2/n8/P3u53H+Pk8BDrn8cF5DOfhPN4/D+nPeXxwHjqh8/jgPERF5/HBeSiQzuOD85Arncf75/HQNp3HB+chhDqPD85DNXUeH5yHauo8PjiP4Tycx/vnoZo6jw/OQzV1Hh+ch2rqPD44D9XUeXxwHqqp83j3PC4n1dR5fHAeqqnz+OA8VFPn8cF5qKbO44PzGM7Debx/Hqqp8/jgPFRT5/HBeaimzuOD81BNnccH56GaOo/3z+OsmjqPD85DNXUeH5yHauo8PjgP1dR5fHAew3k4j/fPQzVtdh6X7f78S7vs2+XnxYXQ1RbXNldbXK5cbXEFcrHFN1FxtcV1wtUWl/5WW1zNW23xYfHFFtfcVltcc1ttcc1ttcU1t9UW19wWW3zX3FZbXHNbbXHNbbXFNbfVFh8WX2xxzW21xTW31RbX3FZbXHNbbXHNbbHFh+a22uKa22qLa26rLa65rbb4sPhii2tuqy2uua22uOa22uKa22qLa26LLX7R3FZbXHNbbXHNbbXFNbfVFh8WX2xxzW21xTW31RbX3FZbXHNbbXHNbbHFr5rbaotrbqstrrmttrjmttriw+KLLa65rba45rba4prbaotrbqstrrkttvhNc1ttcc1ttcU1t9UW19xWW3xYfLHFNbfVFtfcVltcc1ttcc1ttcU1t26LfzPu589eHo+fFr9rbqstrrmttrjmttrimttqiw+LL7a45rba4prbaotrbqstrrmttrjmttjiD81ttcU1t9UW19xWW1xzW23xYfHFFtfcVltcc1ttcc1ttcU1t9UW19zWWvx60txWW1xzW21xzW21xTW31RYfFl9scc1ttcU1t9UW19xWW1xzW21xzW2xxc+a22qLa26rLa65rba45rba4sPiiy2uua22uOa22uKa22qLa26rLa65Lbb4prmttrjmttrimttqi2tuqy0+LL7Y4prbaotrbqstrrmttrjmttrimttii++a22qLa26rLa65rba45rba4sPiiy2uua22uOa22uKa22qLa26rLa65Lbb40NxWW1xzW21xzW21xTW3Zotft3H+82e/PSfbf158WHyxxTW31RbX3FZbXHNbbXHNbbXFNbfFFr9obqstrrmttrjmttrimttqiw+LL7a45rba4prbaotrbqstrrmttrjmttjiV81ttcU1t9UW19xWW1xzW23xYfHFFtfcVltcc1ttcc1ttcU1t9UW19wWW/ymua22uOa22uKa22qLa26rLT4svtjimttqi2tuqy2uua22uOa22uKa22KL3zW31RbX3FZbXHNbbXHNbbXFh8WbLf7tJ56LX8b4eXHNbbXFNbfVFtfcVltcc1ttcc1tscUfmttqi2tuqy2uua22uOa22uLD4ostrrmttrjmttrimttqi2tuqy2uua21+O2kua22uOa22uKa22qLa26rLT4svtjimttqi2tuqy2uua22uOa22uKa22KLnzW31RbX3FZbXHNbbXHNbbXFh8UXW1xzW21xzW21xTW31RbX3FZbXHNbbPFNc1ttcc1ttcU1t9UW19xWW3xYfLHFNbfVFtfcVltcc1ttcc1ttcU1t8UW3zW31RbX3FZbXHNbbXHNbbXFh8UXW1xzW21xzW21xTW31RbX3FZbXHNbbPGhuXVb/H57/rLXx+n68+Ka22qLa26rLa65dVv8sZ3eFr+cPv7h+74/f+H7frl+8sPjyex+3X++pOGSXNKUS9IIXdKcS9IeXdKcS9I0XdKcS9JKXdKcS9JgXdKUS7pouy5pziVpxi5pziVp0S5pziVp3C5pziUNl+SSplySxu2S5lySxu2S5lySxu2S5lySxu2S5lySxu2SplzSVeN2SXMuSeN2SXMuSeN2SXMuSeN2SXMuabgklzTlkjRulzTnkjRulzTnkjRulzTnkjRulzTnkjRulzTlkm4at0uac0kat0uac0kat0uac0kat0uac0nDJbmkKZekcbukOZekcbukOZekcbukOZekcbukOZekcbukKZd017hd0pxL0rhd0pxL0rhd0pxL0rhd0pxLGi7JJU25JI3bJc25JI3bJc25JI3bJc25JI3bJc25JI3bJU25pIfG7ZLmXJLG7ZLmXJLG7ZLmXJLG7ZLmXNJwSS5pyiVp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4dbbXIdbb/Nh8+U21+HW21yHW29zHW69zXW49TbX4ZbbfOhw622uw623uQ633uY63HqbD5svt7kOt97mOtx6m+tw622uw623uQ633OYXHW69zXW49TbX4dbbXIdbb/Nh8+U21+HW21yHW29zHW69zXW49TbX4Zbb/KrDrbe5Drfe5jrcepvrcOttPmy+3OY63Hqb63Drba7Drbe5Drfe5jrccpvfdLj1Ntfh1ttch1tvcx1uvc2HzZfbXIdrt/l1G+c/f/a6n/afN9fh1ttch1tvcx1uvc11uOU2v+tw622uw623uQ633uY63HqbD5svt7kOt97mOtx6m+tw622uw623uQ633OYPHW69zXW49TbX4dbbXIdbb/Nh8+U21+HW21yHW29zHW69zXW49TbX4Vbb/HLS4dbbXIdbb3Mdbr3Ndbj1Nh82X25zHW69zXW49TbX4dbbXIdbb3MdbrnNzzrcepvrcOttrsOtt7kOt97mw+bLba7Drbe5Dtdv828/8dz8MsbPm+tw622uw623uQ633OabDrfe5jrcepvrcOttrsOtt/mw+XKb63Drba7Drbe5Drfe5jrcepvrcMttvutw622uw623uQ633uY63HqbD5svt7kOt97mOtx6m+tw622uw623uQ633OZDh1tvcx1uvc11uPU21+HW23zYfLnNdbj1Ntfh1ttch1tvcx1uvc11uOU2v+hw622uw623uQ633uY63HqbD5svt7kOt97mOtx6m+tw622uw623uQ633OZXHW69zXW49TbX4dbbXIdbb/Nh8+U21+HW21yHW29zHW69zXW49TbX4Zbb/KbDrbe5Drfe5jpcv83vt+cve32crj9vrsOtt/mw+XKb63D9Nn9sp7fNL6ePf/i+789f+L5frp/88HiOd7/+/B7Wm77nlmbdkm7olmbdkh7plmbdks7plibd0l0/dUuzbkmXdUuzbknvdUuzbklHdkuzbmm4Jbc06ZZ0b7c065Z0b7c065Z0b7c065Z0b7c065Z0b7c06ZYeurdbmnVLurdbmnVLurdbmnVLurdbmnVLwy25pUm3pHu7pVm3pHu7pVm3pHu7pVm3pHu7pVm3pHu7pTm3dD3p3m5p1i3p3m5p1i3p3m5p1i3p3m5p1i0Nt+SWJt2S7u2WZt2S7u2WZt2S7u2WZt2S7u2WZt2S7u2WJt3SWfd2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p8+Wuk+fLXWfNlvedZ8+W+o+fbbUffpsqfv02XLYss2Wuk+fLXWfPlvqPn221H3aPPO66z5ttnzoPn221H36bKn7tPnu89B9+mw5bNlmS92nz5a6T58tdZ8+W+o+fbbUfbpseT3pPn221H36bKn79NlS9+mz5bBlmy11nz5b6j5dnnldT7pPny11nz5b6j5ttjzrPm2++5x1nz5b6j59ttR9+mw5bNlmS92nz5a6T58tdZ8+W+o+fbbUfdpsuek+fbbUffpsqfv02VL36bPlsGWXZ16b7tNnS92nz5a6T58tdZ8+3310nzZb7rpPny11nz5b6j59ttR9+mw5bNlmS92nz5a6T58tdZ8+W+o+fbbUfdpsOXSfPlvqPn221H3aPPMauk+fLYct22yp+/TZUvfp891H9+mzpe7TZ0vdp82WF92nz5a6T58tdZ8+W+o+fbYctmyzpe7TZ0vdp8+Wuk+fLXWfPlvqPm22vOo+bZ55XXWfPlvqPn221H36bDls2ea7j+7TZ0vdp8+Wuk+fLXWfPlvqPm22vOk+fbbUffpsqfv02VL36bPlsGWbLXWfPlvqPn221H36bKn7tHnmddN92mx51336bKn79NlS92nz3eeu+/TZctiyzZa6T58tdZ8+W+o+fbbUffpsqfu02fKh+/TZUvfps6Xu02dL3afPlsOWbbbUffpsqfu0eeb10H36bKn79NlS9+my5e2k+3T57nM76T59ttR9+myp+/TZctiyzZa6T58tdZ8+W+o+fbbUffpsqfu02fKs+/TZUvfps6Xu02dL3afPlsOWXZ55nXWfPlvqPn221H36bKn79Pnuo/u02XLTffpsqfv02VL36bOl7tNny2HLNlvqPn221H36bKn79NlS9+mzpe7TZstd9+mzpe7TZ0vdp80zr1336bPlsGWbLXWfPlvqPn2+++g+fbbUffpsqfu02XLoPn221H36bKn79NlS9+mz5bBlmy11nz5b6j59ttR9+myp+/TZUvdps+VF92nzzOui+/TZUvfps6Xu02fLYcs23310nz5b6j59ttR9+myp+/TZUvdps+VV9+mzpe7TZ0vdp8+Wuk+fLYct22yp+/TZUvfps6Xu02dL3afNM6+r7tNmy5vu02dL3afPlrpPm+8+N92nz5bDlm221H36bKn79NlS9+mzpe7TZ0vdp82Wd92nz5a6T58tdZ8+W+o+fbYctmyzpe7TZ0vdp80zr7vu02dL3afPlrpPmy0fuk+b7z4P3afPlrpPny11nz5bDlu22VL36bOl7tNnS92nz5a6T58tdZ8uW95Puk+fLXWfPlvqPn221H36bDls2eSZ1/2k+/TZUvfps6Xu02dL3afPdx/dp82WZ92nz5a6T58tdZ8+W+o+fbYctmyzpe7TZ0vdp8+Wuk+fLXWfPlvqPm223HSfPlvqPn221H3aPPPadJ8+Ww5bttlS9+mzpe7T57uP7tNnS92nz5a6T5std92nz5a6T58tdZ8+W+o+fbYctmyzpe7TZ0vdp8+Wuk+fLXWfPlvqPm22HLpPm2deQ/fps6Xu02dL3afPlsOWbb776D59ttR9+myp+/TZUvfps6Xu02bLi+7TZ0vdp8+Wuk+fLXWfPlsOW7bZUvfps6Xu02dL3afPlrpPm2deF92nzZZX3afPlrpPny11nzbffa66T58thy3bbKn79NlS9+mzpe7TZ0vdp8+Wuk+bLW+6T58tdZ8+W+o+fbbUffpsOWzZZkvdp8+Wuk+bZ1433afPlrpPny11nzZb3nWfNt997rpPny11nz5b6j59thy2bLOl7tNnS92nz5a6T58tdZ8+W+o+bbZ86D59ttR9+myp+/TZUvfps+WwZZdnXg/dp8+Wuk+fLXWfPlvqPn2+++g+XbZ8nHSfPlvqPn221H36bKn79Nly2LLNlrpPny11nz5b6j59ttR9+myp+7TZ8qz79NlS9+mzpe7T5ZnX46z79Nly2LLNlrpPn89L3afPlrpPny11nz5b6j5tttx0nz5b6j5tnGTTffpsqfv02XLYss3npe7TZ0vdp8+Wuk+fLXWfPlvqPm223HWfNk6y6z59ttR9+myp+/TZctiyzXcf3afPlrpPny11nz5b6j59ttR92mw5dJ8+W+o+fbbUffpsqfv02XLYss2Wus/X2fK+3Z9b3vfTz1vqPi/d8jz2t9/HuFw/WfO6b+e3X3qMH9f81W/6en/7Td++/9Lbr37lfT8/nj+8b5cff/iPO9GU3Mm/cid6lTv5V+5EC3Mn/8KdXHQ2d/L3Hx7jyXofP/B4uxMNz538K3eiD7qTf9zJ7W2X8fc1Pvrh7XF/+5VPp9MnPzwuz1vaxu3+8Q9fTm93t59/kvOLAOpYv8yxDsfqWH/vsT6ev/J22U6l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0Q96+wl+WvvRD3r70Q96+9EPWn++cNMPevvRD1r7uesHvf3oB63fH9z1g95+9IPefoKf1n70g95+9IPefvSD3n70g95+9IPWfh76QW8/+kFvP/pBbz/6QW8/wU9rP/pB688XHvpBbz/6QW8/+kFvP/pB5/cHl4N+0NuPftDbj37Q249+0NtP8NPaj37Q249+0NuPftDbj37Q249+0NrPUT/o7Uc/6O1HP+jtRz/o/PnC5Rj8tPajH/T2ox/09qMf9H5/oB/09qMftPZz0g96+9EPevvRD3r70Q96+wl+WvvRD3r70Q96+9EPevvRD3r70Q9a+znrB7396AetP1846we9/egHvf0EP6396Ae93x/oB7396Ae9/egHvf3oB639hH7Q249+0NuPftDbj37Q20/w09qPftDbj37Q249+0NuPftDbj37Q+vOFi37Q249+0NuPftDbj37Q+v3BJfhp7Uc/6O1HP+jtRz/o7Uc/6O1HP2jt56of9PajH/T2ox/09qMf9PYT/LT2ox/09qMf9PajH7T+fOGqH/T2ox+09nPTD3r70Q9avz+46Qe9/egHvf0EP6396Ae9/egHvf3oB7396Ae9/egHrf3c9YPefvSD3n70g95+9IPefoKf1n70g9afL9z1g95+9IPefvSD3n70g9bvDx76QW8/+kFvP/pBbz/6QW8/wU9rP/pBbz/6QW8/+kFvP/pBbz/6QWc/14N+0NuPftDbj37Q249+0Pnzhesh+GntRz/o7Uc/6O1HP+j9/kA/6O1HP2jt56gf9PajH/T2ox/09qMf9PYT/LT2ox/09qMf9PajH/T2ox/09qMftPZz0g96+9EPWn++cNIPevvRD3r7CX5a+9EPer8/0A96+9EPevvRD3r70Q9a+znrB7396Ae9/egHvf3oB739BD+t/egHvf3oB7396Ae9/egHvf3oB60/Xwj9oLcf/aC3H/2gtx/9oPX7gwh+WvvRD3r70Q96+9EPevvRD3r70Q9a+7noB7396Ae9/egHvf3oB739BD+t/egHvf3oB7396AetP1+46Ae9/egHrf1c9YPefvSD1u8PrvpBbz/6QW8/wU9rP/pBbz/6QW8/+kFvP/pBbz/6QWs/N/2gtx/9oLcf/aC3H/2gt5/gp7Uf/aD15ws3/aC3H/2gtx/9oLcf/aD1+4O7ftDbj37Q249+0NuP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dqdcfdud8qB8b8rVt90pV992p1x9251y9W13ytW3vSk/q2+7U66+7U65+rY75erb7pQH5XtTrr7tTrn6tjvl6tvulKtvu1Ouvu1Neahv05S/fcVT+SXiE+Xq2+6Uq2+7U66+7U55UL435erb7pSrb7tTrr7tTrn6tjvl6tvelF/Ut90pV992p1x9251y9W13yoPyvSlX33anXH3bnXL1bXfK1bfdKVff9qb8qr7tTrn6tjvl6tvulKtvu1MelO9Nufq2O+Xq2+6Uq2+7U66+7U65+rY35Tf1bXfK1bfdKVffdqdcfdud8qB8b8rVt90pV992p1x9251y9W13ytW3vSm/q2+7U66+7U65+rY75erb7pQH5XtTrr7tTrn6tjvl6tvulKtvu1Ouvu1N+UN9251y9W13ytW33SlX33anPCjfm3L1bXfK1bdpyu+35y97fRyunyhX33anXH3bnXL1bZryx+nwrvxy+PqL7+fz8xe+ny/Xb744nszu178/S/V+UPWcUtIpqYVOKemUVEinlHRK6qZTSjqlcEpOKeeU1FinlHRKKq9TSjol9dgpJZ2SKu2Ukk5J7XZKOad0VLudUtIpqd1OKemU1G6nlHRKardTSjqlcEpOKeeU1G6nlHRKardTSjoltdspJZ2S2u2Ukk5J7XZKOad0UrudUtIpqd1OKemU1G6nlHRKardTSjqlcEpOKeeU1G6nlHRKardTSjoltdspJZ2S2u2Ukk5J7XZKOad0VrudUtIpqd1OKemU1G6nlHRKardTSjqlcEpOKeeU1G6nlHRKardTSjoltdspJZ2S2u2Ukk5J7XZKOacUardTSjoltdspJZ2S2u2Ukk5J7XZKSacUTskp5ZyS2u2Ukk5J7XZKSaekdjulpFNSu51S0imp3U4p55QuardTSjoltdspJZ2S2u2Ukk5J7XZKSacUTskp5ZyS2u2Ukk5J7XZKSaekdjulpFNSu51S0imp3U4p55SuardTSjoltdspJZ2S2u2Ukk5J7XZKSacUTskp5ZyS2u2Ukk5J7XZKSaekdjulpFNSu51S0imp3U4p55RuardTSjoltdspJZ2S2u2Ukk5J7XZKSacUTskp5ZyS2u2Ukk5J7XZKSaekdjulpFNSu51S0imp3U4p55TuardTSjoltdspJZ2S2u2Ukk5J7XZKSacUTskp5ZyS2u2Ukk5J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baldpdtSu0q3pXaVbkvti/Ydtat0W2pX6RK1//jEW/ttrU+0q3RbalfpttSu0u2o/aXSbaldpdtSu0q3pXaVbkvti/Ydtat0W2pX6bbUrtJtqV2l21K7Sreh9nVS6bbUrtJtqV2l21K7Srel9kX7jtpVui21q3RbalfpttSu0m2pXaXbUftZpdtSu0q3pXaVbkvtKt2W2hftO2pX6bbUrtJtqV2l21K7SreldpVuR+0XlW5L7SrdltpVui21q3Rbal+076hdpdtSu0q3pXaVbkvtKt2W2lW6HbVfVbottat0W2pX6bbUrtJtqX3RvqN2lW5L7SrdltpVui21q3RbalfpdtS+VLottat0W2pX6RK1Px/vH/b+Ot0/0a7Sbal90b6jdpUuUfvrcvrQfjv9+sPP6/X9Az+vt/sXH15vfc/79ZNzUv+c04HnpCo6pwPPSa10TgeekwrqnI47p5u66pwOPCfV1jkdeE5qsHM68JxUZud04Dkt5+ScjjsnVdw5HXhOqrhzOvCcVHHndOA5qeLO6cBzUsWd03HndFfFndOB56SKO6cDz0kVd04HnpMq7pwOPKflnJzTceekijunA89JFXdOB56TKu6cDjwnVdw5HXhOqrhzOu6cHqq4czrwnFRx53TgOanizunAc1LFndOB57Sck3M67pxUced04Dmp4s7pwHNSxZ3TgeekijunA89JFXdOx53TUxV3TgeekyrunA48J1XcOR14Tqq4czrwnJZzck7HnZMq7pwOPCdV3DkdeE6quHM68JxUced04Dmp4s7puHN6qeLO6cBzUsWd04HnpIo7pwPPSRV3Tgee03JOzum4c1LFndOB56SKO6cDz0kVd04HnpMq7pwOPCdV3Dkddk63kyrunA48J1XcOR14Tqq4czrwnFRx53TgOS3n5JyOOydV3DkdeE6quHM68JxUced04Dmp4s7pwHNSxZ3Tced0VsWd04HnpIo7pwPPSRV3TgeekyrunA48p+WcnNNx56SKO6cDz0kVd04HnpMq7pwOPCdV3DkdeE6quHM67pwuqrhzOvCcVHHndOA5qeLO6cBzUsWd04HntJyTczrunFRx53TgOanizunAc1LFndOB56SKO6cDz0kVd07HndNVFXdOB56TKu6cDjwnVdw5HXhOqrhzOvCclnNyTsedkyrunA48J1XcOR14Tqq4czrw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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "7": {
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "24": {
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n",
      "path": "std/embedded_curve_ops.nr"
    },
    "25": {
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "26": {
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n",
      "path": "std/field/mod.nr"
    },
    "29": {
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "34": {
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "35": {
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n",
      "path": "std/hash/sha256.nr"
    },
    "58": {
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "59": {
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n",
      "path": "std/panic.nr"
    },
    "68": {
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n",
      "path": "std/uint128.nr"
    },
    "70": {
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::{Serialize, Deserialize}, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n\n#[note]\n#[derive(Serialize)]\n#[derive(Deserialize)]\nstruct NewAddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for NewAddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NewAddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        let header = NoteHeader::empty();\n        NewAddressNote { address, npk_m_hash, header }\n    }\n}\n\nimpl Eq for NewAddressNote {\n    fn eq(self, other: Self) -> bool {\n        (self.address == other.address) & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//serialize is a macro now?\n// impl Serialize<3> for NewAddressNote {\n//     fn serialize(self) -> [Field; 3] {\n//         [self.address.to_field(), self.shared_secret, self.npk_m_hash.to_field()]\n//     }\n// }\n\n",
      "path": "/Users/niallcheetham/dev/aztec/priv2/privGroupsToken/src/contracts/src/types/NewAddressNote.nr"
    },
    "71": {
      "source": "use dep::aztec::{\n    protocol_types::{\n    address::AztecAddress, traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n    hash::poseidon2_hash_with_separator\n},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\n\n#[note]\n#[derive(Serialize)]\nstruct StringNote { \n    string: Field,\n    randomness: Field,\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for StringNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl StringNote {\n    pub fn new(string: Field, npk_m_hash: Field) -> Self {\n        let randomness : Field = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        StringNote { string, randomness, npk_m_hash, header }\n    }\n}\n\nimpl Eq for StringNote {\n    fn eq(self, other: Self) -> bool {\n        (self.string == other.string)\n            & (self.randomness == other.randomness)\n            & (self.npk_m_hash == other.npk_m_hash)\n    }\n}\n\n//dont think i need serialise because of new macro\nimpl Serialize<3> for StringNote {\n    fn serialize(self) -> [Field; 3] {\n        [self.string, self.randomness, self.npk_m_hash.to_field()]\n    }\n}\n",
      "path": "/Users/niallcheetham/dev/aztec/priv2/privGroupsToken/src/contracts/src/types/StringNote.nr"
    },
    "78": {
      "source": "mod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n//for this contract, the number of group members does not matter, anyone can be a creditor or debtor, i dont have any assertions.\n//this is more of a reason for the good ole shared secret account approach \n\n#[aztec]\ncontract PrivateGroups {\n\n    use dep::aztec::{prelude::{Map, AztecAddress, PrivateImmutable, PrivateSet}};\n    // use dep::address_note::address_note::AddressNote;\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, events::event, functions::{public, initializer, private, internal}}\n    };\n    use dep::aztec::note::note_viewer_options::NoteViewerOptions;\n    use crate::types::StringNote::StringNote;\n    use crate::types::NewAddressNote::NewAddressNote;\n    use aztec::note::note_getter::NoteGetterOptions;\n    use value_note::{balance_utils, utils::increment, value_note::ValueNote};\n    use std::hash::poseidon2;\n    use aztec::context::inputs::private_context_inputs::PrivateContextInputs;\n\n    global ZERO_ADDRESS: AztecAddress = AztecAddress::from_field(0x0000000000000000000000000000000000000000000000000000000000000000);\n\n    #[storage]\n   struct Storage<Context> {\n        admin: PrivateImmutable<NewAddressNote, Context>,\n        // group_members: Map<AztecAddress, PrivateSet<NewAddressNote, Context>, Context>,\n        group_balances_credit: Map<Field, PrivateSet<ValueNote,Context>, Context>,\n        group_balances_debt: Map<Field, PrivateSet<ValueNote, Context>, Context>,\n   }\n\n    #[private]\n    #[initializer]\n    fn constructor(admin: AztecAddress, group_members: [AztecAddress; 3]) {\n        //setting the admin address note\n        let admin_keys = get_public_keys(admin);\n        let mut admin_address_note = NewAddressNote::new(admin, admin_keys.npk_m.hash());\n        storage.admin.initialize(&mut admin_address_note).emit(encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, admin_keys.ivpk_m, admin));\n\n        //this is for adding members to the private set, so they can see the other members, going to be expensive\n        // for i in 0..3 {\n        //     let member = group_members[i as u32];\n        //     if (member != ZERO_ADDRESS) {\n        //         let member_keys = get_public_keys(member);\n        //         for i in 0..3 {\n        //             let member_add = group_members[i as u32];\n        //             let mut memberNote = NewAddressNote::new(member_add, member_keys.npk_m.hash());\n        //             storage.group_members.at(member).insert(&mut memberNote).emit(\n        //                 encode_and_encrypt_note(&mut context, admin_keys.ovpk_m, member_keys.ivpk_m, member)\n        //             );\n        //         }\n        //     }\n        // }\n    }\n\n    //need to constrain this so that only group members can read this \n    #[private]\n    fn get_admin() -> pub AztecAddress {\n        let admin_note = storage.admin.get_note();\n        admin_note.address\n    }\n\n    // #[private]\n    // fn get_group_members(member: AztecAddress) -> [AztecAddress; 3] {\n    //     let mut options = NoteGetterOptions::new();\n    //     let member_note = storage.group_members.at(member).get_notes(options);\n    //     let mut member_array : [AztecAddress; 3] = [ZERO_ADDRESS; 3];\n    //     //if you call this and u are not part of the group, it will return the zero address\n    //     for i in 0..3 {\n    //         let note = member_note.get_unchecked(i);\n    //         let address: AztecAddress = note.address;\n    //         member_array[i] = address;\n    //     }\n    //     member_array\n    // }\n\n    //TODO:: change the creditor to from\n    // change the debtor to to, this makes it easy to keep track of the notes\n    // outgoing will be from\n    // incoming will be to\n    #[private]\n    fn set_balance(creditor: AztecAddress, debtor: AztecAddress, amount: Field) {\n\n        //notes for the creditor\n        let hash_inputs_credit  = [creditor.to_field(), debtor.to_field()];\n        let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, amount, creditor, debtor);\n\n        // notes for the debtor\n        let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n        let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, amount, debtor, creditor);\n    }\n\n    //can have a timestamp here for when the payment is made. \n    #[private]\n    fn make_payment(debtor: AztecAddress, creditor: AztecAddress, amount: Field) {\n        //do not do any assertions for now\n        let new_amount = amount * -1;\n\n        //notes for the creditor\n        let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n        let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n        let loc_credit = storage.group_balances_credit.at(key_credit);\n        increment(loc_credit, new_amount, creditor, debtor);\n\n        // notes for the debtor\n        let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n        let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n        let loc_debt = storage.group_balances_debt.at(key_debt);\n        increment(loc_debt, new_amount, debtor, creditor);\n    }\n\n    #[private]\n    fn setup_group_payments(creditor: AztecAddress, debtors: [AztecAddress; 2], amount: Field) {\n        //can be called by anyone\n\n        //increase the credit for the creditor with each member\n        let shared_amount : u32 = amount as u32 / (debtors.len() + 1);\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n            let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n            let loc_credit = storage.group_balances_credit.at(key_credit);\n            increment(loc_credit, shared_amount.to_field(), creditor, debtor);\n        }\n        //increase the debt for each member with the creditor\n        for i in 0..2 {\n            let debtor = debtors[i];\n            let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n            let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n            let loc_debt = storage.group_balances_debt.at(key_debt);\n            increment(loc_debt, shared_amount.to_field(), debtor, creditor);\n        }\n    }\n\n    #[private]\n    fn read_balance_credit(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n        //for this function i need to also get the notes that the debtor has sent if they have sent any\n        //if they have sent new notes, i need to nullify the old ones that i have sent to the debtor\n        //make a new one with the new outstanding balance\n        //tricky part is listening for new notes that the debtor has sent, updating the balance\n\n        let hash_inputs_credit = [creditor.to_field(), debtor.to_field()];\n        let key_credit = poseidon2::Poseidon2::hash(hash_inputs_credit, 2);\n        let options = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key_credit).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                let note = balance_notes_credit.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance\n    }\n\n    #[private]\n    fn read_balance_debt(debtor: AztecAddress, creditor: AztecAddress) -> Field {\n        let hash_inputs_debt = [debtor.to_field(), creditor.to_field()];\n        let key_debt = poseidon2::Poseidon2::hash(hash_inputs_debt, 2);\n        let options = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key_debt).get_notes(options);\n\n        let mut total_balance = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get_unchecked(i);\n                total_balance += note.value;\n            }\n        }\n\n        total_balance\n    }\n\n    // read the total balance of two addresses\n    //for some reason this function is not working, going to have to do the ole, balance call for credit and debt and subtract in the frontend\n    #[private]\n    fn read_total_balance(creditor: AztecAddress, debtor: AztecAddress) -> u64 {\n        //going to have to hand type this, could not call the other private functions\n\n        //keys to check in storage\n        let hash_inputs = [creditor.to_field(), debtor.to_field()];\n        let key = poseidon2::Poseidon2::hash(hash_inputs, 2);\n\n        //options for the notes \n        let options_1 = NoteGetterOptions::new();\n        let balance_notes_credit: BoundedVec<ValueNote, 16> = storage.group_balances_credit.at(key).get_notes(options_1);\n\n        let options_2 = NoteGetterOptions::new();\n        let balance_notes_debt: BoundedVec<ValueNote, 16> = storage.group_balances_debt.at(key).get_notes(options_2);\n\n        //sum the notes\n        let mut total_balance_credit = 0 as Field;\n        for i in 0..balance_notes_credit.max_len() {\n            if i < balance_notes_credit.len() {\n                // let note = balance_notes_credit.get_unchecked(i);\n                let note = balance_notes_credit.get(i);\n                total_balance_credit += note.value;\n            }\n        }\n\n        //sum the notes\n        let mut total_balance_debt = 0 as Field;\n        for i in 0..balance_notes_debt.max_len() {\n            if i < balance_notes_debt.len() {\n                let note = balance_notes_debt.get(i);\n                total_balance_debt += note.value;\n            }\n        }\n\n        //convert the note to integer\n\n        let total_debt = U128::from_integer(total_balance_debt);\n        let total_credit = U128::from_integer(total_balance_credit);\n        let tot_debt: i64 = total_debt.to_integer();\n        let tot_credit: i64 = total_credit.to_integer();\n        let total_balance = tot_credit - tot_debt;\n        total_balance as u64\n        // let total_balance = total_credit - total_debt;\n        // total_balance\n    }\n\n    // #[private]\n    // fn read_total_balance_2(creditor: AztecAddress, debtor: AztecAddress) -> Field {\n\n    //     let total_balance_credit = read_balance_credit(&mut context, creditor, debtor);\n    //     let total_balance_debt = read_balance_debt(&mut context, debtor, creditor);\n    //     let total_balance = total_balance_credit - total_balance_debt;\n\n    //     total_balance    \n    // }\n\n    unconstrained pub(crate) fn admin() -> pub AztecAddress {\n        let admin_note: NewAddressNote = storage.admin.view_note();\n        admin_note.address\n    }\n}\n\n//TODO:: add the token transfer, have tests for that too. \n//add block time to storage for notes being paid\n",
      "path": "/Users/niallcheetham/dev/aztec/priv2/privGroupsToken/src/contracts/src/main.nr"
    },
    "80": {
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr"
    },
    "86": {
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"
    },
    "87": {
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"
    },
    "89": {
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"
    },
    "92": {
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"
    },
    "101": {
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"
    },
    "103": {
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"
    },
    "107": {
      "source": "use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"
    },
    "108": {
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_ovsk_app, public_keys::{PublicKeys, OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"
    },
    "110": {
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::{OvpkM, IvpkM}}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext},\n        keys::public_keys::{OvpkM, IvpkM}\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"
    },
    "123": {
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"
    },
    "124": {
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"
    },
    "126": {
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\nunconstrained pub fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr"
    },
    "127": {
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"
    },
    "128": {
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"
    },
    "129": {
      "source": "use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"
    },
    "133": {
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\nunconstrained pub fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"
    },
    "137": {
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"
    },
    "141": {
      "source": "// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N> where T: Eq {\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe {\n        get_collapse_hints(input)\n    };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>\n) where T: Eq {\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(collapsed.len(), collapsed_to_input_index_mapping.len(), \"Collapse hint vec length mismatch\");\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(collapsed.get_unchecked(i), input[input_index].unwrap(), \"Wrong collapsed vec content\");\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(collapsed.get_unchecked(i), std::mem::zeroed(), \"Dirty collapsed vec storage\");\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(input: [Option<T>; N]) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr"
    },
    "145": {
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"
    },
    "163": {
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr"
    },
    "164": {
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr"
    },
    "167": {
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"
    },
    "169": {
      "source": "use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"
    },
    "170": {
      "source": "use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr"
    },
    "178": {
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"
    },
    "185": {
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr"
    },
    "189": {
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr"
    },
    "231": {
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"
    },
    "308": {
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"
    },
    "309": {
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"
    },
    "311": {
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"
    },
    "315": {
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"
    },
    "316": {
      "source": "use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"
    },
    "318": {
      "source": "use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"
    },
    "319": {
      "source": "use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"
    },
    "324": {
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"
    },
    "325": {
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"
    },
    "352": {
      "source": "use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(amount: Field) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(ValueNote::properties().value, SortOrder.DESC)\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(\n        encode_and_encrypt_note(\n            balance.context,\n            outgoing_viewer_ovpk_m,\n            recipient_keys.ivpk_m,\n            recipient\n        )\n    );\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/utils.nr"
    },
    "353": {
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n",
      "path": "/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "get_public_keys_and_partial_address",
    "random",
    "decompose_hint",
    "notify_created_note_oracle_wrapper",
    "get_key_validation_request",
    "lt_32_hint",
    "lte_16_hint",
    "build_msg_block_iter",
    "pad_msg_block",
    "attach_len_to_msg_block",
    "build_msg_block_iter",
    "emit_encrypted_note_log_oracle_wrapper",
    "directive_invert",
    "directive_integer_quotient"
  ]
}