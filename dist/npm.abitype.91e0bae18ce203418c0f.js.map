{"version":3,"file":"npm.abitype.91e0bae18ce203418c0f.js","mappings":"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","sources":["webpack://publicgroups/./node_modules/abitype/dist/esm/errors.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js","webpack://publicgroups/./node_modules/abitype/dist/esm/regex.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/runtime/signatures.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/errors/abiItem.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/errors/signature.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/errors/struct.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/runtime/cache.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/runtime/utils.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/runtime/structs.js","webpack://publicgroups/./node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js"],"sourcesContent":["import { version } from './version.js';\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        const message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: abitype@${version}`,\n        ].join('\\n');\n        super(message);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiTypeError'\n        });\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n}\n//# sourceMappingURL=errors.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidAbiParameterError extends BaseError {\n    constructor({ param }) {\n        super('Failed to parse ABI parameter.', {\n            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n            docsPath: '/api/human#parseabiparameter-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParameterError'\n        });\n    }\n}\nexport class InvalidAbiParametersError extends BaseError {\n    constructor({ params }) {\n        super('Failed to parse ABI parameters.', {\n            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n            docsPath: '/api/human#parseabiparameters-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiParametersError'\n        });\n    }\n}\nexport class InvalidParameterError extends BaseError {\n    constructor({ param }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParameterError'\n        });\n    }\n}\nexport class SolidityProtectedKeywordError extends BaseError {\n    constructor({ param, name }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SolidityProtectedKeywordError'\n        });\n    }\n}\nexport class InvalidModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidModifierError'\n        });\n    }\n}\nexport class InvalidFunctionModifierError extends BaseError {\n    constructor({ param, type, modifier, }) {\n        super('Invalid ABI parameter.', {\n            details: param,\n            metaMessages: [\n                `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : ''}.`,\n                `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidFunctionModifierError'\n        });\n    }\n}\nexport class InvalidAbiTypeParameterError extends BaseError {\n    constructor({ abiParameter, }) {\n        super('Invalid ABI parameter.', {\n            details: JSON.stringify(abiParameter, null, 2),\n            metaMessages: ['ABI parameter type is invalid.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiTypeParameterError'\n        });\n    }\n}\n//# sourceMappingURL=abiParameter.js.map","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped(regex, string) {\n    const match = regex.exec(string);\n    return match?.groups;\n}\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexport const isTupleRegex = /^\\(.+?\\).*?$/;\n//# sourceMappingURL=regex.js.map","import { execTyped } from '../../regex.js';\n// https://regexr.com/7gmok\nconst errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isErrorSignature(signature) {\n    return errorSignatureRegex.test(signature);\n}\nexport function execErrorSignature(signature) {\n    return execTyped(errorSignatureRegex, signature);\n}\n// https://regexr.com/7gmoq\nconst eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/;\nexport function isEventSignature(signature) {\n    return eventSignatureRegex.test(signature);\n}\nexport function execEventSignature(signature) {\n    return execTyped(eventSignatureRegex, signature);\n}\n// https://regexr.com/7gmot\nconst functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/;\nexport function isFunctionSignature(signature) {\n    return functionSignatureRegex.test(signature);\n}\nexport function execFunctionSignature(signature) {\n    return execTyped(functionSignatureRegex, signature);\n}\n// https://regexr.com/7gmp3\nconst structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/;\nexport function isStructSignature(signature) {\n    return structSignatureRegex.test(signature);\n}\nexport function execStructSignature(signature) {\n    return execTyped(structSignatureRegex, signature);\n}\n// https://regexr.com/78u01\nconst constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isConstructorSignature(signature) {\n    return constructorSignatureRegex.test(signature);\n}\nexport function execConstructorSignature(signature) {\n    return execTyped(constructorSignatureRegex, signature);\n}\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex = /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/;\nexport function isFallbackSignature(signature) {\n    return fallbackSignatureRegex.test(signature);\n}\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/;\nexport function isReceiveSignature(signature) {\n    return receiveSignatureRegex.test(signature);\n}\nexport const modifiers = new Set([\n    'memory',\n    'indexed',\n    'storage',\n    'calldata',\n]);\nexport const eventModifiers = new Set(['indexed']);\nexport const functionModifiers = new Set([\n    'calldata',\n    'memory',\n    'storage',\n]);\n//# sourceMappingURL=signatures.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidAbiItemError extends BaseError {\n    constructor({ signature }) {\n        super('Failed to parse ABI item.', {\n            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n            docsPath: '/api/human#parseabiitem-1',\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAbiItemError'\n        });\n    }\n}\nexport class UnknownTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [\n                `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownTypeError'\n        });\n    }\n}\nexport class UnknownSolidityTypeError extends BaseError {\n    constructor({ type }) {\n        super('Unknown type.', {\n            metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSolidityTypeError'\n        });\n    }\n}\n//# sourceMappingURL=abiItem.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidSignatureError extends BaseError {\n    constructor({ signature, type, }) {\n        super(`Invalid ${type} signature.`, {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidSignatureError'\n        });\n    }\n}\nexport class UnknownSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Unknown signature.', {\n            details: signature,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'UnknownSignatureError'\n        });\n    }\n}\nexport class InvalidStructSignatureError extends BaseError {\n    constructor({ signature }) {\n        super('Invalid struct signature.', {\n            details: signature,\n            metaMessages: ['No properties exist.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidStructSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=signature.js.map","import { BaseError } from '../../errors.js';\nexport class CircularReferenceError extends BaseError {\n    constructor({ type }) {\n        super('Circular reference detected.', {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'CircularReferenceError'\n        });\n    }\n}\n//# sourceMappingURL=struct.js.map","import { BaseError } from '../../errors.js';\nexport class InvalidParenthesisError extends BaseError {\n    constructor({ current, depth }) {\n        super('Unbalanced parentheses.', {\n            metaMessages: [\n                `\"${current.trim()}\" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,\n            ],\n            details: `Depth \"${depth}\"`,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidParenthesisError'\n        });\n    }\n}\n//# sourceMappingURL=splitParameters.js.map","/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(param, type) {\n    if (type)\n        return `${type}:${param}`;\n    return param;\n}\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map([\n    // Unnamed\n    ['address', { type: 'address' }],\n    ['bool', { type: 'bool' }],\n    ['bytes', { type: 'bytes' }],\n    ['bytes32', { type: 'bytes32' }],\n    ['int', { type: 'int256' }],\n    ['int256', { type: 'int256' }],\n    ['string', { type: 'string' }],\n    ['uint', { type: 'uint256' }],\n    ['uint8', { type: 'uint8' }],\n    ['uint16', { type: 'uint16' }],\n    ['uint24', { type: 'uint24' }],\n    ['uint32', { type: 'uint32' }],\n    ['uint64', { type: 'uint64' }],\n    ['uint96', { type: 'uint96' }],\n    ['uint112', { type: 'uint112' }],\n    ['uint160', { type: 'uint160' }],\n    ['uint192', { type: 'uint192' }],\n    ['uint256', { type: 'uint256' }],\n    // Named\n    ['address owner', { type: 'address', name: 'owner' }],\n    ['address to', { type: 'address', name: 'to' }],\n    ['bool approved', { type: 'bool', name: 'approved' }],\n    ['bytes _data', { type: 'bytes', name: '_data' }],\n    ['bytes data', { type: 'bytes', name: 'data' }],\n    ['bytes signature', { type: 'bytes', name: 'signature' }],\n    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n    ['bytes32 r', { type: 'bytes32', name: 'r' }],\n    ['bytes32 root', { type: 'bytes32', name: 'root' }],\n    ['bytes32 s', { type: 'bytes32', name: 's' }],\n    ['string name', { type: 'string', name: 'name' }],\n    ['string symbol', { type: 'string', name: 'symbol' }],\n    ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint8 v', { type: 'uint8', name: 'v' }],\n    ['uint256 balance', { type: 'uint256', name: 'balance' }],\n    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n    ['uint256 value', { type: 'uint256', name: 'value' }],\n    // Indexed\n    [\n        'event:address indexed from',\n        { type: 'address', name: 'from', indexed: true },\n    ],\n    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n    [\n        'event:uint indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n    [\n        'event:uint256 indexed tokenId',\n        { type: 'uint256', name: 'tokenId', indexed: true },\n    ],\n]);\n//# sourceMappingURL=cache.js.map","import { bytesRegex, execTyped, integerRegex, isTupleRegex, } from '../../regex.js';\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js';\nimport { InvalidFunctionModifierError, InvalidModifierError, InvalidParameterError, SolidityProtectedKeywordError, } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, UnknownSignatureError, } from '../errors/signature.js';\nimport { InvalidParenthesisError } from '../errors/splitParameters.js';\nimport { getParameterCacheKey, parameterCache } from './cache.js';\nimport { eventModifiers, execConstructorSignature, execErrorSignature, execEventSignature, execFunctionSignature, functionModifiers, isConstructorSignature, isErrorSignature, isEventSignature, isFallbackSignature, isFunctionSignature, isReceiveSignature, } from './signatures.js';\nexport function parseSignature(signature, structs = {}) {\n    if (isFunctionSignature(signature)) {\n        const match = execFunctionSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'function' });\n        const inputParams = splitParameters(match.parameters);\n        const inputs = [];\n        const inputLength = inputParams.length;\n        for (let i = 0; i < inputLength; i++) {\n            inputs.push(parseAbiParameter(inputParams[i], {\n                modifiers: functionModifiers,\n                structs,\n                type: 'function',\n            }));\n        }\n        const outputs = [];\n        if (match.returns) {\n            const outputParams = splitParameters(match.returns);\n            const outputLength = outputParams.length;\n            for (let i = 0; i < outputLength; i++) {\n                outputs.push(parseAbiParameter(outputParams[i], {\n                    modifiers: functionModifiers,\n                    structs,\n                    type: 'function',\n                }));\n            }\n        }\n        return {\n            name: match.name,\n            type: 'function',\n            stateMutability: match.stateMutability ?? 'nonpayable',\n            inputs,\n            outputs,\n        };\n    }\n    if (isEventSignature(signature)) {\n        const match = execEventSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'event' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], {\n                modifiers: eventModifiers,\n                structs,\n                type: 'event',\n            }));\n        }\n        return { name: match.name, type: 'event', inputs: abiParameters };\n    }\n    if (isErrorSignature(signature)) {\n        const match = execErrorSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'error' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));\n        }\n        return { name: match.name, type: 'error', inputs: abiParameters };\n    }\n    if (isConstructorSignature(signature)) {\n        const match = execConstructorSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'constructor' });\n        const params = splitParameters(match.parameters);\n        const abiParameters = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));\n        }\n        return {\n            type: 'constructor',\n            stateMutability: match.stateMutability ?? 'nonpayable',\n            inputs: abiParameters,\n        };\n    }\n    if (isFallbackSignature(signature))\n        return { type: 'fallback' };\n    if (isReceiveSignature(signature))\n        return {\n            type: 'receive',\n            stateMutability: 'payable',\n        };\n    throw new UnknownSignatureError({ signature });\n}\nconst abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\nconst dynamicIntegerRegex = /^u?int$/;\nexport function parseAbiParameter(param, options) {\n    // optional namespace cache by `type`\n    const parameterCacheKey = getParameterCacheKey(param, options?.type);\n    if (parameterCache.has(parameterCacheKey))\n        return parameterCache.get(parameterCacheKey);\n    const isTuple = isTupleRegex.test(param);\n    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n    if (!match)\n        throw new InvalidParameterError({ param });\n    if (match.name && isSolidityKeyword(match.name))\n        throw new SolidityProtectedKeywordError({ param, name: match.name });\n    const name = match.name ? { name: match.name } : {};\n    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};\n    const structs = options?.structs ?? {};\n    let type;\n    let components = {};\n    if (isTuple) {\n        type = 'tuple';\n        const params = splitParameters(match.type);\n        const components_ = [];\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            // remove `modifiers` from `options` to prevent from being added to tuple components\n            components_.push(parseAbiParameter(params[i], { structs }));\n        }\n        components = { components: components_ };\n    }\n    else if (match.type in structs) {\n        type = 'tuple';\n        components = { components: structs[match.type] };\n    }\n    else if (dynamicIntegerRegex.test(match.type)) {\n        type = `${match.type}256`;\n    }\n    else {\n        type = match.type;\n        if (!(options?.type === 'struct') && !isSolidityType(type))\n            throw new UnknownSolidityTypeError({ type });\n    }\n    if (match.modifier) {\n        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n        if (!options?.modifiers?.has?.(match.modifier))\n            throw new InvalidModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n        // Check if resolved `type` is valid if there is a function modifier\n        if (functionModifiers.has(match.modifier) &&\n            !isValidDataLocation(type, !!match.array))\n            throw new InvalidFunctionModifierError({\n                param,\n                type: options?.type,\n                modifier: match.modifier,\n            });\n    }\n    const abiParameter = {\n        type: `${type}${match.array ?? ''}`,\n        ...name,\n        ...indexed,\n        ...components,\n    };\n    parameterCache.set(parameterCacheKey, abiParameter);\n    return abiParameter;\n}\n// s/o latika for this\nexport function splitParameters(params, result = [], current = '', depth = 0) {\n    const length = params.trim().length;\n    // biome-ignore lint/correctness/noUnreachable: recursive\n    for (let i = 0; i < length; i++) {\n        const char = params[i];\n        const tail = params.slice(i + 1);\n        switch (char) {\n            case ',':\n                return depth === 0\n                    ? splitParameters(tail, [...result, current.trim()])\n                    : splitParameters(tail, result, `${current}${char}`, depth);\n            case '(':\n                return splitParameters(tail, result, `${current}${char}`, depth + 1);\n            case ')':\n                return splitParameters(tail, result, `${current}${char}`, depth - 1);\n            default:\n                return splitParameters(tail, result, `${current}${char}`, depth);\n        }\n    }\n    if (current === '')\n        return result;\n    if (depth !== 0)\n        throw new InvalidParenthesisError({ current, depth });\n    result.push(current.trim());\n    return result;\n}\nexport function isSolidityType(type) {\n    return (type === 'address' ||\n        type === 'bool' ||\n        type === 'function' ||\n        type === 'string' ||\n        bytesRegex.test(type) ||\n        integerRegex.test(type));\n}\nconst protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n/** @internal */\nexport function isSolidityKeyword(name) {\n    return (name === 'address' ||\n        name === 'bool' ||\n        name === 'function' ||\n        name === 'string' ||\n        name === 'tuple' ||\n        bytesRegex.test(name) ||\n        integerRegex.test(name) ||\n        protectedKeywordsRegex.test(name));\n}\n/** @internal */\nexport function isValidDataLocation(type, isArray) {\n    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';\n}\n//# sourceMappingURL=utils.js.map","import { execTyped, isTupleRegex } from '../../regex.js';\nimport { UnknownTypeError } from '../errors/abiItem.js';\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js';\nimport { InvalidSignatureError, InvalidStructSignatureError, } from '../errors/signature.js';\nimport { CircularReferenceError } from '../errors/struct.js';\nimport { execStructSignature, isStructSignature } from './signatures.js';\nimport { isSolidityType, parseAbiParameter } from './utils.js';\nexport function parseStructs(signatures) {\n    // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n    const shallowStructs = {};\n    const signaturesLength = signatures.length;\n    for (let i = 0; i < signaturesLength; i++) {\n        const signature = signatures[i];\n        if (!isStructSignature(signature))\n            continue;\n        const match = execStructSignature(signature);\n        if (!match)\n            throw new InvalidSignatureError({ signature, type: 'struct' });\n        const properties = match.properties.split(';');\n        const components = [];\n        const propertiesLength = properties.length;\n        for (let k = 0; k < propertiesLength; k++) {\n            const property = properties[k];\n            const trimmed = property.trim();\n            if (!trimmed)\n                continue;\n            const abiParameter = parseAbiParameter(trimmed, {\n                type: 'struct',\n            });\n            components.push(abiParameter);\n        }\n        if (!components.length)\n            throw new InvalidStructSignatureError({ signature });\n        shallowStructs[match.name] = components;\n    }\n    // Resolve nested structs inside each parameter\n    const resolvedStructs = {};\n    const entries = Object.entries(shallowStructs);\n    const entriesLength = entries.length;\n    for (let i = 0; i < entriesLength; i++) {\n        const [name, parameters] = entries[i];\n        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\n    }\n    return resolvedStructs;\n}\nconst typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = new Set()) {\n    const components = [];\n    const length = abiParameters.length;\n    for (let i = 0; i < length; i++) {\n        const abiParameter = abiParameters[i];\n        const isTuple = isTupleRegex.test(abiParameter.type);\n        if (isTuple)\n            components.push(abiParameter);\n        else {\n            const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n            if (!match?.type)\n                throw new InvalidAbiTypeParameterError({ abiParameter });\n            const { array, type } = match;\n            if (type in structs) {\n                if (ancestors.has(type))\n                    throw new CircularReferenceError({ type });\n                components.push({\n                    ...abiParameter,\n                    type: `tuple${array ?? ''}`,\n                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),\n                });\n            }\n            else {\n                if (isSolidityType(type))\n                    components.push(abiParameter);\n                else\n                    throw new UnknownTypeError({ type });\n            }\n        }\n    }\n    return components;\n}\n//# sourceMappingURL=structs.js.map","import { InvalidAbiParametersError } from './errors/abiParameter.js';\nimport { isStructSignature, modifiers } from './runtime/signatures.js';\nimport { parseStructs } from './runtime/structs.js';\nimport { splitParameters } from './runtime/utils.js';\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js';\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters(params) {\n    const abiParameters = [];\n    if (typeof params === 'string') {\n        const parameters = splitParameters(params);\n        const length = parameters.length;\n        for (let i = 0; i < length; i++) {\n            abiParameters.push(parseAbiParameter_(parameters[i], { modifiers }));\n        }\n    }\n    else {\n        const structs = parseStructs(params);\n        const length = params.length;\n        for (let i = 0; i < length; i++) {\n            const signature = params[i];\n            if (isStructSignature(signature))\n                continue;\n            const parameters = splitParameters(signature);\n            const length = parameters.length;\n            for (let k = 0; k < length; k++) {\n                abiParameters.push(parseAbiParameter_(parameters[k], { modifiers, structs }));\n            }\n        }\n    }\n    if (abiParameters.length === 0)\n        throw new InvalidAbiParametersError({ params });\n    return abiParameters;\n}\n//# sourceMappingURL=parseAbiParameters.js.map"],"names":["BaseError","Error","constructor","shortMessage","args","details","cause","message","docsPath","super","metaMessages","join","Object","defineProperty","this","enumerable","configurable","writable","value","InvalidAbiParametersError","params","JSON","stringify","InvalidParameterError","param","SolidityProtectedKeywordError","name","InvalidModifierError","type","modifier","InvalidFunctionModifierError","InvalidAbiTypeParameterError","abiParameter","regex","string","match","exec","groups","bytesRegex","integerRegex","isTupleRegex","structSignatureRegex","isStructSignature","signature","test","execStructSignature","modifiers","Set","UnknownTypeError","UnknownSolidityTypeError","InvalidStructSignatureError","CircularReferenceError","InvalidParenthesisError","current","depth","trim","parameterCache","Map","indexed","abiParameterWithoutTupleRegex","abiParameterWithTupleRegex","dynamicIntegerRegex","parseAbiParameter","options","parameterCacheKey","getParameterCacheKey","has","get","isTuple","protectedKeywordsRegex","isSolidityKeyword","structs","components","splitParameters","components_","length","i","push","isSolidityType","isArray","isValidDataLocation","array","set","result","char","tail","slice","typeWithoutTupleRegex","resolveStructs","abiParameters","ancestors","parseAbiParameters","parameters","signatures","shallowStructs","signaturesLength","properties","split","propertiesLength","k","trimmed","resolvedStructs","entries","entriesLength","parseStructs"],"sourceRoot":""}