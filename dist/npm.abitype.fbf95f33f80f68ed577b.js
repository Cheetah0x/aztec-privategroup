"use strict";(self.webpackChunkprivategroups=self.webpackChunkprivategroups||[]).push([[22],{82897:(e,t,r)=>{r.d(t,{m:()=>B});class n extends Error{constructor(e,t={}){const r=t.cause instanceof n?t.cause.details:t.cause?.message?t.cause.message:t.details,a=t.cause instanceof n&&t.cause.docsPath||t.docsPath;super([e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...a?[`Docs: https://abitype.dev${a}`]:[],...r?[`Details: ${r}`]:[],"Version: abitype@1.0.5"].join("\n")),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiTypeError"}),t.cause&&(this.cause=t.cause),this.details=r,this.docsPath=a,this.metaMessages=t.metaMessages,this.shortMessage=e}}class a extends n{constructor({params:e}){super("Failed to parse ABI parameters.",{details:`parseAbiParameters(${JSON.stringify(e,null,2)})`,docsPath:"/api/human#parseabiparameters-1"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiParametersError"})}}class s extends n{constructor({param:e}){super("Invalid ABI parameter.",{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParameterError"})}}class i extends n{constructor({param:e,name:t}){super("Invalid ABI parameter.",{details:e,metaMessages:[`"${t}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SolidityProtectedKeywordError"})}}class o extends n{constructor({param:e,type:t,modifier:r}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${r}" not allowed${t?` in "${t}" type`:""}.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidModifierError"})}}class u extends n{constructor({param:e,type:t,modifier:r}){super("Invalid ABI parameter.",{details:e,metaMessages:[`Modifier "${r}" not allowed${t?` in "${t}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidFunctionModifierError"})}}class l extends n{constructor({abiParameter:e}){super("Invalid ABI parameter.",{details:JSON.stringify(e,null,2),metaMessages:["ABI parameter type is invalid."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiTypeParameterError"})}}function p(e,t){const r=e.exec(t);return r?.groups}const c=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,d=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,y=/^\(.+?\).*?$/,m=/^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;function f(e){return m.test(e)}function b(e){return p(m,e)}const h=new Set(["memory","indexed","storage","calldata"]),g=(new Set(["indexed"]),new Set(["calldata","memory","storage"]));class w extends n{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownTypeError"})}}class v extends n{constructor({type:e}){super("Unknown type.",{metaMessages:[`Type "${e}" is not a valid ABI type.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSolidityTypeError"})}}class $ extends n{constructor({signature:e,type:t}){super(`Invalid ${t} signature.`,{details:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSignatureError"})}}class I extends n{constructor({signature:e}){super("Invalid struct signature.",{details:e,metaMessages:["No properties exist."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStructSignatureError"})}}class x extends n{constructor({type:e}){super("Circular reference detected.",{metaMessages:[`Struct "${e}" is a circular reference.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"CircularReferenceError"})}}class P extends n{constructor({current:e,depth:t}){super("Unbalanced parentheses.",{metaMessages:[`"${e.trim()}" has too many ${t>0?"opening":"closing"} parentheses.`],details:`Depth "${t}"`}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParenthesisError"})}}const A=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]),M=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,O=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,j=/^u?int$/;function k(e,t){const r=function(e,t){return t?`${t}:${e}`:e}(e,t?.type);if(A.has(r))return A.get(r);const n=y.test(e),a=p(n?O:M,e);if(!a)throw new s({param:e});if(a.name&&function(e){return"address"===e||"bool"===e||"function"===e||"string"===e||"tuple"===e||c.test(e)||d.test(e)||_.test(e)}(a.name))throw new i({param:e,name:a.name});const l=a.name?{name:a.name}:{},m="indexed"===a.modifier?{indexed:!0}:{},f=t?.structs??{};let b,h={};if(n){b="tuple";const e=E(a.type),t=[],r=e.length;for(let n=0;n<r;n++)t.push(k(e[n],{structs:f}));h={components:t}}else if(a.type in f)b="tuple",h={components:f[a.type]};else if(j.test(a.type))b=`${a.type}256`;else if(b=a.type,"struct"!==t?.type&&!S(b))throw new v({type:b});if(a.modifier){if(!t?.modifiers?.has?.(a.modifier))throw new o({param:e,type:t?.type,modifier:a.modifier});if(g.has(a.modifier)&&!function(e,t){return t||"bytes"===e||"string"===e||"tuple"===e}(b,!!a.array))throw new u({param:e,type:t?.type,modifier:a.modifier})}const w={type:`${b}${a.array??""}`,...l,...m,...h};return A.set(r,w),w}function E(e,t=[],r="",n=0){const a=e.trim().length;for(let s=0;s<a;s++){const a=e[s],i=e.slice(s+1);switch(a){case",":return 0===n?E(i,[...t,r.trim()]):E(i,t,`${r}${a}`,n);case"(":return E(i,t,`${r}${a}`,n+1);case")":return E(i,t,`${r}${a}`,n-1);default:return E(i,t,`${r}${a}`,n)}}if(""===r)return t;if(0!==n)throw new P({current:r,depth:n});return t.push(r.trim()),t}function S(e){return"address"===e||"bool"===e||"function"===e||"string"===e||c.test(e)||d.test(e)}const _=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/,z=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;function Z(e,t,r=new Set){const n=[],a=e.length;for(let s=0;s<a;s++){const a=e[s];if(y.test(a.type))n.push(a);else{const e=p(z,a.type);if(!e?.type)throw new l({abiParameter:a});const{array:s,type:i}=e;if(i in t){if(r.has(i))throw new x({type:i});n.push({...a,type:`tuple${s??""}`,components:Z(t[i]??[],t,new Set([...r,i]))})}else{if(!S(i))throw new w({type:i});n.push(a)}}}return n}function B(e){const t=[];if("string"==typeof e){const r=E(e),n=r.length;for(let e=0;e<n;e++)t.push(k(r[e],{modifiers:h}))}else{const r=function(e){const t={},r=e.length;for(let n=0;n<r;n++){const r=e[n];if(!f(r))continue;const a=b(r);if(!a)throw new $({signature:r,type:"struct"});const s=a.properties.split(";"),i=[],o=s.length;for(let e=0;e<o;e++){const t=s[e].trim();if(!t)continue;const r=k(t,{type:"struct"});i.push(r)}if(!i.length)throw new I({signature:r});t[a.name]=i}const n={},a=Object.entries(t),s=a.length;for(let e=0;e<s;e++){const[r,s]=a[e];n[r]=Z(s,t)}return n}(e),n=e.length;for(let a=0;a<n;a++){const n=e[a];if(f(n))continue;const s=E(n),i=s.length;for(let e=0;e<i;e++)t.push(k(s[e],{modifiers:h,structs:r}))}}if(0===t.length)throw new a({params:e});return t}}}]);
//# sourceMappingURL=npm.abitype.fbf95f33f80f68ed577b.js.map