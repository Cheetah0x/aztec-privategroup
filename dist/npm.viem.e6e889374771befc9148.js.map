{"version":3,"file":"npm.viem.e6e889374771befc9148.js","mappings":"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","sources":["webpack://publicgroups/./node_modules/viem/_esm/utils/data/isHex.js","webpack://publicgroups/./node_modules/viem/_esm/utils/data/size.js","webpack://publicgroups/./node_modules/viem/_esm/errors/version.js","webpack://publicgroups/./node_modules/viem/_esm/errors/base.js","webpack://publicgroups/./node_modules/viem/_esm/errors/abi.js","webpack://publicgroups/./node_modules/viem/_esm/errors/address.js","webpack://publicgroups/./node_modules/viem/_esm/utils/lru.js","webpack://publicgroups/./node_modules/viem/_esm/errors/data.js","webpack://publicgroups/./node_modules/viem/_esm/utils/data/pad.js","webpack://publicgroups/./node_modules/viem/_esm/errors/encoding.js","webpack://publicgroups/./node_modules/viem/_esm/utils/encoding/fromHex.js","webpack://publicgroups/./node_modules/viem/_esm/utils/encoding/toHex.js","webpack://publicgroups/./node_modules/viem/_esm/utils/encoding/toBytes.js","webpack://publicgroups/./node_modules/viem/_esm/utils/hash/keccak256.js","webpack://publicgroups/./node_modules/viem/_esm/utils/address/getAddress.js","webpack://publicgroups/./node_modules/viem/_esm/utils/address/isAddress.js","webpack://publicgroups/./node_modules/viem/_esm/utils/data/concat.js","webpack://publicgroups/./node_modules/viem/_esm/utils/data/slice.js","webpack://publicgroups/./node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"],"sourcesContent":["export function isHex(value, { strict = true } = {}) {\n    if (!value)\n        return false;\n    if (typeof value !== 'string')\n        return false;\n    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');\n}\n//# sourceMappingURL=isHex.js.map","import { isHex } from './isHex.js';\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value) {\n    if (isHex(value, { strict: false }))\n        return Math.ceil((value.length - 2) / 2);\n    return value.length;\n}\n//# sourceMappingURL=size.js.map","export const version = '2.21.16';\n//# sourceMappingURL=version.js.map","import { version } from './version.js';\nlet errorConfig = {\n    getDocsUrl: ({ docsBaseUrl, docsPath = '', docsSlug, }) => docsPath\n        ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}`\n        : undefined,\n    version,\n};\nexport function setErrorConfig(config) {\n    errorConfig = config;\n}\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        const details = (() => {\n            if (args.cause instanceof BaseError)\n                return args.cause.details;\n            if (args.cause?.message)\n                return args.cause.message;\n            return args.details;\n        })();\n        const docsPath = (() => {\n            if (args.cause instanceof BaseError)\n                return args.cause.docsPath || args.docsPath;\n            return args.docsPath;\n        })();\n        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });\n        const message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsUrl ? [`Docs: ${docsUrl}`] : []),\n            ...(details ? [`Details: ${details}`] : []),\n            ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),\n        ].join('\\n');\n        super(message, args.cause ? { cause: args.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.name = args.name ?? this.name;\n        this.shortMessage = shortMessage;\n        this.version = version;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=base.js.map","import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js';\nimport { size } from '../utils/data/size.js';\nimport { BaseError } from './base.js';\nexport class AbiConstructorNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'A constructor was not found on the ABI.',\n            'Make sure you are using the correct ABI and that the constructor exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiConstructorNotFoundError',\n        });\n    }\n}\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n    constructor({ docsPath }) {\n        super([\n            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiConstructorParamsNotFoundError',\n        });\n    }\n}\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n    constructor({ data, size }) {\n        super([\n            `Data size of ${size} bytes is invalid.`,\n            'Size must be in increments of 32 bytes (size % 32 === 0).',\n        ].join('\\n'), {\n            metaMessages: [`Data: ${data} (${size} bytes)`],\n            name: 'AbiDecodingDataSizeInvalidError',\n        });\n    }\n}\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n    constructor({ data, params, size, }) {\n        super([`Data size of ${size} bytes is too small for given parameters.`].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n            name: 'AbiDecodingDataSizeTooSmallError',\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n            name: 'AbiDecodingZeroDataError',\n        });\n    }\n}\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super([\n            `ABI encoding array length mismatch for type ${type}.`,\n            `Expected length: ${expectedLength}`,\n            `Given length: ${givenLength}`,\n        ].join('\\n'), { name: 'AbiEncodingArrayLengthMismatchError' });\n    }\n}\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, value }) {\n        super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: 'AbiEncodingBytesSizeMismatchError' });\n    }\n}\nexport class AbiEncodingLengthMismatchError extends BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding params/values length mismatch.',\n            `Expected length (params): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'), { name: 'AbiEncodingLengthMismatchError' });\n    }\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n    constructor(errorName, { docsPath }) {\n        super([\n            `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n            'Cannot encode error result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the inputs exist on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorInputsNotFoundError',\n        });\n    }\n}\nexport class AbiErrorNotFoundError extends BaseError {\n    constructor(errorName, { docsPath } = {}) {\n        super([\n            `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorNotFoundError',\n        });\n    }\n}\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded error signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the error exists on it.',\n            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiErrorSignatureNotFoundError',\n        });\n        Object.defineProperty(this, \"signature\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.signature = signature;\n    }\n}\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n    constructor({ docsPath }) {\n        super('Cannot extract event signature from empty topics.', {\n            docsPath,\n            name: 'AbiEventSignatureEmptyTopicsError',\n        });\n    }\n}\nexport class AbiEventSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded event signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiEventSignatureNotFoundError',\n        });\n    }\n}\nexport class AbiEventNotFoundError extends BaseError {\n    constructor(eventName, { docsPath } = {}) {\n        super([\n            `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the event exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiEventNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n    constructor(functionName, { docsPath } = {}) {\n        super([\n            `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n    constructor(functionName, { docsPath }) {\n        super([\n            `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n            'Cannot decode function result without knowing what the parameter types are.',\n            'Make sure you are using the correct ABI and that the function exists on it.',\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionOutputsNotFoundError',\n        });\n    }\n}\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n    constructor(signature, { docsPath }) {\n        super([\n            `Encoded function signature \"${signature}\" not found on ABI.`,\n            'Make sure you are using the correct ABI and that the function exists on it.',\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n        ].join('\\n'), {\n            docsPath,\n            name: 'AbiFunctionSignatureNotFoundError',\n        });\n    }\n}\nexport class AbiItemAmbiguityError extends BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI items.', {\n            metaMessages: [\n                `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n                `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n            name: 'AbiItemAmbiguityError',\n        });\n    }\n}\nexport class BytesSizeMismatchError extends BaseError {\n    constructor({ expectedSize, givenSize, }) {\n        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n            name: 'BytesSizeMismatchError',\n        });\n    }\n}\nexport class DecodeLogDataMismatch extends BaseError {\n    constructor({ abiItem, data, params, size, }) {\n        super([\n            `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n        ].join('\\n'), {\n            metaMessages: [\n                `Params: (${formatAbiParams(params, { includeName: true })})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n            name: 'DecodeLogDataMismatch',\n        });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"params\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n        this.data = data;\n        this.params = params;\n        this.size = size;\n    }\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n    constructor({ abiItem, param, }) {\n        super([\n            `Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : ''} on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n        ].join('\\n'), { name: 'DecodeLogTopicsMismatch' });\n        Object.defineProperty(this, \"abiItem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.abiItem = abiItem;\n    }\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid encoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath, name: 'InvalidAbiEncodingType' });\n    }\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n    constructor(type, { docsPath }) {\n        super([\n            `Type \"${type}\" is not a valid decoding type.`,\n            'Please provide a valid ABI type.',\n        ].join('\\n'), { docsPath, name: 'InvalidAbiDecodingType' });\n    }\n}\nexport class InvalidArrayError extends BaseError {\n    constructor(value) {\n        super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n            name: 'InvalidArrayError',\n        });\n    }\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n    constructor(type) {\n        super([\n            `\"${type}\" is not a valid definition type.`,\n            'Valid types: \"function\", \"event\", \"error\"',\n        ].join('\\n'), { name: 'InvalidDefinitionTypeError' });\n    }\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n    constructor(type) {\n        super(`Type \"${type}\" is not supported for packed encoding.`, {\n            name: 'UnsupportedPackedAbiType',\n        });\n    }\n}\n//# sourceMappingURL=abi.js.map","import { BaseError } from './base.js';\nexport class InvalidAddressError extends BaseError {\n    constructor({ address }) {\n        super(`Address \"${address}\" is invalid.`, {\n            metaMessages: [\n                '- Address must be a hex value of 20 bytes (40 hex characters).',\n                '- Address must match its checksum counterpart.',\n            ],\n            name: 'InvalidAddressError',\n        });\n    }\n}\n//# sourceMappingURL=address.js.map","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map","import { BaseError } from './base.js';\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \"${offset}\" is out-of-bounds (size: ${size}).`, { name: 'SliceOffsetOutOfBoundsError' });\n    }\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, { name: 'SizeExceedsPaddingSizeError' });\n    }\n}\nexport class InvalidBytesLengthError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`, { name: 'InvalidBytesLengthError' });\n    }\n}\n//# sourceMappingURL=data.js.map","import { SizeExceedsPaddingSizeError, } from '../../errors/data.js';\nexport function pad(hexOrBytes, { dir, size = 32 } = {}) {\n    if (typeof hexOrBytes === 'string')\n        return padHex(hexOrBytes, { dir, size });\n    return padBytes(hexOrBytes, { dir, size });\n}\nexport function padHex(hex_, { dir, size = 32 } = {}) {\n    if (size === null)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\nexport function padBytes(bytes, { dir, size = 32 } = {}) {\n    if (size === null)\n        return bytes;\n    if (bytes.length > size)\n        throw new SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n//# sourceMappingURL=pad.js.map","import { BaseError } from './base.js';\nexport class IntegerOutOfRangeError extends BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \"${value}\" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: 'IntegerOutOfRangeError' });\n    }\n}\nexport class InvalidBytesBooleanError extends BaseError {\n    constructor(bytes) {\n        super(`Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {\n            name: 'InvalidBytesBooleanError',\n        });\n    }\n}\nexport class InvalidHexBooleanError extends BaseError {\n    constructor(hex) {\n        super(`Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`, { name: 'InvalidHexBooleanError' });\n    }\n}\nexport class InvalidHexValueError extends BaseError {\n    constructor(value) {\n        super(`Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`, { name: 'InvalidHexValueError' });\n    }\n}\nexport class SizeOverflowError extends BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: 'SizeOverflowError' });\n    }\n}\n//# sourceMappingURL=encoding.js.map","import { InvalidHexBooleanError, SizeOverflowError, } from '../../errors/encoding.js';\nimport { size as size_ } from '../data/size.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBytes } from './toBytes.js';\nexport function assertSize(hexOrBytes, { size }) {\n    if (size_(hexOrBytes) > size)\n        throw new SizeOverflowError({\n            givenSize: size_(hexOrBytes),\n            maxSize: size,\n        });\n}\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex(hex, toOrOpts) {\n    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;\n    const to = opts.to;\n    if (to === 'number')\n        return hexToNumber(hex, opts);\n    if (to === 'bigint')\n        return hexToBigInt(hex, opts);\n    if (to === 'string')\n        return hexToString(hex, opts);\n    if (to === 'boolean')\n        return hexToBool(hex, opts);\n    return hexToBytes(hex, opts);\n}\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex, opts = {}) {\n    const { signed } = opts;\n    if (opts.size)\n        assertSize(hex, { size: opts.size });\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n    if (value <= max)\n        return value;\n    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = trim(hex);\n    }\n    if (trim(hex) === '0x00')\n        return false;\n    if (trim(hex) === '0x01')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex, opts = {}) {\n    return Number(hexToBigInt(hex, opts));\n}\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex, opts = {}) {\n    let bytes = hexToBytes(hex);\n    if (opts.size) {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes, { dir: 'right' });\n    }\n    return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromHex.js.map","import { IntegerOutOfRangeError, } from '../../errors/encoding.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToHex(value, opts);\n    if (typeof value === 'string') {\n        return stringToHex(value, opts);\n    }\n    if (typeof value === 'boolean')\n        return boolToHex(value, opts);\n    return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value, opts = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value, opts = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++) {\n        string += hexes[value[i]];\n    }\n    const hex = `0x${string}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { dir: 'right', size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(value_, opts = {}) {\n    const { signed, size } = opts;\n    const value = BigInt(value_);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value_ === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value > maxValue) || value < minValue) {\n        const suffix = typeof value_ === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value_}${suffix}`,\n        });\n    }\n    const hex = `0x${(signed && value < 0\n        ? (1n << BigInt(size * 8)) + BigInt(value)\n        : value).toString(16)}`;\n    if (size)\n        return pad(hex, { size });\n    return hex;\n}\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_, opts = {}) {\n    const value = encoder.encode(value_);\n    return bytesToHex(value, opts);\n}\n//# sourceMappingURL=toHex.js.map","import { BaseError } from '../../errors/base.js';\nimport { isHex } from '../data/isHex.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nimport { numberToHex, } from './toHex.js';\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToBytes(value, opts);\n    if (typeof value === 'boolean')\n        return boolToBytes(value, opts);\n    if (isHex(value))\n        return hexToBytes(value, opts);\n    return stringToBytes(value, opts);\n}\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value, opts = {}) {\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { size: opts.size });\n    }\n    return bytes;\n}\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = pad(hex, { dir: 'right', size: opts.size });\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value, opts) {\n    const hex = numberToHex(value, opts);\n    return hexToBytes(hex);\n}\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(value, opts = {}) {\n    const bytes = encoder.encode(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { dir: 'right', size: opts.size });\n    }\n    return bytes;\n}\n//# sourceMappingURL=toBytes.js.map","import { keccak_256 } from '@noble/hashes/sha3';\nimport { isHex } from '../data/isHex.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toHex } from '../encoding/toHex.js';\nexport function keccak256(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return toHex(bytes);\n}\n//# sourceMappingURL=keccak256.js.map","import { InvalidAddressError } from '../../errors/address.js';\nimport { stringToBytes, } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { LruMap } from '../lru.js';\nimport { isAddress } from './isAddress.js';\nconst checksumAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function checksumAddress(address_, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (checksumAddressCache.has(`${address_}.${chainId}`))\n        return checksumAddressCache.get(`${address_}.${chainId}`);\n    const hexAddress = chainId\n        ? `${chainId}${address_.toLowerCase()}`\n        : address_.substring(2).toLowerCase();\n    const hash = keccak256(stringToBytes(hexAddress), 'bytes');\n    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n            address[i] = address[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n            address[i + 1] = address[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${address.join('')}`;\n    checksumAddressCache.set(`${address_}.${chainId}`, result);\n    return result;\n}\nexport function getAddress(address, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (!isAddress(address, { strict: false }))\n        throw new InvalidAddressError({ address });\n    return checksumAddress(address, chainId);\n}\n//# sourceMappingURL=getAddress.js.map","import { LruMap } from '../lru.js';\nimport { checksumAddress } from './getAddress.js';\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function isAddress(address, options) {\n    const { strict = true } = options ?? {};\n    const cacheKey = `${address}.${strict}`;\n    if (isAddressCache.has(cacheKey))\n        return isAddressCache.get(cacheKey);\n    const result = (() => {\n        if (!addressRegex.test(address))\n            return false;\n        if (address.toLowerCase() === address)\n            return true;\n        if (strict)\n            return checksumAddress(address) === address;\n        return true;\n    })();\n    isAddressCache.set(cacheKey, result);\n    return result;\n}\n//# sourceMappingURL=isAddress.js.map","export function concat(values) {\n    if (typeof values[0] === 'string')\n        return concatHex(values);\n    return concatBytes(values);\n}\nexport function concatBytes(values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const arr of values) {\n        result.set(arr, offset);\n        offset += arr.length;\n    }\n    return result;\n}\nexport function concatHex(values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n//# sourceMappingURL=concat.js.map","import { SliceOffsetOutOfBoundsError, } from '../../errors/data.js';\nimport { isHex } from './isHex.js';\nimport { size } from './size.js';\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice(value, start, end, { strict } = {}) {\n    if (isHex(value, { strict: false }))\n        return sliceHex(value, start, end, {\n            strict,\n        });\n    return sliceBytes(value, start, end, {\n        strict,\n    });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n        throw new SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        size(value) !== end - start) {\n        throw new SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: size(value),\n        });\n    }\n}\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = value_.slice(start, end);\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = `0x${value_\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n//# sourceMappingURL=slice.js.map","import { AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, InvalidAbiEncodingTypeError, InvalidArrayError, } from '../../errors/abi.js';\nimport { InvalidAddressError, } from '../../errors/address.js';\nimport { BaseError } from '../../errors/base.js';\nimport { isAddress } from '../address/isAddress.js';\nimport { concat } from '../data/concat.js';\nimport { padHex } from '../data/pad.js';\nimport { size } from '../data/size.js';\nimport { slice } from '../data/slice.js';\nimport { boolToHex, numberToHex, stringToHex, } from '../encoding/toHex.js';\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters(params, values) {\n    if (params.length !== values.length)\n        throw new AbiEncodingLengthMismatchError({\n            expectedLength: params.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParams = prepareParams({\n        params: params,\n        values: values,\n    });\n    const data = encodeParams(preparedParams);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\nfunction prepareParams({ params, values, }) {\n    const preparedParams = [];\n    for (let i = 0; i < params.length; i++) {\n        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));\n    }\n    return preparedParams;\n}\nfunction prepareParam({ param, value, }) {\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, { length, param: { ...param, type } });\n    }\n    if (param.type === 'tuple') {\n        return encodeTuple(value, {\n            param: param,\n        });\n    }\n    if (param.type === 'address') {\n        return encodeAddress(value);\n    }\n    if (param.type === 'bool') {\n        return encodeBool(value);\n    }\n    if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n        const signed = param.type.startsWith('int');\n        return encodeNumber(value, { signed });\n    }\n    if (param.type.startsWith('bytes')) {\n        return encodeBytes(value, { param });\n    }\n    if (param.type === 'string') {\n        return encodeString(value);\n    }\n    throw new InvalidAbiEncodingTypeError(param.type, {\n        docsPath: '/docs/contract/encodeAbiParameters',\n    });\n}\nfunction encodeParams(preparedParams) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParams = [];\n    const dynamicParams = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParams.length; i++) {\n        const { dynamic, encoded } = preparedParams[i];\n        if (dynamic) {\n            staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n            dynamicParams.push(encoded);\n            dynamicSize += size(encoded);\n        }\n        else {\n            staticParams.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return concat([...staticParams, ...dynamicParams]);\n}\nfunction encodeAddress(value) {\n    if (!isAddress(value))\n        throw new InvalidAddressError({ address: value });\n    return { dynamic: false, encoded: padHex(value.toLowerCase()) };\n}\nfunction encodeArray(value, { length, param, }) {\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiEncodingArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${param.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParams = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParam({ param, value: value[i] });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParams.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encodeParams(preparedParams);\n        if (dynamic) {\n            const length = numberToHex(preparedParams.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nfunction encodeBytes(value, { param }) {\n    const [, paramSize] = param.type.split('bytes');\n    const bytesSize = size(value);\n    if (!paramSize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = padHex(value_, {\n                dir: 'right',\n                size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n            });\n        return {\n            dynamic: true,\n            encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n        };\n    }\n    if (bytesSize !== Number.parseInt(paramSize))\n        throw new AbiEncodingBytesSizeMismatchError({\n            expectedSize: Number.parseInt(paramSize),\n            value,\n        });\n    return { dynamic: false, encoded: padHex(value, { dir: 'right' }) };\n}\nfunction encodeBool(value) {\n    if (typeof value !== 'boolean')\n        throw new BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\nfunction encodeNumber(value, { signed }) {\n    return {\n        dynamic: false,\n        encoded: numberToHex(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\nfunction encodeString(value) {\n    const hexValue = stringToHex(value);\n    const partsLength = Math.ceil(size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n            dir: 'right',\n        }));\n    }\n    return {\n        dynamic: true,\n        encoded: concat([\n            padHex(numberToHex(size(hexValue), { size: 32 })),\n            ...parts,\n        ]),\n    };\n}\nfunction encodeTuple(value, { param }) {\n    let dynamic = false;\n    const preparedParams = [];\n    for (let i = 0; i < param.components.length; i++) {\n        const param_ = param.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParam({\n            param: param_,\n            value: value[index],\n        });\n        preparedParams.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encodeParams(preparedParams)\n            : concat(preparedParams.map(({ encoded }) => encoded)),\n    };\n}\nexport function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n//# sourceMappingURL=encodeAbiParameters.js.map"],"names":["isHex","value","strict","test","startsWith","Math","ceil","length","version","errorConfig","docsBaseUrl","docsPath","docsSlug","undefined","BaseError","Error","constructor","shortMessage","args","details","cause","message","docsUrl","super","metaMessages","join","Object","defineProperty","this","enumerable","configurable","writable","name","walk","fn","err","AbiEncodingArrayLengthMismatchError","expectedLength","givenLength","type","AbiEncodingBytesSizeMismatchError","expectedSize","AbiEncodingLengthMismatchError","InvalidAbiEncodingTypeError","InvalidArrayError","address","LruMap","Map","size","maxSize","get","key","has","delete","set","firstKey","keys","next","SliceOffsetOutOfBoundsError","offset","position","SizeExceedsPaddingSizeError","targetSize","charAt","toUpperCase","slice","toLowerCase","pad","hexOrBytes","dir","padHex","bytes","paddedBytes","Uint8Array","i","padEnd","padBytes","hex_","hex","replace","IntegerOutOfRangeError","max","min","signed","SizeOverflowError","givenSize","assertSize","hexes","Array","from","_v","toString","padStart","boolToHex","opts","Number","bytesToHex","string","numberToHex","value_","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","encoder","TextEncoder","stringToHex","encode","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","hexString","index","j","nibbleLeft","charCodeAt","nibbleRight","stringToBytes","keccak256","to_","to","numberToBytes","boolToBytes","toBytes","toHex","checksumAddressCache","addressRegex","isAddressCache","concat","values","reduce","acc","x","concatHex","arr","result","concatBytes","start","end","assertStartOffset","assertEndOffset","sliceHex","sliceBytes","encodeAbiParameters","params","preparedParams","push","prepareParam","param","prepareParams","data","encodeParams","arrayComponents","matches","match","getArrayComponents","dynamic","isArray","dynamicChild","preparedParam","encoded","map","encodeArray","components","param_","encodeTuple","cacheKey","address_","chainId","hexAddress","substring","hash","split","checksumAddress","encodeAddress","encodeBool","encodeNumber","paramSize","bytesSize","parseInt","encodeBytes","hexValue","partsLength","parts","encodeString","staticSize","staticParams","dynamicParams","dynamicSize"],"sourceRoot":""}